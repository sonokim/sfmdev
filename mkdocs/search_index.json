{
    "docs": [
        {
            "location": "/",
            "text": "SFM Developer Center\n\u00b6\n\n\nWhat is SFM?\n\u00b6\n\n\nSFM (Suprema Fingerprint Module) is the world's most widely used fingerprint module manufactured by Suprema inc. It provides the most powerful fingerprint recognition performance than other competitors. \n\n\nWhat is SFM Developer Center?\n\u00b6\n\n\nSFM Developer Center is an online space that provides technical information and technical communication with customers. In SFM Developer Center, We will open various open source projects using SFM to provide the opportunity to utilize fingerprint recognition technology not only for fingerprint recognition experts but also for those interested in hobbies such as start-up companies or DIY. \n\n\nSuprema inc.\n\nSuprema is a global leader in biometrics and securities technology. By combining world renowned biometric algorithms with superior engineering,Suprema is able to continually develop and manufacture reliable industry leading products. Suprema\u2019s extensive portfolio of products include biometric access control systems, time & attendance devices, fingerprint/live scanners and embedded fingerprint modules.\nSuprema supports world wide sales network that spans across more than 133 countries around the world and was the first biometrics company listed on Korea's stock market (\nKOSDAQ 094840\n)",
            "title": "About"
        },
        {
            "location": "/#sfm-developer-center",
            "text": "",
            "title": "SFM Developer Center"
        },
        {
            "location": "/#what-is-sfm",
            "text": "SFM (Suprema Fingerprint Module) is the world's most widely used fingerprint module manufactured by Suprema inc. It provides the most powerful fingerprint recognition performance than other competitors.",
            "title": "What is SFM?"
        },
        {
            "location": "/#what-is-sfm-developer-center",
            "text": "SFM Developer Center is an online space that provides technical information and technical communication with customers. In SFM Developer Center, We will open various open source projects using SFM to provide the opportunity to utilize fingerprint recognition technology not only for fingerprint recognition experts but also for those interested in hobbies such as start-up companies or DIY.   Suprema inc. \nSuprema is a global leader in biometrics and securities technology. By combining world renowned biometric algorithms with superior engineering,Suprema is able to continually develop and manufacture reliable industry leading products. Suprema\u2019s extensive portfolio of products include biometric access control systems, time & attendance devices, fingerprint/live scanners and embedded fingerprint modules.\nSuprema supports world wide sales network that spans across more than 133 countries around the world and was the first biometrics company listed on Korea's stock market ( KOSDAQ 094840 )",
            "title": "What is SFM Developer Center?"
        },
        {
            "location": "/products/SFM3000/",
            "text": "SFM3000 Series\n\u00b6\n\n\nCore Features, World Class Technology\n\n\nSFM3000 is a cost effective fingerprint identification module\nequipped with essential part for fingerprint identification\nand template storage. SFM3000 is suitable for most of the\napplications where it processes fingerprint recognition and\nhost controller is used to handle other operations. The\ncommunication between SFM3000 and host controller is\ndone by packet protocol through CMOS level serial interface.\n\n\nFeatures\n\u00b6\n\n\n\n\nHigh Performance 400MHz DSP\n\n\nFast Power-on Time\n\n\nSuprema, ISO19794-2 and ANSI 378 Template Options\n\n\n8 Configurable Digital I/O Ports\n\n\nLow Power Consumption\n\n\n256-bit AES Fingerprint Data Encryption\n\n\n\n\nAvailable Models\n\u00b6\n\n\nSFM3050-TC\n\u00b6\n\n\n\n\n\n\nUPEK TouchChip Sensor\n\n\nCapacitive type sensor\n\n\nPerfectPrint technology\n\n\nReliable high quality fingerprint image\n\n\n\n\nSFM3050-TC2S\n\u00b6\n\n\n\n\n\n\nUPEK Steel-Coated TouchChip Sensor\n\n\nIP67 rated dust and water protection\n\n\nCapacitive sensor\n\n\nPerfectPrint technology\n\n\nReliable high quality fingerprint image\n\n\n\n\nSpecification\n\u00b6\n\n\n\n\n\n    \n     \n        \n\n            \nSensor\n           \n            \nSensor Option\n          \n            \nCapacitive\n\n        \n\n        \n\n            \nMain\n\n            \nCPU\n\n            \n400MHz DSP\n \n        \n\n        \n\n            \nFlash Memory\n\n            \n1MB\n(4MB Option))\n\n        \n\n        \n\n            \nEER\n\n            \n<\n 0.1%\n\n        \n\n        \n\n            \nEnrollment Time\n(Sensor Dependent)\n\n            \n<\n 800ms TC1\n<\n 500ms TC2/TC2S\n\n        \n\n        \n\n            \n1:1 Verification Time\n(Sensor Dependent)\n\n            \n<\n 800ms TC1\n<\n 500ms TC2/TC2S\n\n        \n\n        \n\n            \n1:1000 ID Time*\n(Sensor Dependent)\n\n            \n<\n 970ms TC1\n<\n 640ms TC2/TC2S\n\n        \n\n        \n\n            \nTemplate Options\n\n            \nSuprema, ISO19794-2, ANSI 378\n\n        \n\n        \n\n            \nTemplate Size\n(Default: 384 Bytes)\n\n            \n256 to 384 Bytes\n(Configurable)\n\n        \n\n        \n\n            \nTemplate Capacity\n\n            \n1,900 @ 1 MB Flash\n9,500 @ 4 MB Flash\n\n        \n\n        \n\n            \nLog Capacity\n\n            \n-\n\n        \n\n        \n\n            \nFingerprint Data Encryption\n\n            \n256-bit AES\n            \n        \n\n        \n\n            \nInterface\n            \n            \nHost Comm.\n         \n            \nAsync. Serial:\nCMOS level\nup to 460800 bps\n\n        \n\n        \n\n            \nAux Comm.\n\n            \n-\n  \n        \n\n        \n\n            \nWiegand Interface\n\n            \n-\n\n        \n\n        \n\n            \nExternal I/O\n\n            \n8x Digital I/O\n         \n        \n\n        \n\n            \nHardware\n         \n            \nSupply Voltage\n         \n            \n3.3 VDC Regulated\n\n        \n\n        \n\n            \nBoard Size\n\n            \n55 x 40 x 8 mm (L x W x H)\n \n        \n       \n    \n\n\n\n\n\n\n\n\n\n\n\n  \n\n    \nModel\n\n    \nSFM3000\n\n  \n\n  \n\n    \nSFM3050-TC1\n    \n    \nSFM3050-TC2\n    \n    \nSFM3050-TC2S\n    \n  \n\n  \n\n    \nSensor Type\n\n    \nCapacitive\n\n  \n\n  \n\n    \nSensor Options\n\n    \nTC1\n\n    \nTC2\n\n    \nTC2S\n\n  \n\n  \n\n    \nResolution (dpi)\n\n    \n508\n\n    \n508\n\n    \n508\n\n  \n\n  \n\n    \nSensing Area (mm)\n\n    \n12.8 x 18.0\n\n    \n10.4 x 14.4\n\n    \n10.4 x 14.4\n\n  \n\n  \n\n    \nImage Size (px)\n\n    \n256 x 360\n\n    \n208 x 288\n\n    \n208 x 340\n\n  \n\n  \n\n    \nFinger Rotation\n\n    \n+/- 90'\n\n    \n+/- 90'\n\n    \n+/- 90'\n\n  \n\n  \n\n    \nSensor Dimension\n(L x W x H) (mm)\n\n    \n20.4 x 27 x 3.5\n\n    \n20.4 x 27 x 3.5\n\n    \n20.4 x 33.4 x 3.57\n\n  \n\n \n\n\n\n\n\n\n\nAccessories\n\u00b6\n\n\n\n\n\n\n\n\nRelated links\n\u00b6\n\n\nDatasheets\n\u00b6\n\n\n\n\nSFM3050-TC2\n\n\nSFM3050-TC2S\n\n\n\n\nDocuments\n\u00b6\n\n\n\n\nUF Protocol Manual\n\n\n\n\nSoftware\n\u00b6\n\n\n\n\nUnifingerUI",
            "title": "SFM3000 Series"
        },
        {
            "location": "/products/SFM3000/#sfm3000-series",
            "text": "Core Features, World Class Technology  SFM3000 is a cost effective fingerprint identification module\nequipped with essential part for fingerprint identification\nand template storage. SFM3000 is suitable for most of the\napplications where it processes fingerprint recognition and\nhost controller is used to handle other operations. The\ncommunication between SFM3000 and host controller is\ndone by packet protocol through CMOS level serial interface.",
            "title": "SFM3000 Series"
        },
        {
            "location": "/products/SFM3000/#features",
            "text": "High Performance 400MHz DSP  Fast Power-on Time  Suprema, ISO19794-2 and ANSI 378 Template Options  8 Configurable Digital I/O Ports  Low Power Consumption  256-bit AES Fingerprint Data Encryption",
            "title": "Features"
        },
        {
            "location": "/products/SFM3000/#available-models",
            "text": "",
            "title": "Available Models"
        },
        {
            "location": "/products/SFM3000/#sfm3050-tc",
            "text": "UPEK TouchChip Sensor  Capacitive type sensor  PerfectPrint technology  Reliable high quality fingerprint image",
            "title": "SFM3050-TC"
        },
        {
            "location": "/products/SFM3000/#sfm3050-tc2s",
            "text": "UPEK Steel-Coated TouchChip Sensor  IP67 rated dust and water protection  Capacitive sensor  PerfectPrint technology  Reliable high quality fingerprint image",
            "title": "SFM3050-TC2S"
        },
        {
            "location": "/products/SFM3000/#specification",
            "text": "Sensor            \n             Sensor Option           \n             Capacitive \n         \n         \n             Main \n             CPU \n             400MHz DSP  \n         \n         \n             Flash Memory \n             1MB (4MB Option)) \n         \n         \n             EER \n             <  0.1% \n         \n         \n             Enrollment Time (Sensor Dependent) \n             <  800ms TC1 <  500ms TC2/TC2S \n         \n         \n             1:1 Verification Time (Sensor Dependent) \n             <  800ms TC1 <  500ms TC2/TC2S \n         \n         \n             1:1000 ID Time* (Sensor Dependent) \n             <  970ms TC1 <  640ms TC2/TC2S \n         \n         \n             Template Options \n             Suprema, ISO19794-2, ANSI 378 \n         \n         \n             Template Size (Default: 384 Bytes) \n             256 to 384 Bytes (Configurable) \n         \n         \n             Template Capacity \n             1,900 @ 1 MB Flash 9,500 @ 4 MB Flash \n         \n         \n             Log Capacity \n             - \n         \n         \n             Fingerprint Data Encryption \n             256-bit AES             \n         \n         \n             Interface             \n             Host Comm.          \n             Async. Serial: CMOS level up to 460800 bps \n         \n         \n             Aux Comm. \n             -   \n         \n         \n             Wiegand Interface \n             - \n         \n         \n             External I/O \n             8x Digital I/O          \n         \n         \n             Hardware          \n             Supply Voltage          \n             3.3 VDC Regulated \n         \n         \n             Board Size \n             55 x 40 x 8 mm (L x W x H)  \n                \n         \n   \n     Model \n     SFM3000 \n   \n   \n     SFM3050-TC1     \n     SFM3050-TC2     \n     SFM3050-TC2S     \n   \n   \n     Sensor Type \n     Capacitive \n   \n   \n     Sensor Options \n     TC1 \n     TC2 \n     TC2S \n   \n   \n     Resolution (dpi) \n     508 \n     508 \n     508 \n   \n   \n     Sensing Area (mm) \n     12.8 x 18.0 \n     10.4 x 14.4 \n     10.4 x 14.4 \n   \n   \n     Image Size (px) \n     256 x 360 \n     208 x 288 \n     208 x 340 \n   \n   \n     Finger Rotation \n     +/- 90' \n     +/- 90' \n     +/- 90' \n   \n   \n     Sensor Dimension (L x W x H) (mm) \n     20.4 x 27 x 3.5 \n     20.4 x 27 x 3.5 \n     20.4 x 33.4 x 3.57",
            "title": "Specification"
        },
        {
            "location": "/products/SFM3000/#accessories",
            "text": "",
            "title": "Accessories"
        },
        {
            "location": "/products/SFM3000/#related-links",
            "text": "",
            "title": "Related links"
        },
        {
            "location": "/products/SFM3000/#datasheets",
            "text": "SFM3050-TC2  SFM3050-TC2S",
            "title": "Datasheets"
        },
        {
            "location": "/products/SFM3000/#documents",
            "text": "UF Protocol Manual",
            "title": "Documents"
        },
        {
            "location": "/products/SFM3000/#software",
            "text": "UnifingerUI",
            "title": "Software"
        },
        {
            "location": "/products/SFM4000/",
            "text": "SFM4000 Series\n\u00b6\n\n\nSFM4000 is a compact, power efficient module that is simple\nto integrate with various system applications. The module\noffers flexible supply voltage, integrated power management,\nsmall footprint, and voltage detector functions. SFM4000 is\nspecially designed for lock and safe manufacturers look for\nan inexpensive, reliable biometric solution with extra low\npower-consumption and compact size.\n\n\nFeatures\n\u00b6\n\n\n\n\nIntegrated power control circuit\n\n\nSuprema, ISO 19794-2 and ANSI 378 template options\n\n\nSerial Interface with simple protocol\n\n\n4 configurable Digital I/O ports\n\n\nSingle 3.3 VDC regulated power source\n\n\n256-bit AES fingerprint data encryption\n\n\n\n\nAvailable Models\n\u00b6\n\n\nSFM4020-OP\n\u00b6\n\n\n\n\n\n\nOptical Sensor\n\n\nRobust optical fingerprint sensor\n\n\nSolid and scratch-free sensor surface\n\n\nReliable high quality fingerprint image for wet & dry fingers\n\n\nSensor surface optimized to capture the ideal fingerprint image\n\n\n\n\nSpecification\n\u00b6\n\n\n\n\n\n    \n     \n        \n\n            \nSensor\n           \n            \nSensor Option\n          \n            \nOptical\n\n        \n\n        \n\n            \nMain\n\n            \nCPU\n\n            \n400MHz DSP\n \n        \n\n        \n\n            \nFlash Memory\n\n            \n1MB\n\n        \n\n        \n\n            \nEER\n\n            \n<\n 0.1%\n\n        \n\n        \n\n            \nEnrollment Time\n(Sensor Dependent)\n\n            \n<\n 800ms OP5\n\n        \n\n        \n\n            \n1:1 Verification Time\n(Sensor Dependent)\n\n            \n<\n 800ms OP5\n\n        \n\n        \n\n            \n1:1000 ID Time*\n(Sensor Dependent)\n\n            \n<\n 970ms OP5\n\n        \n\n        \n\n            \nTemplate Options\n\n            \nSuprema, ISO19794-2, ANSI 378\n\n        \n\n        \n\n            \nTemplate Size\n(Default: 384 Bytes)\n\n            \n256 to 384 Bytes\n(Configurable)\n\n        \n\n        \n\n            \nTemplate Capacity\n\n            \n1,900 @ 1 MB Flash\n\n        \n\n        \n\n            \nLog Capacity\n\n            \n-\n\n        \n\n        \n\n            \nFingerprint Data Encryption\n\n            \n256-bit AES\n            \n        \n\n        \n\n            \nInterface\n            \n            \nHost Comm.\n         \n            \nAsync. Serial:\nCMOS level\nup to 460800 bps\n\n        \n\n        \n\n            \nAux Comm.\n\n            \n-\n  \n        \n\n        \n\n            \nWiegand Interface\n\n            \n-\n\n        \n\n        \n\n            \nExternal I/O\n\n            \n4x Digital I/O\n         \n        \n\n        \n\n            \nHardware\n         \n            \nSupply Voltage\n         \n            \n3.3 VDC Regulated\n\n        \n\n        \n\n            \nBoard Size\n\n            \n26 x 26 x 6.4 mm (L x W x H)\n   \n        \n       \n    \n\n\n\n\n\n\u00a0\n\n\n\u00a0\n\n\n\n\n\n\n  \n\n    \nModel\n\n    \nSFM4000\n\n  \n\n  \n\n    \nSFM4020-OP5\n    \n  \n\n  \n\n    \nSensor Type\n\n    \nOptical\n\n  \n\n  \n\n    \nSensor Options\n\n    \nOP5\n\n  \n\n  \n\n    \nResolution (dpi)\n\n    \n500\n\n  \n\n  \n\n    \nSensing Area (mm)\n\n    \n16.0 x 19.0\n\n  \n\n  \n\n    \nImage Size (px)\n\n    \n272 x 320\n\n  \n\n  \n\n    \nFinger Rotation\n\n    \n+/- 90'\n\n  \n\n  \n\n    \nSensor Dimension\n(L x W x H) (mm)\n\n    \n20.5 x 25 x 52\n\n  \n\n \n\n\n\n\n\n\n\nAccessories\n\u00b6\n\n\n\n\n\n\n\n\nRelated links\n\u00b6\n\n\nDatasheets\n\u00b6\n\n\n\n\nSFM4020-OP\n\n\n\n\nDocuments\n\u00b6\n\n\n\n\nUF Protocol Manual\n\n\n\n\nSoftware\n\u00b6\n\n\n\n\nUnifingerUI",
            "title": "SFM4000 Series"
        },
        {
            "location": "/products/SFM4000/#sfm4000-series",
            "text": "SFM4000 is a compact, power efficient module that is simple\nto integrate with various system applications. The module\noffers flexible supply voltage, integrated power management,\nsmall footprint, and voltage detector functions. SFM4000 is\nspecially designed for lock and safe manufacturers look for\nan inexpensive, reliable biometric solution with extra low\npower-consumption and compact size.",
            "title": "SFM4000 Series"
        },
        {
            "location": "/products/SFM4000/#features",
            "text": "Integrated power control circuit  Suprema, ISO 19794-2 and ANSI 378 template options  Serial Interface with simple protocol  4 configurable Digital I/O ports  Single 3.3 VDC regulated power source  256-bit AES fingerprint data encryption",
            "title": "Features"
        },
        {
            "location": "/products/SFM4000/#available-models",
            "text": "",
            "title": "Available Models"
        },
        {
            "location": "/products/SFM4000/#sfm4020-op",
            "text": "Optical Sensor  Robust optical fingerprint sensor  Solid and scratch-free sensor surface  Reliable high quality fingerprint image for wet & dry fingers  Sensor surface optimized to capture the ideal fingerprint image",
            "title": "SFM4020-OP"
        },
        {
            "location": "/products/SFM4000/#specification",
            "text": "Sensor            \n             Sensor Option           \n             Optical \n         \n         \n             Main \n             CPU \n             400MHz DSP  \n         \n         \n             Flash Memory \n             1MB \n         \n         \n             EER \n             <  0.1% \n         \n         \n             Enrollment Time (Sensor Dependent) \n             <  800ms OP5 \n         \n         \n             1:1 Verification Time (Sensor Dependent) \n             <  800ms OP5 \n         \n         \n             1:1000 ID Time* (Sensor Dependent) \n             <  970ms OP5 \n         \n         \n             Template Options \n             Suprema, ISO19794-2, ANSI 378 \n         \n         \n             Template Size (Default: 384 Bytes) \n             256 to 384 Bytes (Configurable) \n         \n         \n             Template Capacity \n             1,900 @ 1 MB Flash \n         \n         \n             Log Capacity \n             - \n         \n         \n             Fingerprint Data Encryption \n             256-bit AES             \n         \n         \n             Interface             \n             Host Comm.          \n             Async. Serial: CMOS level up to 460800 bps \n         \n         \n             Aux Comm. \n             -   \n         \n         \n             Wiegand Interface \n             - \n         \n         \n             External I/O \n             4x Digital I/O          \n         \n         \n             Hardware          \n             Supply Voltage          \n             3.3 VDC Regulated \n         \n         \n             Board Size \n             26 x 26 x 6.4 mm (L x W x H)    \n                \n       \u00a0  \u00a0   \n   \n     Model \n     SFM4000 \n   \n   \n     SFM4020-OP5     \n   \n   \n     Sensor Type \n     Optical \n   \n   \n     Sensor Options \n     OP5 \n   \n   \n     Resolution (dpi) \n     500 \n   \n   \n     Sensing Area (mm) \n     16.0 x 19.0 \n   \n   \n     Image Size (px) \n     272 x 320 \n   \n   \n     Finger Rotation \n     +/- 90' \n   \n   \n     Sensor Dimension (L x W x H) (mm) \n     20.5 x 25 x 52",
            "title": "Specification"
        },
        {
            "location": "/products/SFM4000/#accessories",
            "text": "",
            "title": "Accessories"
        },
        {
            "location": "/products/SFM4000/#related-links",
            "text": "",
            "title": "Related links"
        },
        {
            "location": "/products/SFM4000/#datasheets",
            "text": "SFM4020-OP",
            "title": "Datasheets"
        },
        {
            "location": "/products/SFM4000/#documents",
            "text": "UF Protocol Manual",
            "title": "Documents"
        },
        {
            "location": "/products/SFM4000/#software",
            "text": "UnifingerUI",
            "title": "Software"
        },
        {
            "location": "/products/SFM5000/",
            "text": "SFM5000 Series\n\u00b6\n\n\nSFM5000 is the latest UniFinger module equipped with\nworld\u2019s leading fingerprint authentication algorithm, which\nranked No. 1 in FVC2004, 2006 and ongoing. The SFM5000\nseries features powerful 533MHz DSP which optimized\nfor performance while minimizing power consumption\n\n\nFeatures\n\u00b6\n\n\n\n\nPowerful 533MHz DSP\n\n\n1:1 verification in 600ms\n\n\nFast Power-on Time\n\n\n8 configurable Digital I/O Ports\n\n\n1:1,000 Identification in 760ms\n\n\nSuprema, ISO 19794-2 and ANSI 378 Template Options\n\n\n256-bit AES Fingerprint Data Encryption\n\n\n4MB Flash Memory Option  \n\n\n\n\nHybrid Live Finger Detection Technology\n\n\n\n\nSuprema\u2019s LFD technology is based on comparison of dynamic and static image characteristics of the fake fingers to live fingers. By the advanced analysis algorithm to detect the abnormalities in dynamic changing pattern of fingerprint images, and several static features showing liveliness or unnaturalness of fingers, fake fingers are clearly distinguished from the live fingers. This new LFD technology provides efficient and effective solution to protect the fingerprint system from attack via fake fingerprints.\n\n\nAvailable Models\n\u00b6\n\n\nSFM5020-OP\n\u00b6\n\n\n\n\n\n\nOptical Sensor\n\n\nRobust optical fingerprint sensor\n\n\nSolid and scratch-free sensor surface\n\n\nReliable high quality fingerprint image for wet & dry fingers\n\n\nSensor surface optimized to capture the ideal fingerprint image\n\n\n\n\nSFM5030-OC\n\u00b6\n\n\n\n\n\n\nWaterproof Optical Sensor\n\n\nRobust optical fingerprint sensor\n\n\nIP65 rated waterproof front surface\n\n\nSolid and scratch-free sensor surface\n\n\nReliable High quality fingerprint image for wet & dry fingers\n\n\n\n\nSFM5060-OH\n\u00b6\n\n\n\n\n\n\nOptical Sensor with LFD\n\n\n500 dpi resolution\n\n\nHybrid finger detection technology\n\n\nPIV/FIPS 201 certification\n\n\nWaterproof front side\n\n\n\n\nSpecification\n\u00b6\n\n\n\n\n\n    \n     \n        \n\n            \nSensor\n           \n            \nSensor Option\n          \n            \nOptical\n\n        \n\n        \n\n            \nMain\n\n            \nCPU\n\n            \n533MHz DSP\n \n        \n\n        \n\n            \nFlash Memory\n\n            \n1MB\n(4MB Option))\n\n        \n\n        \n\n            \nEER\n\n            \n<\n 0.1%\n\n        \n\n        \n\n            \nEnrollment Time\n(Sensor Dependent)\n\n            \n<\n 600ms OP5/OC4/OH\n\n        \n\n        \n\n            \n1:1 Verification Time\n(Sensor Dependent)\n\n            \n<\n 600ms OP5/OC4/OH\n\n        \n\n        \n\n            \n1:1000 ID Time*\n(Sensor Dependent)\n\n            \n<\n 760ms OP5/OC4/OH\n\n        \n\n        \n\n            \nTemplate Options\n\n            \nSuprema, ISO19794-2, ANSI 378\n\n        \n\n        \n\n            \nTemplate Size\n(Default: 384 Bytes)\n\n            \n256 to 384 Bytes\n(Configurable)\n\n        \n\n        \n\n            \nTemplate Capacity\n\n            \n1,900 @ 1 MB Flash\n9,500 @ 4 MB Flash\n\n        \n\n        \n\n            \nLog Capacity\n\n            \n-\n\n        \n\n        \n\n            \nFingerprint Data Encryption\n\n            \n256-bit AES\n            \n        \n\n        \n\n            \nInterface\n            \n            \nHost Comm.\n         \n            \nAsync. Serial:\nCMOS level\nup to 460800 bps\n\n        \n\n        \n\n            \nAux Comm.\n\n            \n-\n  \n        \n\n        \n\n            \nWiegand Interface\n\n            \n-\n\n        \n\n        \n\n            \nExternal I/O\n\n            \n8x Digital I/O\n         \n        \n\n        \n\n            \nHardware\n         \n            \nSupply Voltage\n         \n            \n3.3 VDC Regulated\n\n        \n\n        \n\n            \nBoard Size\n\n            \n55 x 40 x 8 mm (L x W x H)\n \n        \n       \n    \n\n\n\n\n\n\u00a0\n\n\n\u00a0\n\n\n\n\n\n\n  \n\n    \nModel\n\n    \nSFM5000\n\n  \n\n  \n\n    \nSFM5020-OP5\n    \n    \nSFM5030-OC4\n    \n    \nSFM5060-OH\n    \n  \n\n  \n\n    \nSensor Type\n\n    \nOptical\n\n  \n\n  \n\n    \nSensor Options\n\n    \nOP5\n\n    \nOC4\n\n    \nOH\n\n  \n\n  \n\n    \nResolution (dpi)\n\n    \n500\n\n    \n500\n\n    \n500\n\n  \n\n  \n\n    \nSensing Area (mm)\n\n    \n16.0 x 19.0\n\n    \n16.0 x 18.0\n\n    \n15.0 x 18.8.0\n\n  \n\n  \n\n    \nImage Size (px)\n\n    \n272 x 320\n\n    \n288 x 288\n\n    \n260 x 340\n\n  \n\n  \n\n    \nFinger Rotation\n\n    \n+/- 90'\n\n    \n+/- 90'\n\n    \n+/- 90'\n\n  \n\n  \n\n    \nSensor Dimension\n(L x W x H) (mm)\n\n    \n20.5 x 25 x 52\n\n    \n21 x 23 x 54\n\n    \n21 x 23 x 54\n\n  \n\n \n\n\n\n\n\n\n\nAccessories\n\u00b6\n\n\n\n\n\n\n\n\nRelated links\n\u00b6\n\n\nDatasheets\n\u00b6\n\n\n\n\nSFM5020-OP\n\n\nSFM5030-OC\n\n\nSFM5060-OH\n\n\n\n\nDocuments\n\u00b6\n\n\n\n\nUF Protocol Manual\n\n\n\n\nSoftware\n\u00b6\n\n\n\n\nUnifingerUI",
            "title": "SFM5000 Series"
        },
        {
            "location": "/products/SFM5000/#sfm5000-series",
            "text": "SFM5000 is the latest UniFinger module equipped with\nworld\u2019s leading fingerprint authentication algorithm, which\nranked No. 1 in FVC2004, 2006 and ongoing. The SFM5000\nseries features powerful 533MHz DSP which optimized\nfor performance while minimizing power consumption",
            "title": "SFM5000 Series"
        },
        {
            "location": "/products/SFM5000/#features",
            "text": "Powerful 533MHz DSP  1:1 verification in 600ms  Fast Power-on Time  8 configurable Digital I/O Ports  1:1,000 Identification in 760ms  Suprema, ISO 19794-2 and ANSI 378 Template Options  256-bit AES Fingerprint Data Encryption  4MB Flash Memory Option     Hybrid Live Finger Detection Technology   Suprema\u2019s LFD technology is based on comparison of dynamic and static image characteristics of the fake fingers to live fingers. By the advanced analysis algorithm to detect the abnormalities in dynamic changing pattern of fingerprint images, and several static features showing liveliness or unnaturalness of fingers, fake fingers are clearly distinguished from the live fingers. This new LFD technology provides efficient and effective solution to protect the fingerprint system from attack via fake fingerprints.",
            "title": "Features"
        },
        {
            "location": "/products/SFM5000/#available-models",
            "text": "",
            "title": "Available Models"
        },
        {
            "location": "/products/SFM5000/#sfm5020-op",
            "text": "Optical Sensor  Robust optical fingerprint sensor  Solid and scratch-free sensor surface  Reliable high quality fingerprint image for wet & dry fingers  Sensor surface optimized to capture the ideal fingerprint image",
            "title": "SFM5020-OP"
        },
        {
            "location": "/products/SFM5000/#sfm5030-oc",
            "text": "Waterproof Optical Sensor  Robust optical fingerprint sensor  IP65 rated waterproof front surface  Solid and scratch-free sensor surface  Reliable High quality fingerprint image for wet & dry fingers",
            "title": "SFM5030-OC"
        },
        {
            "location": "/products/SFM5000/#sfm5060-oh",
            "text": "Optical Sensor with LFD  500 dpi resolution  Hybrid finger detection technology  PIV/FIPS 201 certification  Waterproof front side",
            "title": "SFM5060-OH"
        },
        {
            "location": "/products/SFM5000/#specification",
            "text": "Sensor            \n             Sensor Option           \n             Optical \n         \n         \n             Main \n             CPU \n             533MHz DSP  \n         \n         \n             Flash Memory \n             1MB (4MB Option)) \n         \n         \n             EER \n             <  0.1% \n         \n         \n             Enrollment Time (Sensor Dependent) \n             <  600ms OP5/OC4/OH \n         \n         \n             1:1 Verification Time (Sensor Dependent) \n             <  600ms OP5/OC4/OH \n         \n         \n             1:1000 ID Time* (Sensor Dependent) \n             <  760ms OP5/OC4/OH \n         \n         \n             Template Options \n             Suprema, ISO19794-2, ANSI 378 \n         \n         \n             Template Size (Default: 384 Bytes) \n             256 to 384 Bytes (Configurable) \n         \n         \n             Template Capacity \n             1,900 @ 1 MB Flash 9,500 @ 4 MB Flash \n         \n         \n             Log Capacity \n             - \n         \n         \n             Fingerprint Data Encryption \n             256-bit AES             \n         \n         \n             Interface             \n             Host Comm.          \n             Async. Serial: CMOS level up to 460800 bps \n         \n         \n             Aux Comm. \n             -   \n         \n         \n             Wiegand Interface \n             - \n         \n         \n             External I/O \n             8x Digital I/O          \n         \n         \n             Hardware          \n             Supply Voltage          \n             3.3 VDC Regulated \n         \n         \n             Board Size \n             55 x 40 x 8 mm (L x W x H)  \n                \n       \u00a0  \u00a0   \n   \n     Model \n     SFM5000 \n   \n   \n     SFM5020-OP5     \n     SFM5030-OC4     \n     SFM5060-OH     \n   \n   \n     Sensor Type \n     Optical \n   \n   \n     Sensor Options \n     OP5 \n     OC4 \n     OH \n   \n   \n     Resolution (dpi) \n     500 \n     500 \n     500 \n   \n   \n     Sensing Area (mm) \n     16.0 x 19.0 \n     16.0 x 18.0 \n     15.0 x 18.8.0 \n   \n   \n     Image Size (px) \n     272 x 320 \n     288 x 288 \n     260 x 340 \n   \n   \n     Finger Rotation \n     +/- 90' \n     +/- 90' \n     +/- 90' \n   \n   \n     Sensor Dimension (L x W x H) (mm) \n     20.5 x 25 x 52 \n     21 x 23 x 54 \n     21 x 23 x 54",
            "title": "Specification"
        },
        {
            "location": "/products/SFM5000/#accessories",
            "text": "",
            "title": "Accessories"
        },
        {
            "location": "/products/SFM5000/#related-links",
            "text": "",
            "title": "Related links"
        },
        {
            "location": "/products/SFM5000/#datasheets",
            "text": "SFM5020-OP  SFM5030-OC  SFM5060-OH",
            "title": "Datasheets"
        },
        {
            "location": "/products/SFM5000/#documents",
            "text": "UF Protocol Manual",
            "title": "Documents"
        },
        {
            "location": "/products/SFM5000/#software",
            "text": "UnifingerUI",
            "title": "Software"
        },
        {
            "location": "/products/SFM5500/",
            "text": "SFM5500 Series\n\u00b6\n\n\nSFM5500 is a high-end standalone fingerprint module\nequipped with versatile external interface including\nRS232, RS422/485, Wiegand, Digital I/O and LED\nControl, readily applicable to access control applications.\nSFM5500 offers comprehensive functionalities and\ninterfaces to be used as a complete standalone fingerprint\naccess reader by itself.\n\n\nFeatures\n\u00b6\n\n\n\n\nPowerful 533MHz DSP\n\n\n1:1 verification in 550ms\n\n\nFast Power-on Time\n\n\nConfigurable Digital I/O and LED Control Ports\n\n\nWiegand Input & Output Ports\n\n\nAuxiliary Communication Ports\n\n\n1:1,000 Identification in 700ms\n\n\nSuprema, ISO 19794-2, ANSI 378 Template Options\n\n\nWSQ Image Compression Algorithm certified by FBI\n\n\n256-bit AES Fingerprint Data Encryption\n\n\n8MB Flash Memory Option\n\n\nRS232, RS422/485 Host Communication\n\n\n\n\nAvailable Models\n\u00b6\n\n\nSFM5520-OP\n\u00b6\n\n\n\n\n\n\nOptical Sensor\n\n\nRobust optical fingerprint sensor\n\n\nSolid and scratch-free sensor surface\n\n\nReliable high quality fingerprint image for wet & dry fingers\n\n\nSensor surface optimized to capture the ideal fingerprint image\n\n\n\n\nSFM5530-OC\n\u00b6\n\n\n\n\n\n\nWaterproof Optical Sensor\n\n\nRobust optical fingerprint sensor\n\n\nIP65 rated waterproof front surface\n\n\nSolid and scratch-free sensor surface\n\n\nReliable high quality fingerprint image for wet & dry fingers\n\n\n\n\nSFM5550-TC\n\u00b6\n\n\n\n\n\n\nUPEK TouchChip Sensor\n\n\nCapacitive type sensor\n\n\nPerfectPrint technology\n\n\nReliable high quality\n\n\nfingerprint image\n\n\n\n\nSpecification\n\u00b6\n\n\n\n\n\n    \n     \n        \n\n            \nSensor\n           \n            \nSensor Option\n          \n            \nOptical, Capacitive\n\n        \n\n        \n\n            \nMain\n\n            \nCPU\n\n            \n533MHz DSP\n \n        \n\n        \n\n            \nFlash Memory\n\n            \n4MB\n(8MB Option)\n\n        \n\n        \n\n            \nEER\n\n            \n<\n 0.1%\n\n        \n\n        \n\n            \nEnrollment Time\n(Sensor Dependent)\n\n            \n<\n 550ms OP5/OC4\n<\n 600ms TC1\n<\n 410ms TC2\n\n        \n\n        \n\n            \n1:1 Verification Time\n(Sensor Dependent)\n\n            \n<\n 550ms OP5/OC4\n<\n 600ms TC1\n<\n 410ms TC2\n\n        \n\n        \n\n            \n1:1000 ID Time*\n(Sensor Dependent)\n\n            \n<\n 700ms OP5/OC4\n<\n 740ms TC1\n<\n 550ms TC2\n\n        \n\n        \n\n            \nTemplate Options\n\n            \nSuprema, ISO19794-2, ANSI 378\n\n        \n\n        \n\n            \nTemplate Size\n(Default: 384 Bytes)\n\n            \n256 to 384 Bytes\n(Configurable)\n\n        \n\n        \n\n            \nTemplate Capacity\n\n            \n9,000 @ 4 MB Flash\n19,000 @ 8MB Flash\n\n        \n\n        \n\n            \nLog Capacity\n\n            \n12,800\n\n        \n\n        \n\n            \nFingerprint Data Encryption\n\n            \n256-bit AES\n            \n        \n\n        \n\n            \nInterface\n            \n            \nHost Comm.\n         \n            \nRS232 or RS422/485 \nup to 460800 bps\n\n        \n\n        \n\n            \nAux Comm.\n\n            \nAsync. Serial:\nCMOS level up to 460800 bps\n  \n        \n\n        \n\n            \nWiegand Interface\n\n            \n1x Wiegand Input, 1x Wiegand Output\n\n        \n\n        \n\n            \nExternal I/O\n\n            \n3x Digital Inputs, 3x Digital Outputs, 3x LED Outputs\n          \n        \n\n        \n\n            \nHardware\n         \n            \nSupply Voltage\n         \n            \n5 VDC Regulated\n\n        \n\n        \n\n            \nBoard Size\n\n            \n63 x 43 x 10 mm (L x W x H)\n    \n        \n       \n    \n\n\n\n\n\n\u00a0\n\n\n\u00a0\n\n\n\n\n\n\n  \n\n    \nModel\n\n    \nSFM5500\n\n  \n\n  \n\n    \nSFM5520-OP5\n\n    \nSFM5530-OC4\n\n    \nSFM5500-TC\n\n  \n\n  \n\n    \nSensor Type\n\n    \nOptical\n\n    \nOptical\n\n    \nCapacitive\n\n  \n\n  \n\n    \nSensor Options\n\n    \nOP5\n\n    \nOC4\n\n    \nTC1\n\n    \nTC2\n\n  \n\n  \n\n    \nResolution (dpi)\n\n    \n500\n\n    \n500\n\n    \n508\n\n    \n508\n\n  \n\n  \n\n    \nSensing Area (mm)\n\n    \n16.0 x 19.0\n\n    \n16.0 x 18.0\n\n    \n12.8 x 18.0\n\n    \n10.4 x 14.4\n\n  \n\n  \n\n    \nImage Size (px)\n\n    \n272 x 320\n\n    \n288 x 288\n\n    \n256 x 360\n\n    \n208 x 288\n\n  \n\n  \n\n    \nFinger Rotation\n\n    \n+/- 90'\n\n    \n+/- 90'\n\n    \n+/- 90'\n\n    \n+/- 90'\n\n  \n\n  \n\n    \nSensor Dimension\n(L x W x H) (mm)\n\n    \n20.5 x 25 x 52\n\n    \n21 x 23 x 54\n\n    \n20.4 x 27 x 3.5\n\n    \n20.4 x 27 x 3.5\n\n  \n\n \n\n\n\n\n\n\n\nAccessories\n\u00b6\n\n\n\n\n\n\n\n\nRelated links\n\u00b6\n\n\nDatasheets\n\u00b6\n\n\n\n\nSFM5520-OP\n\n\nSFM5530-OC\n\n\nSFM5560-OH\n\n\n\n\nDocuments\n\u00b6\n\n\n\n\nUF Protocol Manual\n\n\n\n\nSoftware\n\u00b6\n\n\n\n\nUnifingerUI",
            "title": "SFM5500 Series"
        },
        {
            "location": "/products/SFM5500/#sfm5500-series",
            "text": "SFM5500 is a high-end standalone fingerprint module\nequipped with versatile external interface including\nRS232, RS422/485, Wiegand, Digital I/O and LED\nControl, readily applicable to access control applications.\nSFM5500 offers comprehensive functionalities and\ninterfaces to be used as a complete standalone fingerprint\naccess reader by itself.",
            "title": "SFM5500 Series"
        },
        {
            "location": "/products/SFM5500/#features",
            "text": "Powerful 533MHz DSP  1:1 verification in 550ms  Fast Power-on Time  Configurable Digital I/O and LED Control Ports  Wiegand Input & Output Ports  Auxiliary Communication Ports  1:1,000 Identification in 700ms  Suprema, ISO 19794-2, ANSI 378 Template Options  WSQ Image Compression Algorithm certified by FBI  256-bit AES Fingerprint Data Encryption  8MB Flash Memory Option  RS232, RS422/485 Host Communication",
            "title": "Features"
        },
        {
            "location": "/products/SFM5500/#available-models",
            "text": "",
            "title": "Available Models"
        },
        {
            "location": "/products/SFM5500/#sfm5520-op",
            "text": "Optical Sensor  Robust optical fingerprint sensor  Solid and scratch-free sensor surface  Reliable high quality fingerprint image for wet & dry fingers  Sensor surface optimized to capture the ideal fingerprint image",
            "title": "SFM5520-OP"
        },
        {
            "location": "/products/SFM5500/#sfm5530-oc",
            "text": "Waterproof Optical Sensor  Robust optical fingerprint sensor  IP65 rated waterproof front surface  Solid and scratch-free sensor surface  Reliable high quality fingerprint image for wet & dry fingers",
            "title": "SFM5530-OC"
        },
        {
            "location": "/products/SFM5500/#sfm5550-tc",
            "text": "UPEK TouchChip Sensor  Capacitive type sensor  PerfectPrint technology  Reliable high quality  fingerprint image",
            "title": "SFM5550-TC"
        },
        {
            "location": "/products/SFM5500/#specification",
            "text": "Sensor            \n             Sensor Option           \n             Optical, Capacitive \n         \n         \n             Main \n             CPU \n             533MHz DSP  \n         \n         \n             Flash Memory \n             4MB (8MB Option) \n         \n         \n             EER \n             <  0.1% \n         \n         \n             Enrollment Time (Sensor Dependent) \n             <  550ms OP5/OC4 <  600ms TC1 <  410ms TC2 \n         \n         \n             1:1 Verification Time (Sensor Dependent) \n             <  550ms OP5/OC4 <  600ms TC1 <  410ms TC2 \n         \n         \n             1:1000 ID Time* (Sensor Dependent) \n             <  700ms OP5/OC4 <  740ms TC1 <  550ms TC2 \n         \n         \n             Template Options \n             Suprema, ISO19794-2, ANSI 378 \n         \n         \n             Template Size (Default: 384 Bytes) \n             256 to 384 Bytes (Configurable) \n         \n         \n             Template Capacity \n             9,000 @ 4 MB Flash 19,000 @ 8MB Flash \n         \n         \n             Log Capacity \n             12,800 \n         \n         \n             Fingerprint Data Encryption \n             256-bit AES             \n         \n         \n             Interface             \n             Host Comm.          \n             RS232 or RS422/485  up to 460800 bps \n         \n         \n             Aux Comm. \n             Async. Serial: CMOS level up to 460800 bps   \n         \n         \n             Wiegand Interface \n             1x Wiegand Input, 1x Wiegand Output \n         \n         \n             External I/O \n             3x Digital Inputs, 3x Digital Outputs, 3x LED Outputs           \n         \n         \n             Hardware          \n             Supply Voltage          \n             5 VDC Regulated \n         \n         \n             Board Size \n             63 x 43 x 10 mm (L x W x H)     \n                \n       \u00a0  \u00a0   \n   \n     Model \n     SFM5500 \n   \n   \n     SFM5520-OP5 \n     SFM5530-OC4 \n     SFM5500-TC \n   \n   \n     Sensor Type \n     Optical \n     Optical \n     Capacitive \n   \n   \n     Sensor Options \n     OP5 \n     OC4 \n     TC1 \n     TC2 \n   \n   \n     Resolution (dpi) \n     500 \n     500 \n     508 \n     508 \n   \n   \n     Sensing Area (mm) \n     16.0 x 19.0 \n     16.0 x 18.0 \n     12.8 x 18.0 \n     10.4 x 14.4 \n   \n   \n     Image Size (px) \n     272 x 320 \n     288 x 288 \n     256 x 360 \n     208 x 288 \n   \n   \n     Finger Rotation \n     +/- 90' \n     +/- 90' \n     +/- 90' \n     +/- 90' \n   \n   \n     Sensor Dimension (L x W x H) (mm) \n     20.5 x 25 x 52 \n     21 x 23 x 54 \n     20.4 x 27 x 3.5 \n     20.4 x 27 x 3.5",
            "title": "Specification"
        },
        {
            "location": "/products/SFM5500/#accessories",
            "text": "",
            "title": "Accessories"
        },
        {
            "location": "/products/SFM5500/#related-links",
            "text": "",
            "title": "Related links"
        },
        {
            "location": "/products/SFM5500/#datasheets",
            "text": "SFM5520-OP  SFM5530-OC  SFM5560-OH",
            "title": "Datasheets"
        },
        {
            "location": "/products/SFM5500/#documents",
            "text": "UF Protocol Manual",
            "title": "Documents"
        },
        {
            "location": "/products/SFM5500/#software",
            "text": "UnifingerUI",
            "title": "Software"
        },
        {
            "location": "/products/SFM6000/",
            "text": "SFM6000 Series\n\u00b6\n\n\nSFM6000 Series represents a great leap forward in biometrics.\nIt boasts a powerful 1.0GHz CPU that empowers the worlds\u2019\nfastest authentication and supports multiple interfaces\nincluding RS232 and USB2.0 that allow high-speed data\ntransfer. With enlarged template capacity up to 25,000\ntemplates, SFM6000 Series is the perfect solution for\na large-scaled yet fast authentication\n\n\nFeatures\n\u00b6\n\n\n\n\nPowerful 1.0GHz CPU\n\n\n1:1 verification in 330ms\n\n\nFast Power-on Time\n\n\n8 configurable Digital I/O Ports\n\n\n1:1,000 Identification in 400ms\n\n\nSuprema, ISO 19794-2, ANSI 378 Template Options\n\n\nAndroid SDK\n\n\nWSQ Image Compression Algorithm certified by FBI\n\n\n256-bit AES Fingerprint Data Encryption\n\n\n8MB and 16MB Flash Memory Option\n\n\nRS232, USB2.0 Host Communication\n\n\n\n\nAvailable Models\n\u00b6\n\n\nSFM6020-OP\n\u00b6\n\n\n\n\n\n\nOptical Sensor\n\n\nRobust optical fingerprint sensor\n\n\nIP65 rated waterproof front surface\n\n\nSolid and scratch-free sensor surface\n\n\nReliable high quality fingerprint image for wet & dry fingers\n\n\nSensor surface optimized to capture the ideal fingerprint image\n\n\n\n\nSFM6030-OC\n\u00b6\n\n\n\n\n\n\nOptical Sensor\n\n\nRobust optical fingerprint sensor\n\n\nIP65 rated waterproof front surface\n\n\nSolid and scratch-free sensor surface\n\n\nReliable high quality fingerprint image for wet & dry fingers\n\n\n\n\nSFM6050-T\n\u00b6\n\n\n\n\n\n\nCapacitive Sensor\n\n\nIP65 rated sensor surface with high durability\n\n\nAnti-latent fingerprint technology\n\n\nReliable high quality fingerprint image\n\n\n\n\nSpecification\n\u00b6\n\n\n\n\n\n    \n     \n        \n\n            \nSensor\n           \n            \nSensor Option\n           \n            \nOptical, Capacitive\n\n        \n\n        \n\n            \nMain\n\n            \nCPU\n\n            \n1GMHz (MIPs)\n   \n        \n\n        \n\n            \nFlash Memory\n\n            \n8MB/16MB\n\n        \n\n        \n\n            \nEER\n\n            \n<\n 0.08%\n\n        \n\n        \n\n            \nEnrollment Time\n(Sensor Dependent)\n\n            \n<\n 330ms OP6/OC6\n<\n 360ms T1\n<\n 250ms T2\n\n        \n\n        \n\n            \n1:1 Verification Time\n(Sensor Dependent)\n\n            \n<\n 330ms OP6/OC6\n<\n 360ms T1\n<\n 250ms T2\n\n        \n\n        \n\n            \n1:1000 ID Time*\n(Sensor Dependent)\n\n            \n<\n 400ms OP6/OC6\n<\n 430ms T1\n<\n 320ms T2\n\n        \n\n        \n\n            \nTemplate Options\n\n            \nSuprema, ISO19794-2, ANSI-378\n\n        \n\n        \n\n            \nTemplate Size\n(Default: 384 Bytes)\n\n            \n256 to 384 Bytes\n(Configurable)\n\n        \n\n        \n\n            \nTemplate Capacity\n\n            \n5,000 @ 8 MB Flash\n25,000 @ 16MB Flash\n\n        \n\n        \n\n            \nFingerprint Data Encryption\n\n            \n256-bit AES\n            \n        \n\n        \n\n            \nInterface\n           \n            \nHost Comm.\n         \n            \nAsync Serial:\nCMOS level upup to 921600 bps \nUSB 2.0(up to 2Mbps)\n\n        \n\n        \n\n            \nExternal I/O\n\n            \n8x Digital I/O\n         \n        \n\n        \n\n            \nHardware\n            \n            \nSupply Voltage\n         \n            \n3.3/5 VDC Regulated\n\n        \n\n        \n\n            \nBoard Size\n\n            \n55 x 40 x 8 mm (L x W x H)\n \n        \n       \n    \n\n\n\n\n\n\u00a0\n\n\n\u00a0\n\n\n\n\n\n\n  \n\n    \nModel\n\n    \nSFM6000\n\n  \n\n  \n\n    \nSFM6020-OP\n\n    \nSFM6030-OC\n\n    \nSFM6050-T1\n\n    \nSFM6050-T2\n\n  \n\n  \n\n    \nSensor Type\n\n    \nOptical\n\n    \nCapacitive\n\n  \n\n  \n\n    \nSensor Options\n\n    \nOP6\n\n    \nOC6\n\n    \nT1\n\n    \nT2\n\n  \n\n  \n\n    \nResolution (dpi)\n\n    \n500\n\n    \n508\n\n  \n\n  \n\n    \nSensing Area (mm)\n\n    \n16.0 x 19.0\n\n    \n16.0 x 18.0\n\n    \n12.8 x 18.0\n\n    \n10.4 x 14.4\n\n  \n\n  \n\n    \nImage Size (px)\n\n    \n272 x 320\n\n    \n288 x 288\n\n    \n256 x 360\n\n    \n208 x 288\n\n  \n\n  \n\n    \nFinger Rotation\n\n    \n+/- 90'\n\n  \n\n  \n\n    \nSensor Dimension\n(L x W x H) (mm)\n\n    \n20.5 x 25 x 52\n\n    \n21 x 23 x 54\n\n    \n20.4 x 27 x 3.5\n\n  \n\n \n\n\n\n\n\n\n\nAccessories\n\u00b6\n\n\n\n\n\n\n\n\n\n\n\n\nRelated links\n\u00b6\n\n\nDatasheets\n\u00b6\n\n\n\n\nSFM6020-OP\n\n\nSFM6030-OC\n\n\nSFM6050-T\n\n\n\n\nFirmware\n\u00b6\n\n\n\n\nDownload link\n\n\n\n\nDocuments\n\u00b6\n\n\n\n\nUF Protocol Manual\n\n\n\n\nSoftware\n\u00b6\n\n\n\n\nUnifingerUI",
            "title": "SFM6000 Series"
        },
        {
            "location": "/products/SFM6000/#sfm6000-series",
            "text": "SFM6000 Series represents a great leap forward in biometrics.\nIt boasts a powerful 1.0GHz CPU that empowers the worlds\u2019\nfastest authentication and supports multiple interfaces\nincluding RS232 and USB2.0 that allow high-speed data\ntransfer. With enlarged template capacity up to 25,000\ntemplates, SFM6000 Series is the perfect solution for\na large-scaled yet fast authentication",
            "title": "SFM6000 Series"
        },
        {
            "location": "/products/SFM6000/#features",
            "text": "Powerful 1.0GHz CPU  1:1 verification in 330ms  Fast Power-on Time  8 configurable Digital I/O Ports  1:1,000 Identification in 400ms  Suprema, ISO 19794-2, ANSI 378 Template Options  Android SDK  WSQ Image Compression Algorithm certified by FBI  256-bit AES Fingerprint Data Encryption  8MB and 16MB Flash Memory Option  RS232, USB2.0 Host Communication",
            "title": "Features"
        },
        {
            "location": "/products/SFM6000/#available-models",
            "text": "",
            "title": "Available Models"
        },
        {
            "location": "/products/SFM6000/#sfm6020-op",
            "text": "Optical Sensor  Robust optical fingerprint sensor  IP65 rated waterproof front surface  Solid and scratch-free sensor surface  Reliable high quality fingerprint image for wet & dry fingers  Sensor surface optimized to capture the ideal fingerprint image",
            "title": "SFM6020-OP"
        },
        {
            "location": "/products/SFM6000/#sfm6030-oc",
            "text": "Optical Sensor  Robust optical fingerprint sensor  IP65 rated waterproof front surface  Solid and scratch-free sensor surface  Reliable high quality fingerprint image for wet & dry fingers",
            "title": "SFM6030-OC"
        },
        {
            "location": "/products/SFM6000/#sfm6050-t",
            "text": "Capacitive Sensor  IP65 rated sensor surface with high durability  Anti-latent fingerprint technology  Reliable high quality fingerprint image",
            "title": "SFM6050-T"
        },
        {
            "location": "/products/SFM6000/#specification",
            "text": "Sensor            \n             Sensor Option            \n             Optical, Capacitive \n         \n         \n             Main \n             CPU \n             1GMHz (MIPs)    \n         \n         \n             Flash Memory \n             8MB/16MB \n         \n         \n             EER \n             <  0.08% \n         \n         \n             Enrollment Time (Sensor Dependent) \n             <  330ms OP6/OC6 <  360ms T1 <  250ms T2 \n         \n         \n             1:1 Verification Time (Sensor Dependent) \n             <  330ms OP6/OC6 <  360ms T1 <  250ms T2 \n         \n         \n             1:1000 ID Time* (Sensor Dependent) \n             <  400ms OP6/OC6 <  430ms T1 <  320ms T2 \n         \n         \n             Template Options \n             Suprema, ISO19794-2, ANSI-378 \n         \n         \n             Template Size (Default: 384 Bytes) \n             256 to 384 Bytes (Configurable) \n         \n         \n             Template Capacity \n             5,000 @ 8 MB Flash 25,000 @ 16MB Flash \n         \n         \n             Fingerprint Data Encryption \n             256-bit AES             \n         \n         \n             Interface            \n             Host Comm.          \n             Async Serial: CMOS level upup to 921600 bps  USB 2.0(up to 2Mbps) \n         \n         \n             External I/O \n             8x Digital I/O          \n         \n         \n             Hardware             \n             Supply Voltage          \n             3.3/5 VDC Regulated \n         \n         \n             Board Size \n             55 x 40 x 8 mm (L x W x H)  \n                \n       \u00a0  \u00a0   \n   \n     Model \n     SFM6000 \n   \n   \n     SFM6020-OP \n     SFM6030-OC \n     SFM6050-T1 \n     SFM6050-T2 \n   \n   \n     Sensor Type \n     Optical \n     Capacitive \n   \n   \n     Sensor Options \n     OP6 \n     OC6 \n     T1 \n     T2 \n   \n   \n     Resolution (dpi) \n     500 \n     508 \n   \n   \n     Sensing Area (mm) \n     16.0 x 19.0 \n     16.0 x 18.0 \n     12.8 x 18.0 \n     10.4 x 14.4 \n   \n   \n     Image Size (px) \n     272 x 320 \n     288 x 288 \n     256 x 360 \n     208 x 288 \n   \n   \n     Finger Rotation \n     +/- 90' \n   \n   \n     Sensor Dimension (L x W x H) (mm) \n     20.5 x 25 x 52 \n     21 x 23 x 54 \n     20.4 x 27 x 3.5",
            "title": "Specification"
        },
        {
            "location": "/products/SFM6000/#accessories",
            "text": "",
            "title": "Accessories"
        },
        {
            "location": "/products/SFM6000/#related-links",
            "text": "",
            "title": "Related links"
        },
        {
            "location": "/products/SFM6000/#datasheets",
            "text": "SFM6020-OP  SFM6030-OC  SFM6050-T",
            "title": "Datasheets"
        },
        {
            "location": "/products/SFM6000/#firmware",
            "text": "Download link",
            "title": "Firmware"
        },
        {
            "location": "/products/SFM6000/#documents",
            "text": "UF Protocol Manual",
            "title": "Documents"
        },
        {
            "location": "/products/SFM6000/#software",
            "text": "UnifingerUI",
            "title": "Software"
        },
        {
            "location": "/documents/Introduction/",
            "text": "1. Introduction\n\u00b6\n\n\nThe SFM SDK is a collection of APIs for interfacing with SFM modules and BioEntry readers. In addition to simple wrapper functions for Packet Protocol, it also provides high level APIs such as template DB management, image manipulation, etc. By using the SDK, developers could write Win32 applications quickly without knowing the minute details of Packet Protocol.\n\n\n\n\nFig. 1. SFM SDK\n\n\nAs shown in Fig. 1, the SDK is composed of several layers and developers could choose whichever layer suited for their applications. Another strong point of the SDK is its extensibility. Many of core APIs provide callback mechanism, with which developers can add customized functions. UniFingerUI V5.x is a good example of this feature. Completely rewritten from scratch, UniFingerUI V5.x covers all the core functionalities of SFM modules and shows how to use the SDK in real applications. The source codes of it are also provided in the SDK.\n\n\n1.1. Contents of the SDK\n\u00b6\n\n\n\n\n\n\n\n\nDirectory\n\n\nSub Directory\n\n\nContents\n\n\n\n\n\n\n\n\n\n\nSDK\n\n\nDocument\n\n\n- SFM SDK Reference Manual   \n - Packet Protocol Manual\n\n\n\n\n\n\n\n\nInclude\n\n\n- Header files of SFM SDK.\n\n\n\n\n\n\n\n\nLib\n\n\n- SFM_SDK.dll: SDK DLL file.   \n - SFM_SDK_Debug.dll: SDK DLL with debug information.   \n - SFM_SDK.lib: import library to be linked with C/C++ applications.   \n - SFM_SDK_Debug.lib: import library to be linked with C/C++ applications\n\n\n\n\n\n\n\n\nLib_Ordinal\n\n\nThe functions in these DLLs are exported by ordinal using DEF files. Use these DLLs if you have problem using the SDK in programming languages other than C/C++.\n\n\n\n\n\n\nUniFingerUI\n\n\n\n\n- Source codes   \n - Visual C++ 6.0 project file   \n - Visual C++ 2010 project file (v.5.1~)\n\n\n\n\n\n\nExample\n\n\nC#\n\n\n- A simple example which shows how to use the SDK in .NET environment\n\n\n\n\n\n\n\n\n1.2. Usage\n\u00b6\n\n\n1.2.1. Compilation\n\u00b6\n\n\nTo call APIs defined in the SFM SDK, \u2018UF_API.h\u2019 should be included in the source files and SDK\\Include should be added to the include directories. To link user application with the SFM SDK, SFM_SDK.lib should be added to library modules.\n\n\nThe following snippet shows a typical source file.\n\n\n#include\n \n\u201cUF_API.h\u201d\n\n\nint\n \nmain\n()\n\n\n{\n\n    \n// First, initialize the serial port\n\n    \nUF_RET_CODE\n \nresult\n \n=\n \nUF_InitCommPort\n(\n \n\u201c\nCOM1\n\u201d\n,\n \n115200\n,\n \nFALSE\n \n);\n\n\n    \nIf\n(\n \nresult\n \n!=\n \nUF_RET_SUCCESS\n \n)\n\n    \n{\n\n        \nreturn\n \n-\n1\n;\n\n    \n}\n\n\n    \n// Call APIs\n\n    \nUINT32\n \nuserID\n;\n\n    \nBYTE\n \nsubID\n;\n\n\n    \nresult\n \n=\n \nUF_Identify\n(\n \n&\nuserID\n,\n \n&\nsubID\n \n);\n\n\n    \n// \u2026\n\n\n}\n\n\n\n1.2.2. Using the DLL\nTo run applications compiled with the SFM SDK, the SFM_SDK.dll file should be in the system directory or in the same directory of the application.\n\n\n1.3. UniFinger UI\n\u00b6\n\n\nUniFinger UI is a full-featured application by which users can test all the core functionalities of SFM modules. UniFinger UI is implemented using the SFM SDK and full source codes are available for SDK users.\n\n\n1.3.1. Optional Requirements\n\u00b6\n\n\nUniFinger UI uses Microsoft\u2019s HTML Help Workshop for online help. You can download it from the MSDN web site.\n\n\n1.3.2. Compilation\n\u00b6\n\n\nOpen UniFingerUI\\UniFingerUI.dsw in Microsoft Visual C++ 6.0 or later. If you download and install HTML Help Workshop, changes the include directory and library path accordingly. If you don\u2019t want online help, just select \u2018Win32 Debug Without Help\u2019 or \u2018Win32 Release Without Help\u2019 as the active configuration.\n\n\n\n\nFig. 2. UniFingerUI",
            "title": "Introduction"
        },
        {
            "location": "/documents/Introduction/#1-introduction",
            "text": "The SFM SDK is a collection of APIs for interfacing with SFM modules and BioEntry readers. In addition to simple wrapper functions for Packet Protocol, it also provides high level APIs such as template DB management, image manipulation, etc. By using the SDK, developers could write Win32 applications quickly without knowing the minute details of Packet Protocol.   Fig. 1. SFM SDK  As shown in Fig. 1, the SDK is composed of several layers and developers could choose whichever layer suited for their applications. Another strong point of the SDK is its extensibility. Many of core APIs provide callback mechanism, with which developers can add customized functions. UniFingerUI V5.x is a good example of this feature. Completely rewritten from scratch, UniFingerUI V5.x covers all the core functionalities of SFM modules and shows how to use the SDK in real applications. The source codes of it are also provided in the SDK.",
            "title": "1. Introduction"
        },
        {
            "location": "/documents/Introduction/#11-contents-of-the-sdk",
            "text": "Directory  Sub Directory  Contents      SDK  Document  - SFM SDK Reference Manual     - Packet Protocol Manual     Include  - Header files of SFM SDK.     Lib  - SFM_SDK.dll: SDK DLL file.     - SFM_SDK_Debug.dll: SDK DLL with debug information.     - SFM_SDK.lib: import library to be linked with C/C++ applications.     - SFM_SDK_Debug.lib: import library to be linked with C/C++ applications     Lib_Ordinal  The functions in these DLLs are exported by ordinal using DEF files. Use these DLLs if you have problem using the SDK in programming languages other than C/C++.    UniFingerUI   - Source codes     - Visual C++ 6.0 project file     - Visual C++ 2010 project file (v.5.1~)    Example  C#  - A simple example which shows how to use the SDK in .NET environment",
            "title": "1.1. Contents of the SDK"
        },
        {
            "location": "/documents/Introduction/#12-usage",
            "text": "",
            "title": "1.2. Usage"
        },
        {
            "location": "/documents/Introduction/#121-compilation",
            "text": "To call APIs defined in the SFM SDK, \u2018UF_API.h\u2019 should be included in the source files and SDK\\Include should be added to the include directories. To link user application with the SFM SDK, SFM_SDK.lib should be added to library modules.  The following snippet shows a typical source file.  #include   \u201cUF_API.h\u201d  int   main ()  { \n     // First, initialize the serial port \n     UF_RET_CODE   result   =   UF_InitCommPort (   \u201c COM1 \u201d ,   115200 ,   FALSE   ); \n\n     If (   result   !=   UF_RET_SUCCESS   ) \n     { \n         return   - 1 ; \n     } \n\n     // Call APIs \n     UINT32   userID ; \n     BYTE   subID ; \n\n     result   =   UF_Identify (   & userID ,   & subID   ); \n\n     // \u2026  }  \n1.2.2. Using the DLL\nTo run applications compiled with the SFM SDK, the SFM_SDK.dll file should be in the system directory or in the same directory of the application.",
            "title": "1.2.1. Compilation"
        },
        {
            "location": "/documents/Introduction/#13-unifinger-ui",
            "text": "UniFinger UI is a full-featured application by which users can test all the core functionalities of SFM modules. UniFinger UI is implemented using the SFM SDK and full source codes are available for SDK users.",
            "title": "1.3. UniFinger UI"
        },
        {
            "location": "/documents/Introduction/#131-optional-requirements",
            "text": "UniFinger UI uses Microsoft\u2019s HTML Help Workshop for online help. You can download it from the MSDN web site.",
            "title": "1.3.1. Optional Requirements"
        },
        {
            "location": "/documents/Introduction/#132-compilation",
            "text": "Open UniFingerUI\\UniFingerUI.dsw in Microsoft Visual C++ 6.0 or later. If you download and install HTML Help Workshop, changes the include directory and library path accordingly. If you don\u2019t want online help, just select \u2018Win32 Debug Without Help\u2019 or \u2018Win32 Release Without Help\u2019 as the active configuration.   Fig. 2. UniFingerUI",
            "title": "1.3.2. Compilation"
        },
        {
            "location": "/documents/API_Compatibility/",
            "text": "2. API Compatibility\n\u00b6\n\n\n\n\n\n\n\n\nCategory\n\n\nFunction\n\n\nSFM 3000/5000\n\n\nSFM 4000\n\n\nSFM 3500\n\n\nSFM 5500\n\n\nBE Pass\n\n\nBE Smart\n\n\n\n\n\n\n\n\n\n\nSerial Comm. API\n\n\nUF_InitCommPort\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_CloseCommPort\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_Reconnect\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetBaudrate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetAsciiMode\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nSocket API\n\n\nUF_InitSocket\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_CloseSocket\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nLow-Level Packet API\n\n\nUF_SendPacket\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ReceivePacket\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SendNetworkPacket\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ReceiveNetworkPacket\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SendRawData\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ReceiveRawData\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SendDataPacket\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetSendPacketCallback\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetReceivePacketCallback\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetSendDataPacketCallback\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetReceiveDataPacketCallback\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetSendRawDataCallback\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetReceiveRawDataCallback\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetDefaultPacketSize\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetDefaultPacketSize\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nGeneral Command API\n\n\nUF_Command\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_CommandEx\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_CommandSendData\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_CommandSendDataEx\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_Cancel\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetProtocol\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetProtocol\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetModuleID\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetGenericCommandTimeout\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetInputCommandTimeout\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetGenericCommandTimeout\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetInputCommandTimeout\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetNetworkDelay\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetNetworkDelay\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nModule API\n\n\nUF_GetModuleInfo\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetModuleString\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SearchModule\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SearchModuleID\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SearchModuleBySocket\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SearchModuleIDEx\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_CalibrateSensor\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_Upgrade\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_Reset\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ PowerOff\n\n\nX\n\n\nO\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_Lock\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_Unlock\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ChangePassword\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nSystem Parameters API\n\n\nUF_InitSysParameter\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetSysParameter\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetSysParameter\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetMultiSysParameter\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetMultiSysParameter\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_Save\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SaveConfiguration\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ReadConfigurationHeader\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_LoadConfiguration\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_MakeParameterConfiguration\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nTemplate Mgmt. API\n\n\nUF_GetNumOfTemplate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetMaxNumOfTemplate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetAllUserInfo\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetAllUserInfoEx\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SortUserInfo\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetUserInfoCallback\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetAdminLevel\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetAdminLevel\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ClearAllAdminLevel\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SaveDB\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_LoadDB\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_CheckTemplate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ReadTemplate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ReadOneTemplate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetScanCallback\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ScanTemplate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_FixProvisionalTemplate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetSecurityLevel\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetSecurityLevel\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetAuthType*\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetAuthType*\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetUserIDByAuthType*\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ResetAllAuthType*\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetEntranceLimit*\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetEntranceLimit*\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ClearAllEntranceLimit*\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nImage API\n\n\nUF_ConvertToBitmap\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SaveImage\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_LoadImage\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ReadImage\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ScanImage\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nEnroll API\n\n\nUF_Enroll\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_EnrollContinue\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_EnrollAfterVerification\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_EnrollTemplate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_EnrollMultipleTemplates\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_EnrollImage\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetEnrollCallback\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nIdentify API\n\n\nUF_Identify\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_IdentifyTemplate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_IdentifyImage\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetIdentifyCallback\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nVerify API\n\n\nUF_Verify\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_VerifyTemplate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_VerifyHostTemplate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_VerifyImage\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetVerifyCallback\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nDelete API\n\n\nUF_Delete\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_DeleteOneTemplate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_DeleteMultipleTemplates\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_DeleteAll\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_DeleteByScan\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetDeleteCallback\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nI/O API\n\n\nUF_InitIO\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetInputFunction\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetInputFunction\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetInputStatus\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetOutputEventList\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ClearAllOutputEvent\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ClearOutputEvent\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetOutputEvent\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetOutputEvent\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetOutputStatus\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetLegacyWiegandConfig\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetLegacyWiegandConfig\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_MakeIOConfiguration\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nGPIO API\n\n\nUF_GetGPIOConfiguration\n\n\nO\n\n\nO\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_SetInputGPIO\n\n\nO\n\n\nO\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_SetOutputGPIO\n\n\nO\n\n\nO\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_SetSharedGPIO\n\n\nO\n\n\nO\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_DisableGPIO\n\n\nO\n\n\nO\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_ClearAllGPIO\n\n\nO\n\n\nO\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_SetDefaultGPIO\n\n\nO\n\n\nO\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_EnableWiegandInput\n\n\nO\n\n\nO\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_EnableWiegandOutput\n\n\nO\n\n\nO\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_DisableWiegandInput\n\n\nO\n\n\nO\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_DisableWiegandOutput\n\n\nO\n\n\nO\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_MakeGPIOConfiguration\n\n\nO\n\n\nO\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\nUser Memory API\n\n\nUF_WriteUserMemory\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ReadUserMemory\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nLog and Time Mgmt. API\n\n\nUF_SetTime\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetTime\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetNumOfLog\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ReadLog\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ReadLatestLog\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_DeleteOldestLog\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_DeleteAllLog\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ClearLogCache\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ReadLogCache\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetCustomLogField\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetCustomLogField\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nExtended Wiegand API\n\n\nUF_SetWiegandFormat\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetWiegandFormat\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetWiegandIO\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetWiegandIO\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetWiegandOption\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetWiegandOption\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetAltValue\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ClearAltValue\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetAltValue\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_MakeWiegandConfiguration\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nWiegand Command Card API\n\n\nUF_AddWiegandCommandCard\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetWiegandCommandCardList\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ClearAllWiegandCommandCard\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nSmartCard API\n\n\nUF_ReadSmartCard\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_ReadSmartCardWithAG\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_WriteSmartCard\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_WriteSmartCardWithAG\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_WriteSmartCardWithEntranceLimit*\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_FormatSmartCard\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetSmartCardMode\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetSmartCardMode\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_ChangePrimaryKey\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_ChangeSecondaryKey\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetKeyOption\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetKeyOption\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetCardLayout\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetCardLayout\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetSmartCardCallback\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\nAccess Control API\n\n\nUF_AddTimeSchedule\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetTimeSchedule\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_DeleteTimeSchedule\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_DeleteAllTimeSchedule\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_AddHoliday\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetHoliday\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_DeleteHoliday\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_DeleteAllHoliday\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_AddAccessGroup\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetAccessGroup\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_DeleteAccessGroup\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_DeleteAllAccessGroup\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetUserAccessGroup\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetUserAccessGroup\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\n\n\n\n\nBlacklist API\n\n\nUF_AddBlacklist\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_DeleteBlacklist\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetBlacklist\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_DeleteAllBlacklist\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nWSQ API\n\n\nUF_ScanImageEx\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_ReadImageEx\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_WSQ_Decode\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\nX\n\n\nX",
            "title": "API Compatability"
        },
        {
            "location": "/documents/API_Compatibility/#2-api-compatibility",
            "text": "Category  Function  SFM 3000/5000  SFM 4000  SFM 3500  SFM 5500  BE Pass  BE Smart      Serial Comm. API  UF_InitCommPort  O  O  O  O  O  O     UF_CloseCommPort  O  O  O  O  O  O     UF_Reconnect  O  O  O  O  O  O     UF_SetBaudrate  O  O  O  O  O  O     UF_SetAsciiMode  O  O  O  O  O  O    Socket API  UF_InitSocket  O  O  O  O  O  O     UF_CloseSocket  O  O  O  O  O  O    Low-Level Packet API  UF_SendPacket  O  O  O  O  O  O     UF_ReceivePacket  O  O  O  O  O  O     UF_SendNetworkPacket  O  O  O  O  O  O     UF_ReceiveNetworkPacket  O  O  O  O  O  O     UF_SendRawData  O  O  O  O  O  O     UF_ReceiveRawData  O  O  O  O  O  O     UF_SendDataPacket  O  O  O  O  O  O     UF_SetSendPacketCallback  O  O  O  O  O  O     UF_SetReceivePacketCallback  O  O  O  O  O  O     UF_SetSendDataPacketCallback  O  O  O  O  O  O     UF_SetReceiveDataPacketCallback  O  O  O  O  O  O     UF_SetSendRawDataCallback  O  O  O  O  O  O     UF_SetReceiveRawDataCallback  O  O  O  O  O  O     UF_SetDefaultPacketSize  O  O  O  O  O  O     UF_GetDefaultPacketSize  O  O  O  O  O  O    General Command API  UF_Command  O  O  O  O  O  O     UF_CommandEx  O  O  O  O  O  O     UF_CommandSendData  O  O  O  O  O  O     UF_CommandSendDataEx  O  O  O  O  O  O     UF_Cancel  O  O  O  O  O  O     UF_SetProtocol  O  O  O  O  O  O     UF_GetProtocol  O  O  O  O  O  O     UF_GetModuleID  O  O  O  O  O  O     UF_SetGenericCommandTimeout  O  O  O  O  O  O     UF_SetInputCommandTimeout  O  O  O  O  O  O     UF_GetGenericCommandTimeout  O  O  O  O  O  O     UF_GetInputCommandTimeout  O  O  O  O  O  O     UF_SetNetworkDelay  O  O  O  O  O  O     UF_GetNetworkDelay  O  O  O  O  O  O    Module API  UF_GetModuleInfo  O  O  O  O  O  O     UF_GetModuleString  O  O  O  O  O  O     UF_SearchModule  O  O  O  O  O  O     UF_SearchModuleID  O  O  O  O  O  O     UF_SearchModuleBySocket  O  O  O  O  O  O     UF_SearchModuleIDEx  O  O  O  O  O  O     UF_CalibrateSensor  O  O  O  O  O  O     UF_Upgrade  O  O  O  O  O  O     UF_Reset  O  O  O  O  O  O     UF_ PowerOff  X  O  X  X  X  X     UF_Lock  X  X  O  O  O  O     UF_Unlock  X  X  O  O  O  O     UF_ChangePassword  X  X  O  O  O  O    System Parameters API  UF_InitSysParameter  O  O  O  O  O  O     UF_GetSysParameter  O  O  O  O  O  O     UF_SetSysParameter  O  O  O  O  O  O     UF_GetMultiSysParameter  O  O  O  O  O  O     UF_SetMultiSysParameter  O  O  O  O  O  O     UF_Save  O  O  O  O  O  O     UF_SaveConfiguration  O  O  O  O  O  O     UF_ReadConfigurationHeader  O  O  O  O  O  O     UF_LoadConfiguration  O  O  O  O  O  O     UF_MakeParameterConfiguration  O  O  O  O  O  O    Template Mgmt. API  UF_GetNumOfTemplate  O  O  O  O  O  O     UF_GetMaxNumOfTemplate  O  O  O  O  O  O     UF_GetAllUserInfo  O  O  O  O  O  O     UF_GetAllUserInfoEx  X  X  X  X  O  O     UF_SortUserInfo  O  O  O  O  O  O     UF_SetUserInfoCallback  O  O  O  O  O  O     UF_SetAdminLevel  O  O  O  O  O  O     UF_GetAdminLevel  O  O  O  O  O  O     UF_ClearAllAdminLevel  O  O  O  O  O  O     UF_SaveDB  O  O  O  O  O  O     UF_LoadDB  O  O  O  O  O  O     UF_CheckTemplate  O  O  O  O  O  O     UF_ReadTemplate  O  O  O  O  O  O     UF_ReadOneTemplate  O  O  O  O  O  O     UF_SetScanCallback  O  O  O  O  O  O     UF_ScanTemplate  O  O  O  O  O  O     UF_FixProvisionalTemplate  O  O  O  O  O  O     UF_SetSecurityLevel  O  O  O  O  O  O     UF_GetSecurityLevel  O  O  O  O  O  O     UF_SetAuthType*  X  X  O  O  O  O     UF_GetAuthType*  X  X  O  O  O  O     UF_GetUserIDByAuthType*  X  X  O  O  O  O     UF_ResetAllAuthType*  X  X  O  O  O  O     UF_SetEntranceLimit*  X  X  O  O  O  O     UF_GetEntranceLimit*  X  X  O  O  O  O     UF_ClearAllEntranceLimit*  X  X  O  O  O  O    Image API  UF_ConvertToBitmap  O  O  O  O  O  O     UF_SaveImage  O  O  O  O  O  O     UF_LoadImage  O  O  O  O  O  O     UF_ReadImage  O  O  O  O  O  O     UF_ScanImage  O  O  O  O  O  O    Enroll API  UF_Enroll  O  O  O  O  O  O     UF_EnrollContinue  O  O  O  O  O  O     UF_EnrollAfterVerification  O  O  O  O  O  O     UF_EnrollTemplate  O  O  O  O  O  O     UF_EnrollMultipleTemplates  O  O  O  O  O  O     UF_EnrollImage  O  O  O  O  O  O     UF_SetEnrollCallback  O  O  O  O  O  O    Identify API  UF_Identify  O  O  O  O  O  O     UF_IdentifyTemplate  O  O  O  O  O  O     UF_IdentifyImage  O  O  O  O  O  O     UF_SetIdentifyCallback  O  O  O  O  O  O    Verify API  UF_Verify  O  O  O  O  O  O     UF_VerifyTemplate  O  O  O  O  O  O     UF_VerifyHostTemplate  O  O  O  O  O  O     UF_VerifyImage  O  O  O  O  O  O     UF_SetVerifyCallback  O  O  O  O  O  O    Delete API  UF_Delete  O  O  O  O  O  O     UF_DeleteOneTemplate  O  O  O  O  O  O     UF_DeleteMultipleTemplates  O  O  O  O  O  O     UF_DeleteAll  O  O  O  O  O  O     UF_DeleteByScan  O  O  O  O  O  O     UF_SetDeleteCallback  O  O  O  O  O  O    I/O API  UF_InitIO  X  X  O  O  O  O     UF_SetInputFunction  X  X  O  O  O  O     UF_GetInputFunction  X  X  O  O  O  O     UF_GetInputStatus  X  X  O  O  O  O     UF_GetOutputEventList  X  X  O  O  O  O     UF_ClearAllOutputEvent  X  X  O  O  O  O     UF_ClearOutputEvent  X  X  O  O  O  O     UF_SetOutputEvent  X  X  O  O  O  O     UF_GetOutputEvent  X  X  O  O  O  O     UF_SetOutputStatus  X  X  O  O  O  O     UF_SetLegacyWiegandConfig  X  X  O  O  O  O     UF_GetLegacyWiegandConfig  X  X  O  O  O  O     UF_MakeIOConfiguration  X  X  O  O  O  O    GPIO API  UF_GetGPIOConfiguration  O  O  X  X  X  X     UF_SetInputGPIO  O  O  X  X  X  X     UF_SetOutputGPIO  O  O  X  X  X  X     UF_SetSharedGPIO  O  O  X  X  X  X     UF_DisableGPIO  O  O  X  X  X  X     UF_ClearAllGPIO  O  O  X  X  X  X     UF_SetDefaultGPIO  O  O  X  X  X  X     UF_EnableWiegandInput  O  O  X  X  X  X     UF_EnableWiegandOutput  O  O  X  X  X  X     UF_DisableWiegandInput  O  O  X  X  X  X     UF_DisableWiegandOutput  O  O  X  X  X  X     UF_MakeGPIOConfiguration  O  O  X  X  X  X    User Memory API  UF_WriteUserMemory  O  O  O  O  O  O     UF_ReadUserMemory  O  O  O  O  O  O    Log and Time Mgmt. API  UF_SetTime  X  X  O  O  O  O     UF_GetTime  X  X  O  O  O  O     UF_GetNumOfLog  X  X  O  O  O  O     UF_ReadLog  X  X  O  O  O  O     UF_ReadLatestLog  X  X  O  O  O  O     UF_DeleteOldestLog  X  X  O  O  O  O     UF_DeleteAllLog  X  X  O  O  O  O     UF_ClearLogCache  X  X  O  O  O  O     UF_ReadLogCache  X  X  O  O  O  O     UF_SetCustomLogField  X  X  O  O  O  O     UF_GetCustomLogField  X  X  O  O  O  O    Extended Wiegand API  UF_SetWiegandFormat  X  X  O  O  O  O     UF_GetWiegandFormat  X  X  O  O  O  O     UF_SetWiegandIO  X  X  O  O  O  O     UF_GetWiegandIO  X  X  O  O  O  O     UF_SetWiegandOption  X  X  O  O  O  O     UF_GetWiegandOption  X  X  O  O  O  O     UF_SetAltValue  X  X  O  O  O  O     UF_ClearAltValue  X  X  O  O  O  O     UF_GetAltValue  X  X  O  O  O  O     UF_MakeWiegandConfiguration  X  X  O  O  O  O    Wiegand Command Card API  UF_AddWiegandCommandCard  X  X  O  O  O  O     UF_GetWiegandCommandCardList  X  X  O  O  O  O     UF_ClearAllWiegandCommandCard  X  X  O  O  O  O    SmartCard API  UF_ReadSmartCard  X  X  X  X  X  O     UF_ReadSmartCardWithAG  X  X  X  X  X  O     UF_WriteSmartCard  X  X  X  X  X  O     UF_WriteSmartCardWithAG  X  X  X  X  X  O     UF_WriteSmartCardWithEntranceLimit*  X  X  X  X  X  O     UF_FormatSmartCard  X  X  X  X  X  O     UF_SetSmartCardMode  X  X  X  X  X  O     UF_GetSmartCardMode  X  X  X  X  X  O     UF_ChangePrimaryKey  X  X  X  X  X  O     UF_ChangeSecondaryKey  X  X  X  X  X  O     UF_SetKeyOption  X  X  X  X  X  O     UF_GetKeyOption  X  X  X  X  X  O     UF_SetCardLayout  X  X  X  X  X  O     UF_GetCardLayout  X  X  X  X  X  O     UF_SetSmartCardCallback  X  X  X  X  X  O    Access Control API  UF_AddTimeSchedule  X  X  X  X  O  O     UF_GetTimeSchedule  X  X  X  X  O  O     UF_DeleteTimeSchedule  X  X  X  X  O  O     UF_DeleteAllTimeSchedule  X  X  X  X  O  O     UF_AddHoliday  X  X  X  X  O  O     UF_GetHoliday  X  X  X  X  O  O     UF_DeleteHoliday  X  X  X  X  O  O     UF_DeleteAllHoliday  X  X  X  X  O  O     UF_AddAccessGroup  X  X  X  X  O  O     UF_GetAccessGroup  X  X  X  X  O  O     UF_DeleteAccessGroup  X  X  X  X  O  O     UF_DeleteAllAccessGroup  X  X  X  X  O  O     UF_SetUserAccessGroup  X  X  X  X  O  O     UF_GetUserAccessGroup  X  X  X  X  O  O    Blacklist API  UF_AddBlacklist  X  X  O  O  O  O     UF_DeleteBlacklist  X  X  O  O  O  O     UF_GetBlacklist  X  X  O  O  O  O     UF_DeleteAllBlacklist  X  X  O  O  O  O    WSQ API  UF_ScanImageEx  X  X  X  O  X  X     UF_ReadImageEx  X  X  X  O  X  X     UF_WSQ_Decode  X  X  X  O  X  X",
            "title": "2. API Compatibility"
        },
        {
            "location": "/documents/API_Specification/",
            "text": "3. API Specification\n\u00b6\n\n\n3.1. Return Codes\n\u00b6\n\n\nMost APIs in the SDK return UF_RET_CODE. The return codes and their meanings are as follows;\n\n\n\n\n\n\n\n\nCategory\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSuccess\n\n\nUF_RET_SUCCESS\n\n\nThe function succeeds.\n\n\n\n\n\n\nSerial Comm.\n\n\nUF_ERR_CANNOT_OPEN_SEREIAL\n\n\nCannot open the specified serial port.\n\n\n\n\n\n\n\n\nUF_ERR_CANNOT_SETUP_SERIAL\n\n\nCannot set the baud rate.\n\n\n\n\n\n\n\n\nUF_ERR_CANNOT_WRITE_SERIAL\n\n\nCannot write data to the serial port.\n\n\n\n\n\n\n\n\nUF_ERR_WRITE_SERIAL_TIMEOUT\n\n\nWrite timeout.\n\n\n\n\n\n\n\n\nUF_ERR_CANNOT_READ_SERIAL\n\n\nCannot read data from the serial port.\n\n\n\n\n\n\n\n\nUF_ERR_READ_SERIAL_TIMEOUT\n\n\nRead timeout.\n\n\n\n\n\n\n\n\nUF_ERR_CHECKSUM_ERROR\n\n\nReceived packet has wrong checksum.\n\n\n\n\n\n\n\n\nUF_ERR_CANNOT_SET_TIMEOUT\n\n\nCannot set communication timeout.\n\n\n\n\n\n\nSocket\n\n\nUF_ERR_CANNOT_START_SOCKET\n\n\nCannot initialize the socket interface.\n\n\n\n\n\n\n\n\nUF_ERR_CANNOT_OPEN_SOCKET\n\n\nCannot open the socket.\n\n\n\n\n\n\n\n\nUF_ERR_CANNOT_CONNECT_SOCKET\n\n\nCannot connect to the socket.\n\n\n\n\n\n\n\n\nUF_ERR_CANNOT_READ_SOCKET\n\n\nCannot read data from the socket.\n\n\n\n\n\n\n\n\nUF_ERR_READ_SOCKET_TIMEOUT\n\n\nRead timeout.\n\n\n\n\n\n\n\n\nUF_ERR_CANNOT_WRITE_SOCKET\n\n\nCannot write data to the socket.\n\n\n\n\n\n\n\n\nUF_ERR_WRITE_SOCKET_TIMEOUT\n\n\nWrite timeout.\n\n\n\n\n\n\nProtocol\n\n\nUF_ERR_SCAN_FAIL\n\n\nSensor or fingerprint input has failed.\n\n\n\n\n\n\n\n\nUF_ERR_NOT_FOUND\n\n\nIdentification failed, or the requested data is not found.\n\n\n\n\n\n\n\n\nUF_ERR_NOT_MATCH\n\n\nFingerprint does not match.\n\n\n\n\n\n\n\n\nUF_ERR_TRY_AGAIN\n\n\nFingerprint image is not good.\n\n\n\n\n\n\n\n\nUF_ERR_TIME_OUT\n\n\nTimeout for fingerprint input.\n\n\n\n\n\n\n\n\nUF_ERR_MEM_FULL\n\n\nNo more templates are allowed.\n\n\n\n\n\n\n\n\nUF_ERR_EXIST_ID\n\n\nThe specified user ID already exists.\n\n\n\n\n\n\n\n\nUF_ERR_FINGER_LIMIT\n\n\nThe number of fingerprints enrolled in same ID exceeds its limit.\n\n\n\n\n\n\n\n\nUF_ERR_UNSUPPORTED\n\n\nThe command is not supported.\n\n\n\n\n\n\n\n\nUF_ERR_INVALID_ID\n\n\nThe requested user ID is invalid or missing.\n\n\n\n\n\n\n\n\nUF_ERR_TIMEOUT_MATCH\n\n\nTimeout for fingerprint identification.\n\n\n\n\n\n\n\n\nUF_ERR_BUSY\n\n\nModule is processing another command.\n\n\n\n\n\n\n\n\nUF_ERR_CANCELED\n\n\nThe command is canceled.\n\n\n\n\n\n\n\n\nUF_ERR_DATA_ERROR\n\n\nThe checksum of a data packet is incorrect.\n\n\n\n\n\n\n\n\nUF_ERR_EXIST_FINGER\n\n\nThe finger is already enrolled.\n\n\n\n\n\n\n\n\nUF_ERR_DURESS_FINGER\n\n\nA duress finger is detected.\n\n\n\n\n\n\n\n\nUF_ERR_CARD_ERROR\n\n\nCannot read a smart card.\n\n\n\n\n\n\n\n\nUF_ERR_LOCKED\n\n\nModule is locked.\n\n\n\n\n\n\n\n\nUF_ERR_ACCESS_NOT_GRANTED\n\n\nAccess is not granted by time schedule and access group.\n\n\n\n\n\n\n\n\nUF_ERR_REJECTED_ID\n\n\nAuthentication type of the user is UF_AUTH_REJECT or the ID is in the blacklist.\n\n\n\n\n\n\n\n\nUF_ERR_FAKE_DETECTED\n\n\nScanned finger is determined as a fake finger.\n\n\n\n\n\n\n\n\nUF_ERR_EXCEED_ENTRANCE_LIMIT\n\n\nEntrance limit is exceeded.\n\n\n\n\n\n\nApplication\n\n\nUF_ERR_OUT_OF_MEMORY\n\n\nOut of memory.\n\n\n\n\n\n\n\n\nUF_ERR_INVALID_PARAMETER\n\n\nInvalid parameter.\n\n\n\n\n\n\n\n\nUF_ERR_FILE_IO\n\n\nFile I/O failed\n\n\n\n\n\n\n\n\nUF_ERR_INVALID_FILE\n\n\nThe configuration or DB file is invalid.\n\n\n\n\n\n\n\n\n\n\n3.2. Serial Communication API\n\u00b6\n\n\nTo communicate with SFM modules, users should configure the serial port first.\n\n\n\n\nUF_InitCommPort: configures serial port parameters.\n\n\nUF_CloseCommPort: closes the serial port.\n\n\nUF_Reconnect: resets system parameters and IO settings.\n\n\nUF_SetBaudrate: changes the baud rate.\n\n\nUF_SetAsciiMode: changes the packet translation mode.\n\n\n\n\n\n\nUF_InitCommPort\n\u00b6\n\n\nOpens a serial port and configures communication parameters. This function should be called first before calling any other APIs.\n\n\nUF_RET_CODE UF_InitCommPort( const char* commPort, int baudrate, BOOL asciiMode )\n\n\nParameters\n  \n\n\ncommPort\n\nPointer to a null-terminated string that specifies the name of the serial port.  \n\n\nbaudrate\n\nSpecifies the baud rate at which the serial port operates. Available baud rates are 9600, 19200, 38400, 57600, 115200bps (230400bps and 460800bps are available in later version of 5.0). The default setting of SFM modules is 115200bps.  \n\n\nasciiMode\n\nDetermines the packet translation mode. If it is set to TRUE, the binary packet is converted to ASCII format first before being sent to the module. Response packets are in ASCII format, too. The default setting of SFM modules is binary mode.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.  \n\n\nExample\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_InitCommPort\n(\n \n\u201c\nCOM1\n\u201d\n,\n \n115200\n,\n \nFALSE\n \n);\n\n\n\n\n\n\nUF_CloseCommPort\n\u00b6\n\n\nCloses the serial port opened by \nUF_InitCommPort.\n\n\nUF_RET_CODE UF_CloseCommPort()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_Reconnect\n\u00b6\n\n\nTo improve communication efficiency, the SDK caches basic information of a module such as system parameters and I/O settings. \nUF_Reconnect\n clears this cached information. When changing the modules connected to the serial port, this function should be called.\n\n\nvoid UF_Reconnect()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nNone\n\n\n\n\nUF_SetBaudrate\n\u00b6\n\n\nChanges the baud rate.\n\n\nUF_RET_CODE UF_SetBaudrate( int baudrate )\n\n\nParameters\n\n\nbaudrate\n\nSpecifies the baud rate at which the serial port operates. Available baud rates are 9600, 19200, 38400, 57600, 115200bps. The default setting of SFM modules is 115200bps.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the\ncorresponding error code.\n\n\n\n\nUF_SetAsciiMode\n\u00b6\n\n\nChanges the packet translation mode.\n\n\nvoid UF_SetAsciiMode( BOOL asciiMode )\n\n\nParameters\n\n\nasciiMode\n\nTRUE for ascii format, FALSE for binary format.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\n3.3. Socket API\n\u00b6\n\n\nIn addition to serial ports, users can connect to the module by Ethernet-to-Serial converters. In this case, socket API should be used in place of serial API.\n\n\n\n\nUF_InitSocket: opens a socket and connects to the specified IP address.\n\n\nUF_CloseSocket: closes the socket.\n\n\n\n\n\n\nUF_InitSocket\n\u00b6\n\n\nInitializes the socket interface and connects to the module with specified IP address.\n\n\nUF_RET_CODE UF_InitSocket( const char* inetAddr, int port, BOOL asciiMode )\n\n\nParameters\n\n\ninetAddr\n\nIP address of the Ethernet-to-Serial converter.\n\nport\n\nTCP port of the socket interface.\n\nasciiMode\n\nDetermines the packet translation mode. If it is set to TRUE, the binary packet is converted to ASCII format first before being sent to the module. Response packets are in ASCII format, too. The default setting of SFM modules is binary mode.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\nExample\n\u00b6\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_InitSocket\n(\n \n\u201c\n192.168.1.41\n\u201d\n,\n \n1470\n,\n \nFALSE\n \n);\n\n\n\n\n\nUF_CloseSocket\n\u00b6\n\n\nCloses the socket interface.\n\n\nUF_RET_CODE UF_CloseSocket()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\n3.4. Low-Level Packet API\n\u00b6\n\n\nThese functions provide direct interface to the low-level packet exchanges. In most cases, users need not to call these functions directly. Command API and other high level APIs are implemented on top of this API.\nPacket API also let users set callback functions for data transfer. Examples of using these callback functions for GUI application can be found in UniFingerUI V4.0 source codes.\n\n\n\n\nUF_SendPacket: sends a 13 byte packet.\n\n\nUF_SendNetworkPacket: sends a 15 byte network packet.\n\n\nUF_ReceivePacket: receives a 13 byte packet.\n\n\nUF_ReceiveNetworkPacket: receives a 15 byte network packet.\n\n\nUF_SendRawData: sends raw data.\n\n\nUF_ReceiveRawData: receives raw data.\n\n\nUF_SendDataPacket: sends data using Extended Data Transfer Protocol.\n\n\nUF_ReceiveDataPacket: receives data using Extended Data Transfer Protocol.\n\n\nUF_SetSendPacketCallback: sets the callback function of sending packets.\n\n\nUF_SetReceivePacketCallback: sets the callback function of receiving packets.\n\n\nUF_SetSendDataPacketCallback: sets the callback function of sending data packets.\n\n\nUF_SetReceiveDataPacketCallback: sets the callback function of receiving data packets.\n\n\nUF_SetSendRawDataCallback: sets the callback function of sending raw data.\n\n\nUF_SetReceiveRawDataCallback: sets the callback function of receiving raw data.\n\n\nUF_SetDefaultPacketSize: sets the size of data packets.\n\n\nUF_GetDefaultPacketSize: gets the size of data packets.\n\n\n\n\n\n\nUF_SendPacket\n\u00b6\n\n\nSends a 13 byte packet to the module. The packet is composed as follows;\n\n\n\n\n\n\n\n\nStart code\n\n\nCommand\n\n\nParam\n\n\nSize\n\n\nFlag/Error\n\n\nChecksum\n\n\nEnd code\n\n\n\n\n\n\n\n\n\n\n1byte\n\n\n1byte\n\n\n4bytes\n\n\n4bytes\n\n\n1byte\n\n\n1byte\n\n\n1byte\n\n\n\n\n\n\n\n\n\n\nStart code: 1 byte. Indicates the beginning of a packet. It always should be 0x40.\n\n\nCommand: 1 byte. Refer to the Packet Protocol Manual for available commands.\n\n\nParam: 4 bytes. The meaning of this field varies according to each command.\n\n\nSize: 4 bytes. The meaning of this field varies according to each command.\n\n\nFlag/Error: 1 byte. Indicates flag data in the request packet, and error code in the response packet.\n\n\nChecksum: 1 byte. Checks the validity of a packet. Checksum is a remainder of the sum of each field, from the Start code to Flag/Error, divided by 256 (0x100).\n\n\nEnd code: 1 byte. Indicates the end of a packet. It always should be 0x0A. It is also used as a code indicating the end of binary data such as fingerprint templates.\n\n\n\n\nUF_RET_CODE UF_SendPacket( BYTE command, UINT32 param, UINT32 size, BYTE flag, int timeout )\n\n\nParameters\n\n\ncommand\n\nCommand field of a packet. Refer to the Packet Protocol Manual for available commands.\n\nparam\n\nParam field of a packet.\n\nsize\n\nSize field of a packet.\n\nflag\n\nFlag field of a packet.\n\ntimeout\n\nSets the timeout in milliseconds. If sending does not complete within this limit, UF_ERR_WRITE_SERIAL_TIMEOUT will be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\nExample\n\u00b6\n\n\n// To send ES command with user ID 10 and ADD_NEW(0x79) option,\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_SendPacket\n(\n \nUF_COM_ES\n,\n \n10\n,\n \n0\n,\n \n0x79\n,\n \n2000\n \n);\n\n\n\nIf\n(\n \nresult\n \n!=\n \nUF_RET_SUCCESS\n \n)\n\n\n{\n\n    \nReturn\n \nresult\n;\n\n\n}\n\n\n\n\n\n\n\nUF_SendNetworkPacket\n\u00b6\n\n\nSends a 15 byte network packet to the specified module. In order to support RS422 or RS485 network interfaces, SFM modules support Network Packet Protocol. Network packet is composed of 15 bytes, whose start code is different from the standard packet, and includes 2 bytes for terminal ID. The terminal ID is equal to the lower 2 bytes of Module ID of system parameter.\n\n\n\n\n\n\n\n\nField\n\n\nStart code\n\n\nTerminal ID\n\n\nCommand\n\n\nParam\n\n\nSize\n\n\nFlag / Error\n\n\nChecksum\n\n\nEnd code\n\n\n\n\n\n\n\n\n\n\nBytes\n\n\n1\n\n\n2\n\n\n1\n\n\n4\n\n\n4\n\n\n1\n\n\n1\n\n\n1\n\n\n\n\n\n\nValue\n\n\n0x41\n\n\n1 ~ 0xFFFF\n\n\n\n\n\n\nSame as standard protocol\n\n\n\n\nChecksum of 13 bytes\n\n\n0x0A\n\n\n\n\n\n\n\n\nUF_SendNetworkPacket( BYTE command, USHORT terminalID, UINT32 param, UINT32 size, BYTE flag, int timeout )\n\n\nParameters\n  \n\n\ncommand\n\nCommand field of a packet. Refer to the Packet Protocol Manual for available commands.\n\nterminalID\n\nSpecifies the terminal ID of the receiving module.\n\nparam\n\nParam field of a packet.\n\nsize\n\nSize field of a packet.\n\nflag\n\nFlag field of a packet.\n\ntimeout\n\nSets the timeout in milliseconds. If sending does not complete within this limit, UF_ERR_WRITE_SERIAL_TIMEOUT will be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_ReceivePacket\n\u00b6\n\n\nReceives a 13 byte packet from the module. Most commands of Packet Protocol can be implemented by a pair of \nUF_SendPacket/UF_ReceivePacket\n or \nUF_SendNetworkPacket/UF_ReceiveNetworkPacket.\n\n\nUF_RET_CODE UF_ReceivePacket( BYTE* packet, int timeout )\n\n\nParameters\n\n\npacket\n\nPointer to the 13 byte packet.\n\ntimeout\n\nSets the timeout in milliseconds. If receiving does not complete within this limit, UF_ERR_READ_SERIAL_TIMEOUT will be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\nUF_ReceiveNetworkPacket\n\u00b6\n\n\nReceives a 15 byte network packet from the specified module.\n\n\nUF_ReceiveNetworkPacket( BYTE* packet, int timeout )\n\n\nParameters\n\n\npacket\n\nPointer to the 15 byte packet.\n\ntimeout\n\nSets the timeout in milliseconds. If receiving does not complete within this limit, UF_ERR_READ_SERIAL_TIMEOUT will be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SendRawData\n\u00b6\n\n\nSome commands such as ET(Enroll Template) and IT(Identify Template) send additional data after the 13/15 byte request packet. \nUF_SendRawData\n is used in these cases for sending the data.\n\n\nUF_RET_CODE UF_SendRawData( BYTE* buf, UINT32 size, int timeout )\n\n\nParameters\n\n\nbuf\n\nPointer to a data buffer.\n\nsize\n\nNumber of bytes to be sent.\n\ntimeout\n\nSets the timeout in milliseconds. If sending does not complete within this limit, UF_ERR_WRITE_SERIAL_TIMEOUT will be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_ReceiveRawData\n\u00b6\n\n\nSome commands such as ST(Scan Template) and RT(Read Template) return additional data after the 13/15 byte response packet. \nUF_ReceiveRawData\n is used in these cases for receiving the data.\n\n\nUF_RET_CODE UF_ReceiveRawData( BYTE* buf, UINT32 size, int timeout, BOOL checkEndCode )\n\n\nParameters\n\n\nbuf\n\nPointer to a data buffer.\n\nsize\n\nNumber of bytes to be received.\n\ntimeout\n\nSets the timeout in milliseconds. If receiving does not complete within this limit, UF_ERR_READ_SERIAL_TIMEOUT will be returned.\n\ncheckEndCode\n\nData transfer ends with \u20180x0a\u2019. If this parameter is FALSE, the function returns without checking the end code.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SendDataPacket\n\u00b6\n\n\nSends data using Extended Data Transfer Protocol. Dividing large data into small blocks can reduce communication errors between the host and the module. Extended Data Transfer Protocol is an extension of Packet Protocol to provide a reliable and customizable communication for large data. In Extended Data Transfer Protocol, data is divided into multiple data packets. And a data packet consists of fixed-length header, variable-length data body, and 4 byte checksum. Commands which use the Extended Data Transfer Protocols are EIX, VIX, IIX, RIX, SIX, and UG.\n\n\nUF_SendDataPacket( BYTE command, BYTE* buf, UINT32 dataSize, UINT32 dataPacketSize )\n\n\nParameters\n\n\ncommand\n\nCommand field of a packet. Valid commands are EIX, VIX, IIX, RIX, SIX, and UG.\n\nbuf\n\nPointer to a data buffer.\n\ndataSize\n\nNumber of bytes to be sent.\n\ndataPacketSize\n\nSize of data packet. For example, if dataSize is 16384 bytes and dataPacketSize is 4096 bytes, the data will be divided into 4 data packets.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_ReceiveDataPacket\n\u00b6\n\n\nReceives data using Extended Data Transfer Protocol. The size of data packet should be specified before calling this function.\n\n\nUF_ReceiveDataPacket( BYTE command, BYTE* buf, UINT32 dataSize )\n\n\nParameters\n\n\ncommand\n\nCommand field of a packet. Valid commands are EIX, VIX, IIX, RIX, SIX, and UG.\n\nbuf\n\nPointer to a data buffer.\n\ndataSize\n\nNumber of bytes to be received.\n\n\nReturn Values\n  \n\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SetSendPacketCallback\n\u00b6\n\n\nIf \nSendPacketCallback\n is specified, it is called after sending a packet successfully. The argument of the callback is the pointer to the packet.\n\n\nvoid UF_SetSendPacketCallback( void (*callback)( BYTE* ) )\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.\n\n\nReturn Values\n\nNone\n\n\nExample\n\u00b6\n\n\nSee CMainFrame::SendPacketCallback in UniFingerUI source codes.\n\n\n\n\nUF_SetReceivePacketCallback\n\u00b6\n\n\nIf \nReceivePacketCallback\n is specified, it is called after receiving a packet successfully. The argument of the callback is the pointer to the received packet.\n\n\nvoid UF_SetReceivePacketCallback( void (*callback)( BYTE* ) )\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.\n\n\nReturn Values\n\nNone\n\n\nExample\n\u00b6\n\n\nSee CMainFrame::ReceivePacketCallback in UniFingerUI source codes.\n\n\n\n\nUF_SetSendDataPacketCallback\n\u00b6\n\n\nIf \nSendDataPacketCallback\n is specified, it is called after sending a data packet successfully. The argument of the callback is the index of the data packet and the number of total data packets.\n\n\nUF_SetSendDataPacketCallback( void (*callback)( int index, int numOfPacket ) )\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.\n\n\nReturn Values\n\nNone\n\n\nExample\n\u00b6\n\n\nSee CMainFrame::DataPacketCallback in UniFingerUI source codes.\n\n\n\n\nUF_SetReceiveDataPacketCallback\n\u00b6\n\n\nIf \nReceiveDataPacketCallback\n is specified, it is called after receiving a data packet successfully. The argument of the callback is the index of the data packet and the number of total data packets.\n\n\nvoid UF_SetReceiveDataPacketCallback( void (*callback)( int index, int numOfPacket ) )\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.\n\n\nReturn Values\n\nNone\n\n\nExample\n\u00b6\n\n\nSee CMainFrame::DataPacketCallback in UniFingerUI source codes.\n\n\n\n\nUF_SetSendRawDataCallback\n\u00b6\n\n\nIf \nSendRawDataCallback\n is specified, it is called during sending raw data. The argument of the callback is the written length and the total length of data.\n\n\nvoid UF_SetSendRawDataCallback( void (*callback)( int writtenLen, int totalSize ) )\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.\n\n\nReturn Values\n\nNone\n\n\nExample\n\u00b6\n\n\nSee CMainFrame::RawDataCallback in UniFingerUI source codes.\n\n\n\n\nUF_SetReceiveRawDataCallback\n\u00b6\n\n\nIf \nReceiveRawDataCallback\n is specified, it is called during receiving data. The argument of the callback is the read length and the total length of data.\n\n\nvoid UF_SetReceiveRawDataCallback( void (*callback)( int readLen, int totalSize ) )\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.\n\n\nReturn Values\n\nNone\n\n\nExample\n\u00b6\n\n\nSee CMainFrame::RawDataCallback in UniFingerUI source codes.\n\n\n\n\nUF_SetDefaultPacketSize\n\u00b6\n\n\nSets the size of data packets used in Extended Data Transfer protocol. The default value is 4096. When BEACon is used as an Ethernet-to-Serial converter, this value should not be larger than 256.\n\nvoid UF_SetDefaultPacketSize( int defaultSize )\n\n\nParameters\n\n\ndefaultSize\n\nSize of data packet.\n\n\nReturn Values\n\nNone\n\n\n\n\nUF_GetDefaultPacketSize\n\u00b6\n\n\nReturns the size of data packet used in Extended Data Transfer protocol.\n\n\nint UF_GetDefaultPacketSize()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nThe size of data packet.\n\n\n\n\n3.5. Generic Command API\n\u00b6\n\n\nThe commands defined in the Packet Protocol Manual can be classified into several categories according to the types of packet exchange. Generic Command API provides functions which encapsulate these categories. Like low-level Packet API, users need not to call these functions directly. Most commands have corresponding high-level API in the SDK.\n\n\n\n\nUF_Command: encapsulates the commands composed of one request packet and one response packet.\n\n\nUF_CommandEx: encapsulates the commands composed of one request packet and multiple response packets.\n\n\nUF_CommandSendData: encapsulates the commands which send additional data after a request packet.\n\n\nUF_CommandSendDataEx: encapsulates the commands which send additional data and have multiple response packets.\n\n\nUF_Cancel: cancels the previously issued command.\n\n\nUF_SetProtocol: sets the type of packet protocol.\n\n\nUF_GetProtocol: gets the type of packet protocol.\n\n\nUF_GetModuleID: gets the module ID.\n\n\nUF_SetGenericCommandTimeout: sets the timeout for generic commands.\n\n\nUF_SetInputCommandTimeout: sets the timeout for commands which require user inputs.\n\n\nUF_GetGenericCommandTimeout: gets the timeout for generic commands.\n\n\nUF_GetInputCommandTimeout: gets the timeout for commands which \n\n\nrequire user inputs.\n\n\nUF_SetNetworkDelay: sets the delay for the Network Packet Protocol.\n\n\nUF_GetNetworKDelay: gets the delay for the Network Packet Protocol.\n\n\n\n\n\n\nUF_Command\n\u00b6\n\n\nEncapsulates the commands composed of one request packet and one response packet. The majority of commands can be implemented using \nUF_Command.\n\n\nUF_RET_CODE UF_Command( BYTE command, UINT32* param, UINT32* size, BYTE* flag )\n\n\nParameters\n\n\ncommand\n\nCommand field of a packet. Refer to the Packet Protocol Manual for available commands.\n\nparam\n\nParam field of a packet. This parameter is used both for input and output.\n\nsize\n\nSize field of a packet. This parameter is used both for input and output.\n\nflag\n\nFlag field of a packet. This parameter is used both for input and output.\n\n\nReturn Values\n\nIf packets are transferred successfully, return UF_RET_SUCCESS. Otherwise, return the corresponding error code. UF_RET_SUCCESS only means that request packet is received successfully. To know if the operation succeeds, the flag field should be checked.\n\n\nExample\n\u00b6\n\n\n// To read Timeout(0x62) system parameter,\n\n\nUINT32\n \nparam\n \n=\n \n0\n;\n\n\nUINT32\n \nsize\n \n=\n \n0\n;\n\n\nBYTE\n \nflag\n \n=\n \n0x62\n;\n\n\nUINT32\n \ntimeout\n;\n\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_Command\n(\n \nUF_COM_SR\n,\n \n&\nparam\n,\n \n&\nsize\n,\n \n&\nflag\n \n);\n\n\n\nIf\n(\n \nresult\n \n!=\n \nUF_RET_SUCCESS\n \n)\n \n// communication error\n\n\n{\n\n    \nreturn\n \nresult\n;\n\n\n}\n\n\nIf\n(\n \nflag\n \n!=\n \nUF_PROTO_RET_SUCCESS\n \n)\n \n// protocol error\n\n\n{\n\n    \nreturn\n \nUF_GetErrorCode\n(\n \nresult\n \n);\n\n\n}\n\n\n// succeed\n\n\ntimeout\n \n=\n \nsize\n;\n\n\n\n\n\n\n\nUF_CommandEx\n\u00b6\n\n\nEncapsulates the commands composed of one request packet and multiple response packets. Command such as ES(Enroll) and IS(Identify) can have more than one response packet. To handle these cases, \nUF_CommandEx\n requires a message callback function, which should return TRUE when the received packet is the last one.\n\n\nUF_RET_CODE UF_CommandEx( BYTE command, UINT32* param, UINT32* size, BYTE* flag, BOOL (*msgCallback)(BYTE) )\n\n\nParameters\n\n\ncommand\n\nCommand field of a packet. Refer to the Packet Protocol Manual for available commands.\n\nparam\n\nParam field of a packet. This parameter is used both for input and output.\n\nsize\n\nSize field of a packet. This parameter is used both for input and output.\n\nflag\n\nFlag field of a packet. This parameter is used both for input and output.\n\nmsgCallback\n\nPointer to the callback function. This callback is called when a response packet is received. If the callback return TRUE, \nUF_CommandEx\n will return immediately. If the callback return FALSE, \nUF_CommandEx\n will wait for another response packet.\n\n\nReturn Values\n\nIf packets are transferred successfully, return UF_RET_SUCCESS. Otherwise, return the corresponding error code. UF_RET_SUCCESS only means that request packet is received successfully. To know if the operation succeeds, the flag field should be checked.\n\n\nExample\n\u00b6\n\n\n// UF_Identify() is implemented as follows;\n\n\n/**\n\n\n* Message callback for identification\n\n\n*/\n\n\nBOOL\n \nUF_IdentifyMsgCallback\n(\n \nBYTE\n \nerrCode\n \n)\n\n\n{\n\n    \nif\n(\n \nerrCode\n \n==\n \nUF_PROTO_RET_SCAN_SUCCESS\n \n)\n\n    \n{\n\n        \nif\n(\n \ns_IdentifyCallback\n \n)\n\n        \n{\n\n            \n(\n*\ns_IdentifyCallback\n)(\n \nerrCode\n \n);\n\n        \n}\n\n        \nreturn\n \nFALSE\n;\n\n    \n}\n\n    \nelse\n\n    \n{\n\n        \nreturn\n \nTRUE\n;\n\n    \n}\n\n\n}\n\n\n/**\n\n\n* Identify\n\n\n*/\n\n\nUF_RET_CODE\n \nUF_Identify\n(\n \nUINT32\n*\n \nuserID\n,\n \nBYTE\n*\n \nsubID\n \n)\n\n\n{\n\n    \nUINT32\n \nparam\n \n=\n \n0\n;\n\n    \nUINT32\n \nsize\n \n=\n \n0\n;\n\n    \nBYTE\n \nflag\n \n=\n \n0\n;\n\n\n    \nint\n \nresult\n \n=\n \nUF_CommandEx\n(\n \nUF_COM_IS\n,\n \n&\nparam\n,\n \n&\nsize\n,\n \n&\nflag\n,\n\n    \nUF_IdentifyMsgCallback\n \n);\n\n\n    \nif\n(\n \nresult\n \n!=\n \nUF_RET_SUCCESS\n \n)\n\n    \n{\n\n        \nreturn\n \nresult\n;\n\n    \n}\n\n    \nelse\n \nif\n(\n \nflag\n \n!=\n \nUF_PROTO_RET_SUCCESS\n \n)\n\n    \n{\n\n        \nreturn\n \nUF_GetErrorCode\n(\n \nflag\n \n);\n\n    \n}\n\n    \n*\nuserID\n \n=\n \nparam\n;\n\n    \n*\nsubID\n \n=\n \nsize\n;\n\n\n    \nreturn\n \nUF_RET_SUCCESS\n;\n\n\n}\n\n\n\n\n\n\n\nUF_CommandSendData\n\u00b6\n\n\nEncapsulates the commands which send additional data after a request packet. For example, GW(Write GPIO Configuration) command should send configuration data after the request packet.\n\n\nUF_RET_CODE UF_CommandSendData( BYTE command, UINT32* param, UINT32* size, BYTE* flag, BYTE* data, UINT32 dataSize )\n\n\nParameters\n\n\ncommand\n\nCommand field of a packet. Refer to the Packet Protocol Manual for available commands.\n\nparam\n\nParam field of a packet. This parameter is used both for input and output.\n\nsize\n\nSize field of a packet. This parameter is used both for input and output.\n\nflag\n\nFlag field of a packet. This parameter is used both for input and output.\n\ndata\n\nPointer to the data buffer to be sent.\n\ndataSize\n\nNumber of bytes to be sent.\n\n\nReturn Values\n\nIf packets are transferred successfully, return UF_RET_SUCCESS. Otherwise, return the corresponding error code. UF_RET_SUCCESS only means that request packet is received successfully. To know if the operation succeeds, the flag field should be checked.\n\n\n\n\nUF_CommandSendDataEx\n\u00b6\n\n\nEncapsulates the commands which send additional data and have multiple response packets. For example, ET(Enroll Template) command sends template data after request packet and can have multiple response packets.\n\n\nUF_RET_CODE UF_CommandSendDataEx( BYTE command, UINT32* param, UINT32* size, BYTE* flag, BYTE* data, UINT32 dataSize, BOOL (*msgCallback)(BYTE), BOOL waitUserInput )\n\n\nParameters\n\n\ncommand\n\nCommand field of a packet. Refer to the Packet Protocol Manual for available commands.\n\nparam\n\nParam field of a packet. This parameter is used both for input and output.\n\nsize\n\nSize field of a packet. This parameter is used both for input and output.\n\nflag\n\nFlag field of a packet. This parameter is used both for input and output.\n\ndata\n\nPointer to the data buffer to be sent.\n\ndataSize\n\nNumber of bytes to be sent.\n\nmsgCallback\n\nPointer to the callback function. This callback is called when a response packet is received. If the callback return TRUE, \nUF_CommandSendDataEx\n will return immediately. If the callback return FALSE, \nUF_CommandSendDataEx\n will wait for another response packet.\n\nwaitUserInput\n\nTRUE if the command needs user input. Otherwise, FALSE.\n\n\nReturn Values\n\nIf packets are transferred successfully, return UF_RET_SUCCESS. Otherwise, return the corresponding error code. UF_RET_SUCCESS only means that request packet is received successfully. To know if the operation succeeds, the flag field should be checked.\n\n\n\n\nUF_Cancel\n\u00b6\n\n\nCancels the command which is being processed by the module. When the module is executing a command which needs user input to proceed, the status of the module will be changed to UF_SYS_BUSY. If users want to execute another command before finishing the current one, they can explicitly cancel it by this function.\n\n\nUF_RET_CODE UF_Cancel( BOOL receivePacket )\n\n\nParameters\n\n\nreceivePacket\n\nIf TRUE, \nUF_Cancel\n waits until the response packet is received. If FALSE, \nUF_Cancel\n returns immediately after sending the request packet.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SetProtocol\n\u00b6\n\n\nSelects packet protocol. If the host connects to the single module through RS232 interface, use UF_SINGLE_PROTOCOL. If there are multiple modules in RS422/485 networks, use UF_NETWORK_PROTOCOL. The protocol should also be compatible with the Network Mode system parameter.\n\n\n\n\n\n\n\n\nNetwork Mode\n\n\n\n\nSupported Protocol\n\n\n\n\n\n\n\n\n\n\n\n\n13 byte Packet Protocol\n\n\n15 byte Network Packet Protocol\n\n\n\n\n\n\nSingle(0x30)\n\n\nO\n\n\nO\n\n\n\n\n\n\nNetwork (0x31/0x32)\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nvoid UF_SetProtocol( UF_PROTOCOL protocol, UINT32 moduleID )\n\n\nParameters\n\n\nprotocol\n\nUF_SINGLE_PROTOCOL for 13 byte packet protocol, UF_NETWORK_PROTOCOL\nfor 15 byte network packet protocol.\n\nmoduleID\n\nSpecifies the ID of the module. This parameter is applicable when the protocol is set to UF_NETWORK_PROTOCOL.\n\n\nReturn Values\n\nNone\n\n\n\n\nUF_GetProtocol\n\u00b6\n\n\nGets the selected protocol.\n\n\nUF_PROTOCOL UF_GetProtocol()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nUF_SINGLE_PROTOCOL or UF_NETWORK_PROTOCOL.\n\n\n\n\nUF_GetModuleID\n\u00b6\n\n\nGets the ID of the module.\n\n\nUINT32 UF_GetModuleID()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nID of the module.\n\n\n\n\nUF_SetGenericCommandTimeout\n\u00b6\n\n\nSets the timeout for generic commands. The default timeout is 2,000ms.\n\n\nvoid UF_SetGenericCommandTimeout( int timeout )\n\n\nParameters\n\n\ntimeout\n\nSpecifies the timeout period in milliseconds.\n\n\nReturn Values\n\nNone\n\n\n\n\nUF_SetInputCommandTimeout\n\u00b6\n\n\nSets the timeout for commands which need user input. The default timeout is 10,000ms.\n\n\nvoid UF_SetInputCommandTimeout( int timeout )\n\n\nParameters\n\n\ntimeout\n\nSpecifies the timeout period in milliseconds.\n\n\nReturn Values\n\nNone\n\n\n\n\nUF_GetGenericCommandTimeout\n\u00b6\n\n\nGets the timeout for generic commands.\n\n\nint UF_GetGenericCommandTimeout()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nTimeout for generic commands.\n\n\n\n\nUF_GetInputCommandTimeout\n\u00b6\n\n\nGets the timeout for commands which need user input.\n\n\nint UF_GetInputCommandTimeout()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nTimeout for commands which need user input.\n\n\n\n\nUF_SetNetworkDelay\n\u00b6\n\n\nIn half duplex mode, the same communication lines are shared for sending and receiving data. To prevent packet collisions on the shared line, there should be some delay between receiving and sending data. The default delay is set to 40ms. This value can be optimized for specific environments.\n\n\nvoid UF_SetNetworkDelay( int delay )\n\n\nParameters\n\n\ndelay\n\nSpecified the delay in milliseconds.\n\n\nReturn Values\n\nNone\n\n\n\n\nUF_GetNetworkDelay\n\u00b6\n\n\nGets the network delay.\n\n\nint UF_GetNetworkDelay()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nDelay in milliseconds.\n\n\n\n\n3.6. Module API\n\u00b6\n\n\nThese functions provide basic information about the module.\n\n\n\n\nUF_GetModuleInfo: gets the basic module information.\n\n\nUF_GetModuleString: gets a string describing the module.\n\n\nUF_SearchModule: searches a module and find out communication parameters.\n\n\nUF_SearchModuleID: searches an ID of a module.\n\n\nUF_SearchModuleBySocket: searches a module through socket interface.\n\n\nUF_SearchModuleIDEx: searches multiple models in a network.\n\n\nUF_CalibrateSensor: calibrates a sensor.\n\n\nUF_Upgrade: upgrades firmware.\n\n\nUF_Reset: resets the module.\n\n\nUF_Lock: locks the module.\n\n\nUF_Unlock: unlocks the module.\n\n\nUF_ChangePassword: changes the master password of a module.\n\n\nUF_PowerOff : Programmatically turns off a module (SFM4000 only).\n\n\n\n\n\n\nUF_GetModuleInfo\n\u00b6\n\n\nRetrieves the type, version and sensor information of the module.\n\n\nUF_RET_CODE UF_GetModuleInfo( UF_MODULE_TYPE* type, UF_MODULE_VERSION* version, UF_MODULE_SENSOR* sensorType )\n\n\nParameters\n\n\ntype\n\nAvailable types are as follows;\n\n\n\n\n\n\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUF_MODULE_3000\n\n\nSFM 3000 series modules\n\n\n\n\n\n\nUF_MODULE_3500\n\n\nSFM 3500 series modules\n\n\n\n\n\n\nUF_MODULE_4000\n\n\nSFM 4000 series modules\n\n\n\n\n\n\nUF_MODULE_5000\n\n\nSFM_5000 series modules\n\n\n\n\n\n\nUF_BIOENTRY_SMART\n\n\nBioEntry Smart\n\n\n\n\n\n\nUF_BIOENTRY_PASS\n\n\nBioEntry Pass\n\n\n\n\n\n\n\n\nversion\n\nVersion number of the module.\n\n\nsensorType\n\nSensor type of the module.\n\n\n\n\n\n\n\n\nValue\n\n\nSensor Type\n\n\n\n\n\n\n\n\n\n\nUF_SENSOR_FL\n\n\nAuthentec AF-S2\n\n\n\n\n\n\nUF_SENSOR_FC\n\n\nAtmel FingerChip\n\n\n\n\n\n\nUF_SENSOR_OP\n\n\nOptical Sensor I (OP2/OP3/OP4)\n\n\n\n\n\n\nUF_SENSOR_TC\n\n\nUPEK TouchChip (TC1/TC2/TC2S)\n\n\n\n\n\n\nUF_SENSOR_OC2\n\n\nOptical Sensor II (OC2/OD)\n\n\n\n\n\n\nUF_SENSOR_TS\n\n\nUPEK TouchStrip (TS4)\n\n\n\n\n\n\nUF_SENSOR_OL\n\n\nOptical Sensor III (OL)\n\n\n\n\n\n\nUF_SENSOR_OH\n\n\nOptical Sensor IV (OH)\n\n\n\n\n\n\n\n\nReturn Values\n  \n\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetModuleString\n\u00b6\n\n\nRetrieves a string that describes the module information. This function should be called after \nUF_GetModuleInfo.\n\n\nchar* UF_GetModuleString( UF_MODULE_TYPE type, UF_MODULE_VERSION version, UF_MODULE_SENSOR sensorType )\n\n\nParameters\n\n\ntype\n\nSpecifies the type of the module.\n\nversion\n\nSpecifies the version number of the module.\n\nsensorType\n\nSpecifies the sensor type of the module.\n\n\nReturn Values\n\nNull-terminated string that describes the module information. This pointer is a static data in the SDK. So, it should not be shared or freed by applications.\n\n\n\n\nUF_SearchModule\n\u00b6\n\n\nSearch a module connected to the specified serial port. \nUF_SearchModule\n tries all combinations of communication parameters. If it finds any module on the serial port, it returns the communication parameters and its module ID.\n\n\nUF_RET_CODE UF_SearchModule( const char* port, int* baudrate, BOOL* asciiMode, UF_PROTOCOL* protocol, UINT32* moduleID, void (*callback)( const char* comPort, int baudrate ) )\n\n\nParameters\n\n\nport\n\nSerial port.\n\nbaudrate\n\nPointer to the baud rate to be returned.\n\nasciiMode\n \n\nPointer to the packet translation mode to be returned.\n\nprotocol\n\nPointer to the protocol type to be returned.\n\nmoduleID\n\nPointer to the module ID to be returned.\n\ncallback\n\nPointer to the callback function. The callback function can be used for displaying the progress of the search. This parameter can be NULL.\n\n\nReturn Values\n\nIf it finds a module, return UF_RET_SUCCESS. If the search fails, return UF_ERR_NOT_FOUND. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SearchModuleID\n\u00b6\n\n\nUntil firmware V1.3, SFM modules respond both standard and network packets regardless of Network Mode system parameter. However, since firmware V1.4, the modules only respond to 15 byte network packets if Network Mode system parameter is not Single(0x30). So, if users don\u2019t know ID of the module, they cannot communicate with it in network environments. \nUF_SerachModuleID\n can be used to retrieve the ID of the module in these cases. Refer to ID command section in the Packet Protocol Manual for details.\n\n\nUF_RET_CODE UF_SearchModuleID( UINT32* moduleID )\n\n\nParameters\n\n\nmoduleID\n\nPointer to the module ID to be returned.\n\n\nReturn Values\n\nIf it finds a module, return UF_RET_SUCCESS. If the search fails, return UF_ERR_NOT_FOUND. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SearchModuleBySocket\n\u00b6\n\n\nSearch a module connected to the specified IP address. If it finds any module, it will return the communication parameters and the module ID.\n\n\nUF_RET_CODE UF_SearchModuleBySocket( const char* inetAddr, int tcpPort, BOOL* asciiMode, UF_PROTOCOL* protocol, UINT32* moduleID )\n\n\nParameters\n\n\ninetAddr\n\nIP address.\n\ntcpPort\n\nTCP port.\n\nasciiMode\n\nPointer to the packet translation mode to be returned.\n\nprotocol\n\nPointer to the protocol type to be returned.\n\nmoduleID\n\nPointer to the module ID to be returned.\n\n\nReturn Values\n\nIf it finds a module, return UF_RET_SUCCESS. If the search fails, return UF_ERR_NOT_FOUND. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SearchModuleIDEx\n\u00b6\n\n\nUF_SearchModuleID\n is used for searching a module. To search multiple modules in a RS422/485 network, \nUF_SearchModuleIDEx\n should be used instead. By calling this function repetitively, users can search all the modules connected to a network.\n\n\nUF_RET_CODE UF_SearchModuleIDEx( unsigned short* foundModuleID, int numOfFoundID, unsigned short* moduleID, int* numOfID )\n\n\nParameters\n\n\nfoundModuleID\n\nPointer to the array of module IDs, which are already found. When the ID of a module is in this array, the module will ignore the search command.\n\nnumOfFoundID\n\nNumber of module IDs, which are already found.\n\nmoduleID\n\nPointer to the array of module IDs, which will be filled with newly found IDs.\n\nnumOfID\n\nPointer to the number of module IDs to be returned.\n\n\nReturn Values\n\nIf it finds one or more modules, return UF_RET_SUCCESS. If the search fails, return UF_ERR_NOT_FOUND. Otherwise, return the corresponding error code.\n\n\nExample\n\u00b6\n\n\nint\n \nnumOfModuleID\n;\n\n\nunsigned\n \nshort\n \nmoduleID\n[\n32\n];\n\n\n\nint\n \nnumOfFoundID\n \n=\n \n0\n;\n\n\nBOOL\n \nfoundNewID\n \n=\n \nFALSE\n;\n\n\n\ndo\n \n{\n\n    \nresult\n \n=\n \nUF_SearchModuleIDEx\n(\n \nmoduleID\n,\n \nnumOfFoundID\n,\n \nmoduleID\n \n+\n\n\nnumOfFoundID\n,\n \n&\nnumOfModuleID\n \n);\n\n\n    \nif\n(\n \nresult\n \n==\n \nUF_RET_SUCCESS\n \n)\n\n    \n{\n\n        \nfoundNewID\n \n=\n \nTRUE\n;\n\n\n        \nnumOfFoundID\n \n+=\n \nnumOfModuleID\n;\n\n    \n}\n\n    \nelse\n\n    \n{\n\n        \nfoundNewID\n \n=\n \nFALSE\n;\n\n    \n}\n\n\n}\n \nwhile\n(\n \nfoundNewID\n \n&&\n \nnumOfFoundID\n \n<\n \n32\n \n);\n\n\n\n\n\n\n\nUF_CalibrateSensor\n\u00b6\n\n\nCalibrates fingerprint sensor. This function is supported for AuthenTec\u2019s FingerLoc AF-S2 and UPEK\u2019s TouchChip. After using the \nUF_CalibrateSensor\n, \nUF_Save\n should be called to save calibration data into flash memory.\n\n\nUF_RET_CODE UF_CalibrateSensor()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_Upgrade\n\u00b6\n\n\nUpgrades the firmware of the module. Users should not turn off the module when upgrade is in progress.\n\n\nUF_RET_CODE UF_Upgrade( const char* firmwareFilename, int data++PacketSize++)\n\n\nParameters\n\n\nfirmwareFilename\n\nNull-terminated string that specifies the firmware file name.\n\ndataPacketSize\n\nThe packet size of firmware data. If it is 16384, the firmware is divided into 16384 byte packets before transferring to the module.\n\n\nReturn Values\n\nIf upgrade succeeds, return UF_RET_SUCCESS. Otherwise, return the\ncorresponding error code.\n\n\n\n\nUF_Reset\n\u00b6\n\n\nResets the module.\n\n\nUF_RET_CODE UF_Reset()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nUF_RET_SUCCESS\n\n\n\n\nUF_Lock\n\u00b6\n\n\nLocks the module. When the module is locked, it returns UF_ERR_LOCKED to functions other than \nUF_Unlock.\n\n\nUF_RET_CODE UF_Lock()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the module is locked successfully, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_Unlock\n\u00b6\n\n\nUnlocks a locked module.\n\n\nUF_RET_CODE UF_Unlock( const unsigned char* password )\n\n\nParameters\n\n\npassword\n\n16 byte master password. The default password is a string of 16 NULL\ncharacters.\n\n\nReturn Values\n\nIf the password is wrong, return UF_ERR_NOT_MATCH. If it is successful, return UF_RET_SUCCESS.\n\n\n\n\nUF_ChangePassword\n\u00b6\n\n\nChanges the master password.\n\n\nUF_RET_CODE UF_ChangePassword( const unsigned char* newPassword, const unsigned char* oldPassword )\n\n\nParameters\n\n\nnewPassword\n\n16 byte new password.\n\noldPassword\n\n16 byte old password.\n\n\nReturn Values\n\nIf the old password is wrong, return UF_ERR_NOT_MATCH. If it is successful, return UF_RET_SUCCESS.\n\n\n\n\nUF_PowerOff\n\u00b6\n\n\nProgrammatically turns off a module. This function is only available with SFM4000 series.\n\n\nUF_RET_CODE UF_PowerOff()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nThe module is powered off successfully, return UF_RET_SUCCESS.\n\n\n\n\n3.7. System Parameters API\n\u00b6\n\n\nFunctions for managing system parameters. Available system parameters are defined in UF_SysParameter.h. See the Packet Protocol Manual for available values for each parameter.\nThis API also provides functions for saving and loading system configurations.\n\n\n\n\nUF_InitSysParameter: clears the system parameter cache.\n\n\nUF_GetSysParameter: gets the value of a system parameter.\n\n\nUF_SetSysParameter: sets the value of a system parameter.\n\n\nUF_GetMultiSysParameter: gets the values of multiple system parameters.\n\n\nUF_SetMultiSysParameter: sets the values of multiple system parameters.\n\n\nUF_Save: saves system parameters into the flash memory.\n\n\nUF_SaveConfiguration: saves system configurations into the specified file.\n\n\nUF_ReadConfigurationHeader: reads configuration information stored in a file.\n\n\nUF_LoadConfiguration: loads system configurations from the specified file.\n\n\nUF_MakeParameterConfiguration: makes parameter configuration data to be saved.\n\n\n\n\n\n\nUF_InitSysParameter\n\u00b6\n\n\nTo prevent redundant communication, the SFM SDK caches the system parameters previously read or written. \nUF_InitSysParameter\n clears this cache. It is called in \nUF_Reconnect\n.\n\n\nvoid UF_InitSysParameter()\n  \n\n\nParameters\n\nNone\n\n\nReturn Values\n\nNone\n\n\n\n\nUF_GetSysParameter\n\u00b6\n\n\nReads the value of a system parameter.\n\n\nUF_RET_CODE UF_GetSysParameter( UF_SYS_PARAM parameter, UINT32* value )\n\n\nParameters\n\n\nparameter\n\nSystem parameter to be read.\n\nvalue\n\nPointer to the value of the specified system parameter to be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. If there is no such parameter, return UF_ERR_NOT_FOUND. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SetSysParameter\n\u00b6\n\n\nWrites the value of a system parameter. The parameter value is changed in memory only. To make the change permanent, \nUF_Save\n should be called after this function. For BioEntry Smart and Pass, users cannot change the UF_SYS_MODULE_ID system parameter.\n\n\nUF_RET_CODE UF_SetSysParameter( UF_SYS_PARAM parameter, UINT32 value )\n\n\nParameters\n\n\nparameter\n\nSystem parameter to be written.\n\nvalue\n\nValue of the system parameter. Refer to the Packet Protocol Manual for available values for each parameter.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. If there is no such parameter, return UF_ERR_NOT_FOUND. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetMultiSysParameter\n\u00b6\n\n\nReads the values of multiple system parameters.\n\n\nUF_RET_CODE UF_GetMultiSysParameter( int parameterCount, UF_SYS_PARAM* parameters, UINT32* values )\n\n\nParameters\n\n\nparameterCount\n\nNumber of system parameters to be read.\n\nparameters\n\nArray of system parameters to be read.\n\nvalues\n\nArray of the values of the specified system parameters to be read.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\nExample\n\u00b6\n\n\n// To read 3 system parameters, UF_SYS_TIMEOUT, UF_SYS_ENROLL_MODE,\n\n\n// UF_SYS_SECURITY_LEVEL,\n\n\n\nUF_SYS_PARAM\n \nparameters\n[\n3\n]\n \n=\n \n{\n \nUF_SYS_TIMEOUT\n,\n \nUF_SYS_ENROLL_MODE\n,\n \nUF_SYS_SECURITY_LEVEL\n \n};\n\n\nUINT32\n \nvalues\n[\n3\n];\n\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_GetMultiSysParameter\n(\n \n3\n,\n \nparameters\n,\n \nvalues\n \n);\n\n\n\n\n\n\n\nUF_SetMultiSysParameter\n\u00b6\n\n\nWrites the values of multiple system parameters. The parameter value is changed in memory only. To make the change permanent, \nUF_Save\n should be called.\n\n\nUF_RET_CODE UF_SetMultiSysParameter( int parameterCount, UF_SYS_PARAM* parameters, UINT32* values )\n\n\nParameters\n\n\nparameterCount\n\nNumber of system parameters to be written.\n\nparameters\n\nArray of system parameters to be written.\n\nvalues\n\nArray of the values of the specified system parameters to be written.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_Save\n\u00b6\n\n\nSaves the system parameters into the flash memory.\n\n\nUF_RET_CODE UF_Save()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SaveConfiguration\n\u00b6\n\n\nSaves system configurations into the specified file. The configuration file consists of a file header and multiple configuration components. There are 5 configuration components to be saved.\n\ntypedef\n \nenum\n \n{\n\n    \nUF_CONFIG_PARAMETERS\n  \n=\n \n0x01\n,\n \n// System parameters\n\n    \nUF_CONFIG_GPIO\n        \n=\n \n0x02\n,\n \n// GPIO configurations for\n\n                                  \n// SFM3000\n\n    \nUF_CONFIG_IO\n          \n=\n \n0x04\n,\n \n// IO configurations for\n\n                                  \n// SFM3500\n\n    \nUF_CONFIG_WIEGAND\n     \n=\n \n0x08\n,\n \n// Extended Wiegand\n\n    \nUF_CONFIG_USER_MEMORY\n \n=\n \n0x10\n,\n \n// User memory\n\n\n}\n \nUF_CONFIG_TYPE\n;\n\n\n\n\nUF_RET_CODE UF_SaveConfiguration( const char* filename, const char* description, int numOfComponent, UFConfigComponentHeader* componentHeader, void** componentData )\n\n\nParameters\n\n\nfilename\n\nNull-terminated string that specifies the file name.\n\ndescription\n\nNull-terminated string describing the configuration file. The maximum length of description is 256 bytes.\n\nnumOfComponent\n\nNumber of components to be saved.\n\ncomponentHeader\n\nPointer to an array of UFConfigComponentHeader structures to be saved.\n\n\ntypedef\n \nstruct\n \n{\n\n    \nUF_CONFIG_TYPE\n \ntype\n;\n\n    \nUINT32\n \ndataSize\n;\n\n    \nUINT32\n \nchecksum\n;\n\n\n}\n \nUFConfigComponentHeader\n;\n\n\n\n\n\ncomponentData\n\nPointer to an array of component data to be saved.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\nExample\n\u00b6\n\n\n// To save system parameters and IO configuration\n\n\n// of a SFM 3500 module into \u201cSFM3500.cfg\u201d file,\n\n\nUF_ConfigComponentHeader\n \nconfigHeader\n[\n2\n];\n\n\nvoid\n*\n \nconfigData\n[\n2\n];\n\n\n\n// Make system parameter component\n\n\nUFConfigParameter\n*\n \nparameter\n \n=\n \n(\nUFConfigParameter\n*\n)\nmalloc\n(\n \nsizeof\n(\nint\n)\n \n+\n\n    \nNUM_OF_PARAMETER\n \n*\n \nsizeof\n(\nUFConfigParameterItem\n)\n \n);\n\n\nUF_MakeParameterConfiguration\n(\n \n&\nconfigHeader\n[\n0\n],(\nBYTE\n*\n)\nparameter\n \n);\n\n\nconfigData\n[\n0\n]\n \n=\n \n(\nvoid\n*\n)\nparameter\n;\n\n\n\n// Make IO component\n\n\nUFConfigIO\n*\n \nio\n \n=\n \n(\nUFConfigIO\n*\n)\nmalloc\n(\n \nsizeof\n(\nUFConfigIO\n)\n \n+\n\n    \nsizeof\n(\nUFConfigOutputItem\n)\n \n*\n \n(\nUF_MAX_OUTPUT_EVENT\n \n-\n \n1\n)\n \n);\n\n\nUF_MakeIOConfiguration\n(\n \n&\nconfigHeader\n[\n1\n],\n \n(\nBYTE\n*\n)\nio\n \n);\n\n\nconfigData\n[\n1\n]\n \n=\n \n(\nvoid\n*\n)\nio\n;\n\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_SaveConfiguration\n(\n \n\u201c\nSFM3500\n.\ncfg\n\u201d\n,\n \n\u201c\nConfiguration\n\n    \nfile\n \nfor\n \nSFM3500\n\u201d\n,\n \n2\n,\n \nconfigHeader\n,\n \nconfigData\n \n);\n\n\n\n\n\n\n\nUF_ReadConfigurationHeader\n\u00b6\n\n\nReads the header information from a file which is saved by \nUF_SaveConfiguration.\n\n\nUF_RET_CODE UF_ReadConfigurationHeader( const char* filename, UFConfigFileHeader* header )\n\n\nParameters\n\n\nfilename\n\nNull-terminated string that specifies the file name.\n\nheader\n\nPointer to the UFConfigFileHeader to be read.\n\n\ntypedef\n \nstruct\n \n{\n\n    \nUINT32\n \nmagicNo\n;\n \n// if valid, UF_VALID_CONFIG_FILE\n\n    \nUINT32\n \nnumOfComponent\n;\n\n    \nchar\n \ndescription\n[\n256\n];\n\n\n}\n \nUFConfigFileHeader\n;\n\n\n\n\n\nReturn Values\n\nIf the header is read successfully, return UF_RET_SUCCESS. If the file is of invalid type, return UF_ERR_INVALID_FILE. Otherwise, return the corresponding error code.\n\n\n\n\nUF_LoadConfiguration\n\u00b6\n\n\nLoads system configurations into a module from the specified file. To make permanent the configuration changes, \nUF_Save\n should be called after \nUF_LoadConfiguration\n.\n\n\nUF_RET_CODE UF_LoadConfiguration( const char* filename, int numOfComponent, UF_CONFIG_TYPE* type )\n\n\nParameters\n\n\nfilename\n\nNull-terminated string that specifies the file name.\n\nnumOfComponent\n\nNumber of configuration components to be loaded.\n\ntype\n\nArray of component types to be loaded.\n\n\nReturn Values\n\nIf the configurations are loaded successfully, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\nExample\n\u00b6\n\n\n// To load system parameters and IO configuration\n\n\n// of a SFM 3500 module from \u201cSFM3500.cfg\u201d file,\n\n\nUF_CONFIG_TYPE\n \nconfigType\n[\n2\n]\n \n=\n \n{\n \nUF_CONFIG_PARAMETERS\n,\n \nUF_CONFIG_IO\n \n};\n\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_LoadConfiguration\n(\n \n\u201c\nSFM3500\n.\ncfg\n\u201d\n,\n \n2\n,\n \nconfigType\n \n);\n\n\n\n\n\n\n\nUF_MakeParameterConfiguration\n\u00b6\n\n\nMake a UFConfigComponentHeader and a UFConfigParameter structure to be used in \nUF_SaveConfiguration\n.\n\n\nUF_RET_CODE   \n UF_MakeParameterConfiguration( UFConfigComponentHeader* configHeader, BYTE* configData )\n  \n\n\nParameters\n\n\nconfigHeader\n\nPointer to the UFConfigComponentHeader structure.\n\nconfigData\n\nPointer to the UFConfigParameter structure. It should be preallocated large enough to store all the parameter information.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\n3.8. Template Management API\n\u00b6\n\n\nThese functions provide template management interfaces such as read, delete and fix. Users can also manage user ids and administration levels associated with templates using these APIs.\n\n\n\n\nUF_GetNumOfTemplate: gets the number of template stored in a module.\n\n\nUF_GetMaxNumOfTemplate: gets the template capacity of a module.\n\n\nUF_GetAllUserInfo: gets all the template and user information stored in a module.\n\n\nUF_GetAllUserInfoEx: gets all the template and user information stored in a BioEntry reader.\n\n\nUF_SortUserInfo: sorts UFUserInfo structures.\n\n\nUF_SetUserInfoCallback: sets the callback function for getting user information.\n\n\nUF_SetAdminLevel: sets the administration level of a user.\n\n\nUF_GetAdminLevel: gets the administration level of a user.\n\n\nUF_ClearAllAdminLevel: clears all the administration levels of users.\n\n\nUF_SaveDB: saves templates and user information into the specified file.\n\n\nUF_LoadDB: loads templates and user information from the specified file.\n\n\nUF_CheckTemplate: checks if the specified ID has templates.\n\n\nUF_ReadTemplate: reads the templates of the specified user ID.\n\n\nUF_ReadOneTemplate: reads one template of the specified user ID.\n\n\nUF_SetScanCallback: sets the callback function for scanning fingerprints.\n\n\nUF_ScanTemplate: scans a fingerprint on the sensor and retrieves the fingerprint template.\n\n\nUF_FixProvisionalTemplate: saves the provisional templates into the flash memory.\n\n\nUF_SetSecurityLevel: sets the security level of a user.\n\n\nUF_GetSecurityLevel: gets the security level of a user.\n\n\nUF_SetAuthType: sets the authentication type of a user.\n\n\nUF_GetAuthType: gets the authentication type of a user.\n\n\nUF_GetUserIDByAuthType: gets the user IDs with specified authentication type.\n\n\nUF_ResetAllAuthType: resets the authentication types of all users.\n\n\nUF_SetEntranceLimit: sets the entrance limit of a user.\n\n\nUF_GetEntranceLimit: gets the entrance limit of a user.\n\n\nUF_ClearAllEntranceLimit: clears the entrance limits of all users.\n\n\n\n\n\n\nUF_GetNumOfTemplate\n\u00b6\n\n\nGets the number of templates stored in the module.\n\n\nUF_RET_CODE UF_GetNumOfTemplate( UINT32* numOfTemplate )\n\n\nParameters\n\n\nnumOfTemplate\n\nPointer to the number of templates to be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetMaxNumOfTemplate\n\u00b6\n\n\nGets the template capacity of the module.\n\n\nUF_RET_CODE UF_GetMaxNumOfTemplate( UINT32* maxNumOfTemplate )\n\n\nParameters\n\n\nmaxNumOfTemplate\n\nPointer to the template capacity to be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetAllUserInfo\n\u00b6\n\n\nRetrieves all the user and template information stored in the module.\n\n\nUF_RET_CODE UF_GetAllUserInfo( UFUserInfo* userInfo, UINT32* numOfUser, UINT32* numOfTemplate )\n\n\nParameters\n\n\nuserInfo\n\nArray of UFUserInfo structures, which will store all the information. This pointer should be preallocated large enough to store all the information. UFUserInfo structure is defined as follows;\n\n\ntypedef\n \nstruct\n \n{\n\n    \nUINT32\n \nuserID\n;\n\n    \nBYTE\n \nnumOfTemplate\n;\n\n    \nBYTE\n \nadminLevel\n;\n \n// See UF_SetAdminLevel\n\n    \nBYTE\n \nsecurityLevel\n;\n \n// See UF_SetSecurityLevel\n\n    \nBYTE\n \nreserved\n;\n\n\n}\n \nUFUserInfo\n;\n\n\n\n\n\nnumOfUser\n\nPointer to the number of users to be returned.\n\nnumOfTemplate\n\nPointer to the number of templates to be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\nExample\n\u00b6\n\n\nUINT32\n \nmaxUser\n;\n\n\nUINT32\n \nnumOfUser\n,\n \nnumOfTemplate\n;\n\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_GetSysParameter\n(\n \nUF_SYS_ENROLLED_FINGER\n,\n \n&\nmaxUser\n \n);\n\n\n\nUFUserInfo\n*\n \nuserInfo\n \n=\n \n(\nUFUserInfo\n*\n)\nmalloc\n(\n \nmaxUser\n \n*\n \nsizeof\n(\nUFUserInfo\n)\n \n);\n\n\n\nresult\n \n=\n \nUF_GetAllUserInfo\n(\n \nuserInfo\n,\n \n&\nnumOfUser\n,\n \n&\nnumOfTemplate\n \n);\n\n\n\n\n\n\n\nUF_GetAllUserInfoEx\n\u00b6\n\n\nRetrieves all the user and template information stored in the BioEntry reader.\n\n\nUF_RET_CODE UF_GetAllUserInfoEx( UFUserInfoEx* userInfo, UINT32* numOfUser, UINT32* numOfTemplate )\n\n\nParameters\n\n\nuserInfo\n\nArray of UFUserInfoEx structures, which will store all the information. This pointer should be preallocated large enough to store all the information. UFUserInfoEx structure is defined as follows;\n\n\ntypedef\n \nstruct\n \n{\n\n    \nUINT32\n \nuserID\n;\n\n    \nUINT32\n \nchecksum\n[\n10\n];\n \n// checksum of each template data\n\n    \nBYTE\n \nnumOfTemplate\n;\n\n    \nBYTE\n \nadminLevel\n;\n\n    \nBYTE\n \nduress\n[\n10\n];\n\n    \nBYTE\n \nsecurityLevel\n;\n\n\n}\n \nUFUserInfoEx\n;\n\n\n\n\n\nnumOfUser\n\nPointer to the number of users to be returned.\n\nnumOfTemplate\n\nPointer to the number of templates to be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SortUserInfo\n\u00b6\n\n\nSorts an UFUserInfo array in ascending order of user ID.\n\n\nvoid UF_SortUserInfo( UFUserInfo* userInfo, int numOfUser )\n\n\nParameters\n\n\nuserInfo\n\nArray of UFUserInfo structures.\n\nnumOfUser\n\nNumber of UFUserInfo.\n\n\nReturn Values\n\nNone\n\n\n\n\nUF_SetUserInfoCallback\n\u00b6\n\n\nSets the callback function for getting user information. It is also called when enrolling templates in \nUF_LoadDB\n and reading templates in \n\nUF_SaveDB\n.\n\n\nvoid UF_SetUserInfoCallback( void (*callback)( int index, int numOfTemplate ) )\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.\n\nReturn Values\n\nNone\n\n\nExample\n\u00b6\n\n\nSee CMainFrame::UserInfoCallback in UniFingerUI source codes.\n\n\n\n\nUF_SetAdminLevel\n\u00b6\n\n\nSets the administration level of a user. See \nUF_EnrollAfterVerification\n and \nUF_DeleteAllAfterVerificatoin\n for usage of administration level.\n\n\nUF_RET_CODE UF_SetAdminLevel( UINT32 userID, UF_ADMIN_LEVEL adminLevel )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\nadminLevel\n\nSpecifies the administration level of the user.\n\n\n\n\n\n\n\n\nValue\n\n\nNote\n\n\n\n\n\n\n\n\n\n\nUF_ADMIN_NONE\n\n\n\n\n\n\n\n\nUF_ADMIN_ENROLL\n\n\nCan enroll users.\n\n\n\n\n\n\nUF_ADMIN_DELETE\n\n\nCan delete users.\n\n\n\n\n\n\nUF_ADMIN_ALL\n\n\nCan enroll and delete users.\n\n\n\n\n\n\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetAdminLevel\n\u00b6\n\n\nGets the administration level of a user.\n\n\nUF_RET_CODE UF_GetAdminLevel( UINT32 userID, UF_ADMIN_LEVEL* adminLevel )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\nadminLevel\n\nPointer to the administration level of the user to be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_ClearAllAdminLevel\n\u00b6\n\n\nResets administration levels of all users to UF_ADMIN_NONE.\n\n\nUF_RET_CODE UF_ClearAllAdminLevel()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SaveDB\n\u00b6\n\n\nSaves all the templates and user information stored in a module into the specified file.\n\n\nUF_RET_CODE UF_SaveDB( const char* fileName )\n\n\nParameters\n\n\nfileName\n\nNull-terminated string that specifies the file name.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_LoadDB\n\u00b6\n\n\nLoads templates and user information from the specified file. All the templates previously stored in the module will be erased before loading the DB.\n\n\nUF_RET_CODE UF_LoadDB( const char* fileName )\n\n\nParameters\n\n\nfileName\n\nNull-terminated string that specifies the file name.\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_CheckTemplate\n\u00b6\n\n\nChecks if the specified user ID has enrolled templates.\n\n\nUF_RET_CODE UF_CheckTemplate( UINT32 userID, UINT32* numOfTemplate )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\nnumOfTemplate\n\nPointer to the number of templates of the user ID to be returned.\n\n\nReturn Values\n\nIf there are templates of the user ID, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_ReadTemplate\n\u00b6\n\n\nReads  the templates of the specified user ID.\n\n\nUF_RET_CODE UF_ReadTemplate( UINT32 userID, UINT32* numOfTemplate, BYTE* templateData )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\nnumOfTemplate\n\nPointer to the number of templates of the user ID to be returned.\n\ntemplateData\n\nPointer to the template data to be returned. This pointer should be\npreallocated large enough to store all the template data.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_ReadOneTemplate\n\u00b6\n\n\nReads one template of the specified user ID.\n\n\nUF_RET_CODE UF_ReadOneTemplate( UINT32 userID, int subID, BYTE*templateData )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\nsubID\n\nSub index of the template. It is between 0 and 9.\n\ntemplateData\n\nPointer to the template data to be returned. This pointer should be\npreallocated large enough to store all the template data.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SetScanCallback\n\u00b6\n\n\nSets the callback function of scanning fingerprints. This callback is called when SCAN_SUCCESS message is received.\n\n\nvoid UF_SetScanCallback( void (*callback)( BYTE ) )\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.\n\n\nReturn Values\n\nNone\n\n\n\n\nUF_ScanTemplate\n\u00b6\n\n\nScans a fingerprint on the sensor and receives the template of it.\n\n\nUF_RET_CODE UF_ScanTemplate( BYTE* templateData, UINT32* templateSize, UINT32* imageQuality )\n\n\nParameters\n\n\ntemplateData\n\nPointer to the template data to be returned.\n\ntemplateSize\n\nPointer to the template size to be returned.\n\nimageQuality\n\nPointer to the image quality score to be returned. The score shows the quality of scanned fingerprint and is in the range of 0 ~ 100.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_FixProvisionalTemplate\n\u00b6\n\n\nUF_SYS_PROVISIONAL_ENROLL determines if enrolled templates are saved\npermanently into flash memory or temporarily into DRAM. With provisional enroll, enrolled templates on DRAM will be erased if the module is turned off. \nUF_FixProvisionalTemplate\n saves the provisional templates into the flash memory.\n\n\nUF_RET_CODE UF_FixProvisionalTemplate()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SetSecurityLevel\n\u00b6\n\n\nSince V1.6 firmware, the security level can be assigned per user basis for 1:1 matching. 1:N matching \u2013 identification \u2013 is not affected by this setting.\n\n\nUF_RET_CODE UF_SetSecurityLevel( UINT32 userID, UF_USER_SECURITY_LEVEL securityLevel )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\nsecurityLevel\n\nSpecifies the security level of the user.\n\n\n\n\n\n\n\n\nValue\n\n\nNote\n\n\n\n\n\n\n\n\n\n\nUF_USER_SECURITY_DEFAULT\n\n\nSame as defined by Security Level\n\n\n\n\n\n\n\n\nsystem parameter\n\n\n\n\n\n\nUF_USER_SECURITY_1_TO_1000\n\n\n\n\n\n\n\n\n\u2026\n\n\n\n\n\n\n\n\nUF_USER_SECURITY_1_TO_100000000\n\n\n\n\n\n\n\n\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetSecurityLevel\n\u00b6\n\n\nGets the security level of a user.\n\n\nUF_RET_CODE UF_GetSecurityLevel( UINT32 userID, UF_SECURITY_LEVEL* securityLevel )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\nsecurityLevel\n\nPointer to the security level of the user to be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SetAuthType\n\u00b6\n\n\nSets the authentication type of a user. UF_AUTH_BYPASS can be used for 1:1 matching, when it is necessary to allow access without matching fingerprints. UF_AUTH_REJECT can be used for disabling some IDs temporarily. The default authentication mode is UF_AUTH_FINGERPRINT.\n\n\nUF_RET_CODE UF_SetAuthType( UINT32 userID, UF_AUTH_TYPE authType )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\nauthType\n\nSpecifies the authentication type of the user.\n\n\n\n\n\n\n\n\nValue\n\n\nNote\n\n\n\n\n\n\n\n\n\n\nUF_AUTH_FINGERPRINT\n\n\nFingerprint authentication.\n\n\n\n\n\n\nUF_AUTH_BYPASS\n\n\nAuthentication will succeed without matching fingerprints.\n\n\n\n\n\n\nUF_AUTH_REJECT\n\n\nAuthentication will always fail.\n\n\n\n\n\n\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetAuthType\n\u00b6\n\n\nGets the authentication type of a user.\n\n\nUF_RET_CODE UF_GetAuthType( UINT32 userID, UF_AUTH_TYPE* authType )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\nauthType\n\nPointer to the authentication type of the user to be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetUserIDByAuthType\n\u00b6\n\n\nReceive user IDs with the specified authentication type.\n\n\nUF_RET_CODE UF_GetUserIDByAuthType( UF_AUTH_TYPE authType, int* numOfID, UINT32* userID )\n\n\nParameters\n\n\nauthType\n\nAuthentication type.\n\nnumOfID\n\nPointer to the number of user IDs to be returned.\n\nuserID\n\nArray of user IDs which have the specified authentication type.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_ResetAllAuthType\n\u00b6\n\n\nResets the authentication types of all users to UF_AUTH_FINGERPRINT.\n\n\nUF_RET_CODE UF_ResetAllAuthType()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SetEntranceLimit\n\u00b6\n\n\nSpecifies how many times the user is permitted to access per day. The available options are between 0 and 7. The default value is 0, which means that there is no limit. If the user tries to authenticate after the limit is reached, UF_ERR_EXCEED_ENTRANCE_LIMIT error will be returned.\n\n\nUF_RET_CODE UF_SetEntranceLimit( UINT32 userID, int entranceLimit )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\nentranceLimit\n\nEntrance limit between 0 and 7.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetEntranceLimit\n\u00b6\n\n\nGets the entrance limit of a user.\n\n\nUF_RET_CODE UF_GetEntranceLimit( UINT32 userID, int* entranceLimit, int* entranceCount )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\nentranceLimit\n\nPointer to the entrance limit of the user.\n\nentranceCount\n\nPointer to the number of entrance for today. This count is reset to 0 at midnight.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_ClearAllEntranceLimit\n\u00b6\n\n\nResets the entrance limits of of all users to 0 \u2013 infinite.\n\n\nUF_RET_CODE UF_ClearAllEntranceLimit()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\n3.9. Image Manipulation API\n\u00b6\n\n\nUFImage is a data structure for exchanging image data between the host and the module. It consists of 28 byte header and raw image data.\n\ntypedef\n \nstruct\n \n{\n\n    \nint\n \nwidth\n;\n \n// width of the fingerprint image\n\n    \nint\n \nheight\n;\n \n// height of the fingerprint image\n\n    \nint\n \ncompressed\n;\n \n// compression status \u2013 currently not used\n\n    \nint\n \nencrypted\n;\n \n// encryption status \u2013 currently not used\n\n    \nint\n \nformat\n;\n \n// 0- gray, 1- binary, 2- 4bit gray\n\n    \nint\n \nimgLen\n;\n \n// width * height\n\n    \nint\n \ntemplateLen\n;\n \n// size of fingerprint template \u2013 currently not used\n\n    \nBYTE\n \nbuffer\n[\n1\n];\n// pointer to the raw pixel data\n\n\n}\n \nUFImage\n;\n\n\n\n- UF_ConvertToBitmap: converts a UFImage structure into HBITMAP.\n- UF_SaveImage: saves a UFImage structure into BMP file.\n- UF_LoadImage: loads a BMP file and convert it into a UFImage structure.\n- UF_ReadImage: retrieves the last scanned fingerprint image.\n- UF_ScanImage: scans a fingerprint on the sensor and retrieves the image data.\n\n\n\n\nUF_ConvertToBitmap\n\u00b6\n\n\nTo display a UFImage on the PC screen, it should be converted to a bitmap first. \nUF_ConvertToBitmap\n converts a UFImage into a device independent bitmap and returns the handle of it. After drawing the bitmap, it should be destroyed by calling DeleteObject().\n\n\nHBITMAP UF_ConvertToBitmap( UFImage* image )\n\n\nParameters\n\n\nimage\n\nPointer to the UFImage structure to be converted.\n\n\nReturn Values\n\nIf the function succeeds, return the HBITMAP of the bitmap. Otherwise, return NULL.\n\n\nExample\n\u00b6\n\n\n// The following snippet is from FingerprintViewer.cpp in UniFingerUI\n\n\n// source codes\n\n\nclass\n \nCFingerprintViewer\n \n:\n \npublic\n \nCStatic\n\n\n{\n\n    \n// \u2026\n\n\nPrivate\n:\n\n    \nUFImage\n*\n \nm_Image\n;\n\n    \nHBITMAP\n \nm_Bitmap\n;\n\n\n};\n\n\n\nvoid\n \nCFingerprintViewer\n::\nOnPaint\n()\n\n\n{\n\n    \nCPaintDC\n \ndc\n(\n \nthis\n \n);\n\n    \nCBitmap\n \nbmp\n;\n\n\n    \nif\n(\n \nm_Bitmap\n \n)\n\n    \n{\n\n        \nDeleteObject\n(\n \nm_Bitmap\n \n);\n\n    \n}\n\n\n    \nif\n(\n \nm_Image\n \n)\n\n    \n{\n\n        \nm_Bitmap\n \n=\n \nUF_ConvertToBitmap\n(\n \nm_Image\n \n);\n\n        \nbmp\n.\nAttach\n(\n \nm_Bitmap\n \n);\n\n    \n}\n\n    \nelse\n\n    \n{\n\n        \nbmp\n.\nLoadBitmap\n(\n \nIDB_LOGO\n \n);\n\n    \n}\n\n    \nCDC\n \nbmDC\n;\n\n    \nbmDC\n.\nCreateCompatibleDC\n(\n&\ndc\n);\n\n    \nCBitmap\n \n*\npOldbmp\n \n=\n \nbmDC\n.\nSelectObject\n(\n&\nbmp\n);\n\n\n    \nBITMAP\n \nbi\n;\n\n    \nbmp\n.\nGetBitmap\n(\n&\nbi\n);\n\n\n    \nCRect\n \nrect\n;\n\n    \nthis\n->\nGetClientRect\n(\n&\nrect\n);\n\n\n    \ndc\n.\nSetStretchBltMode\n(\n \nHALFTONE\n \n);\n\n    \ndc\n.\nStretchBlt\n(\n \n1\n,\n \n1\n,\n \nrect\n.\nWidth\n()\n \n-\n \n2\n,\n \nrect\n.\nHeight\n()\n \n-\n \n2\n,\n \n&\nbmDC\n,\n \n0\n,\n \n0\n,\n\n\nbi\n.\nbmWidth\n,\n \nbi\n.\nbmHeight\n,\n \nSRCCOPY\n \n);\n\n    \nbmDC\n.\nSelectObject\n(\npOldbmp\n);\n\n\n}\n\n\n\n\n\n\n\nUF_SaveImage\n\u00b6\n\n\nConverts a UFImage into a bitmap and save it into the specified file.\n\n\nUF_RET_CODE UF_SaveImage( const char* fileName, UFImage* image )\n\n\nParameters\n\n\nfileName\n \n\nNull-terminated string that specifies the file name.\n\nimage\n\nPointer to the UFImage to be saved.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_LoadImage\n\u00b6\n\n\nLoads a bmp file into a UFImage structure.\n\n\nUF_RET_CODE UF_LoadImage( const char* fileName, UFImage* image )\n\n\nParameters\n\n\nfileName\n\nNull-terminated string that specifies the file name.\n\nimage\n\nPointer to the UFImage structure.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_ReadImage\n\u00b6\n\n\nReads the last scanned fingerprint image.\n\n\nUF_RET_CODE UF_ReadImage( UFImage* image )\n\n\nParameters\n\n\nimage\n\nPointer to the UFImage structure.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\nExample\n\u00b6\n\n\nUFImage\n*\n \nimage\n \n=\n \n(\nUFImage\n*\n)\nmalloc\n(\n \nUF_IMAGE_HEADER_SIZE\n \n+\n\n                  \nUF_MAX_IMAGE_SIZE\n \n);\n\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_ReadImage\n(\n \nimage\n \n);\n\n\n\n\n\n\n\nUF_ScanImage\n\u00b6\n\n\nScans a fingerprint input on the sensor and retrieves the image of it.\n\n\nUF_RET_CODE UF_ScanImage( UFImage* image )\n\n\nParameters\n\n\nimage\n\nPointer to the UFImage structure.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\n3.10. Enroll API\n\u00b6\n\n\nThere are three ways to enroll fingerprints; scanning live fingerprints, using scanned images, or sending templates acquired elsewhere. The enrollment process varies according to UF_SYS_ENROLL_MODE parameter. Users can also fine tune the enrollment process by selecting enroll options.\n\n\n\n\nUF_Enroll: enrolls fingerprint inputs on the sensor.\n\n\nUF_EnrollContinue: continues the enrollment process when the enroll mode is UF_ENROLL_TWO_TIMES2 or UF_ENROLL_TWO_TEMPLATES2.\n\n\nUF_EnrollAfterVerification: enrolls after an administrator is verified.\n\n\nUF_EnrollTemplate: enrolls a template.\n\n\nUF_EnrollMultipleTemplates: enrolls multiple templates to the specified ID.\n\n\nUF_EnrollImage: enrolls a fingerprint image.\n\n\nUF_SetEnrollCallback: sets the callback function for enrollment process.\n\n\n\n\n\n\nUF_Enroll\n\u00b6\n\n\nEnrolls fingerprint inputs on the sensor. The enrollment process varies according to the UF_SYS_ENROLL_MODE system parameter.\n\n\n\n\n\n\n\n\nEnroll Mode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUF_ENROLL_ONE_TIME\n\n\nScans a fingerprint and enrolls it.\n\n\n\n\n\n\nUF_ENROLL_TWO_TIMES1\n\n\nScans two fingerprints and enrolls the better one of the two. The scanning of the second fingerprint starts automatically.\n\n\n\n\n\n\nUF_ENROLL_TWO_TIMES2\n\n\nSame as UF_ENROLL_TWO_TIMES1, but the scanning of the second fingerprint should be initiated by another request packet.\n\n\n\n\n\n\nUF_ENROLL_TWO_TEMPLATES1\n\n\nScans two fingerprints and enrolls both of them. The scanning of the second fingerprint starts automatically.\n\n\n\n\n\n\nUF_ENROLL_TWO_TEMPLATES2\n\n\nSame as UF_ENROLL_TWO_TEMPLATES1, but the scanning of the second fingerprint should be initiated by another request packet.\n\n\n\n\n\n\n\n\nUsers can also fine tune the enrollment process by selecting one of the following UF_ENROLL_OPTIONs.\n\n\n\n\n\n\n\n\nOption\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUF_ENROLL_NONE\n\n\nOverwrites existing templates of the same ID.\n\n\n\n\n\n\nUF_ENROLL_ADD_NEW\n\n\nAdds templates to the same user ID.   \n The maximum number of templates per user is 10.\n\n\n\n\n\n\nUF_ENROLL_AUTO_ID\n\n\nThe user ID will be assigned automatically by the module.\n\n\n\n\n\n\nUF_ENROLL_CHECK_ID\n\n\nBefore enrolling, checks if the user ID has already some templates. If it does, UF_ERR_EXIST_ID will be returned. This option is useful when users do not want to overwrite existing templates.\n\n\n\n\n\n\nUF_ENROLL_CHECK_FINGER\n\n\nBefore enrolling, checks if the same fingerprint is already enrolled. If the identification succeeds, return UF_ERR_EXIST_FINGER error. If the identification fails, continue enroll process with UF_ENROLL_ADD_NEW option.\n\n\n\n\n\n\nUF_ENROLL_CHECK_FINGER_AUTO_ID\n\n\nBefore enrolling, checks if the same fingerprint is already enrolled. If the identification succeeds, return UF_ERR_EXIST_FINGER error. If the identification fails, continue enroll process with UF_ENROLL_AUTO_ID option.\n\n\n\n\n\n\nUF_ENROLL_DURESS\n\n\nAdds another fingerprint as duress finger to the specified user ID. Under duress, users can authenticate with duress finger to notify the threat. When duress finger is matched, the module will return UF_ERR_DURESS_FINGER error code and write a log. Users can also setup output signals for duress events. When enrolling, the duress finger should not match with nonduress fingerprints of the same ID. If it is the case, UF_ERR_EXIST_FINGER error will be returned.\n\n\n\n\n\n\n\n\nUF_RET_CODE UF_Enroll( UINT32 userID, UF_ENROLL_OPTION option, UINT32* enrollID, UINT32* imageQuality )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\noption\n\nEnroll option.\n\nenrollID\n\nPointer to the enrolled user ID. This parameter can be different from userID when AUTO_ID option is used.\n\nimageQuality\n\nPointer to the image quality score to be returned. The score shows the quality of scanned fingerprint and is in the range of 0 ~ 100.\n\n\nReturn Values\n\nIf enroll succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_EnrollContinue\n\u00b6\n\n\nContinues the enrollment process when the enroll mode is UF_ENROLL_TWO_TIMES2 or UF_ENROLL_TWO_TEMPLATES2.\n\n\nUF_RET_CODE UF_EnrollContinue( UINT32 userID, UINT32* enrollID, UINT32* imageQuality )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\nenrollID\n\nPointer to the enrolled user ID. This parameter can be different from userID when AUTO_ID option is used.\n\nimageQuality\n\nPointer to the image quality score to be returned. The score shows the quality of scanned fingerprint and is in the range of 0 ~ 100.\n\n\nReturn Values\n\nIf enroll succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\nExample\n\u00b6\n\n\n// To enroll user ID 10 with enroll option of ADD_NEW,\n\n\nUINT32\n \nmode\n;\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_GetSysParameter\n(\n \nUF_SYS_ENROLL_MODE\n,\n \n&\nmode\n \n);\n\n\n\nUINT32\n \nuserID\n,\n \nimageQuality\n;\n\n\nresult\n \n=\n \nUF_Enroll\n(\n \n10\n,\n \nUF_ENROLL_ADD_NEW\n,\n \n&\nuserID\n,\n \n&\nimageQuality\n \n);\n\n\n\n// If enroll mode is UF_ENROLL_TWO_TIMES2 or UF_ENROLL_TWO_TEMPLATES2\n\n\nIf\n(\n \nresult\n \n==\n \nUF_RET_SUCCESS\n\n    \n&&\n \n(\nmode\n \n==\n \nUF_ENROLL_TWO_TEMPLATES2\n\n        \n||\n \nmode\n \n==\n \nUF_ENROLL_TWO_TIMES2\n \n)\n \n)\n\n\n{\n\n    \nresult\n \n=\n \nUF_EnrollContinue\n(\n \n10\n,\n \n&\nuserID\n,\n \n&\nimageQuality\n \n);\n\n\n}\n\n\n\n\n\n\n\nUF_EnrollAfterVerification\n\u00b6\n\n\nEnroll and Delete functions change the fingerprint DB stored in the module. For some applications, it might be necessary to obtain administrator\u2019s permission before enrolling or deleting fingerprints. To process these functions, a user with proper administration level should verify himself first. If there is no user with co1rresponding administration level, these commands will fail with UF_ERR_UNSUPPORTED error code. If the verification fails, UF_ERR_NOT_MATCH error code will be returned. The only exception is that \nUF_EnrollAfterVerification\n will succeed when the fingerprint DB is empty. In that case, the first user enrolled by \nUF_EnrollAfterVerification\n will have UF_ADMIN_LEVEL_ALL.\n\n\nUF_RET_CODE UF_EnrollAfterVerification( UINT32 userID, UF_ENROLL_OPTION option, UINT32* enrollID, UINT32* imageQuality )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\noption\n\nEnroll option.\n\nenrollID\n\nPointer to the enrolled user ID. This parameter can be different from userID when AUTO_ID option is used.\n\nimageQuality\n\nPointer to the image quality score to be returned. The score shows the quality of scanned fingerprint and is in the range of 0 ~ 100.\n\n\nReturn Values\n\nIf enroll succeeds, return UF_RET_SUCCESS. If there is no user with corresponding administration level, return UF_ERR_UNSUPPORTED. If administrator\u2019s verification fails, return UF_ERR_NOT_MATCH. Otherwise, return the corresponding error code.\n\n\n\n\nUF_EnrollTemplate\n\u00b6\n\n\nEnrolls a fingerprint template.\n\n\nUF_RET_CODE UF_EnrollTemplate( UINT32 userID, UF_ENROLL_OPTION option, UINT32 templateSize, BYTE* templateData, UINT32* enrollID )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\noption\n\nEnroll option.\n\ntemplateSize\n\nSize of the template data.\n\ntemplateData\n\nPointer to the template data.\n\nenrollID\n\nPointer to the enrolled user ID. This parameter can be different from userID when AUTO_ID option is used.\n\n\nReturn Values\n\nIf enroll succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_EnrollMultipleTemplates\n\u00b6\n\n\nEnrolls multiple templates to the specified ID.\n\n\nUF_RET_CODE UF_EnrollMultipleTemplates( UINT32 userID, UF_ENROLL_OPTION option, int numOfTemplate, UINT32 templateSize, BYTE* templateData, UINT32* enrollID )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\noption\n\nEnroll option.\n\nnumOfTemplate\n\nNumber of templates to be enrolled.\n\ntemplateSize\n\nSize of one template data. For example, when enroll 3 templates of 384 byte, this parameter is 384 not 1152.\n\ntemplateData\n\nPointer to the template data.\n\nenrollID\n\nPointer to the enrolled user ID. This parameter can be different from userID when AUTO_ID option is used.\n\n\nReturn Values\n\nIf enroll succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_EnrollImage\n\u00b6\n\n\nEnrolls a fingerprint image.\n\n\nUF_RET_CODE UF_EnrollImage( UINT32 userID, UF_ENROLL_OPTION option, UINT32 imageSize, BYTE* imageData, UINT32* enrollID, UINT32* imageQuality )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\noption\n\nEnroll option.\n\nimageSize\n\nSize of the image data.\n\nimageData\n\nPointer to the raw image data. Note that it is not the pointer to UFImage, but the pointer to the raw pixel data without the UFImage header.\n\nenrollID\n\nPointer to the enrolled user ID. This parameter can be different from userID when AUTO_ID option is used..\n\nimageQuality\n\nPointer to the image quality score to be returned. The score shows the quality of scanned fingerprint and is in the range of 0 ~ 100.\n\n\nReturn Values\n\nIf enroll succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SetEnrollCallback\n\u00b6\n\n\nSets the callback function for enrollment process. This callback is called after receiving response packets with UF_PROTO_RET_SCAN_SUCCESS, UF_PROTO_RET_SUCCESS, or UF_PROTO_RET_CONTINUE messages.\n\n\nvoid UF_SetEnrollCallback( void (*callback)( BYTE errCode, UF_ENROLL_MODE enrollMode, int numOfSuccess ) )\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.\n\n\nReturn Values\n\nNone\n\n\n\n\n3.11. Identify API\n\u00b6\n\n\nChecks if a fingerprint input is among the enrolled user ids. While verification checks only the fingerprints of a specified user id, identification searches all the enrolled fingerprints until a match is found. As in enrollment, there are three ways to identify fingerprints; scanning live fingerprints, using scanned images, or sending templates acquired elsewhere.\n\n\n\n\nUF_Identify: identifies the fingerprint input on the sensor.\n\n\nUF_IdentifyTemplate: identifies a template.\n\n\nUF_IdentifyImage: identifies a fingerprint image.\n\n\nUF_SetIdentifyCallback: sets the callback function for identification.\n\n\n\n\n\n\nUF_Identify\n\u00b6\n\n\nIdentifies the fingerprint input on the sensor.\n\n\nUF_RET_CODE UF_Identify( UINT32* userID, BYTE* subID )\n\n\nParameters\n\n\nuserID\n\nPointer to the user ID to be returned.\n\nsubID\n\nPointer to the index of the template to be returned.\n\n\nReturn Values\n\nIf matching succeeds, return UF_RET_SUCCESS. If matching fails, return UF_ERR_NOT_FOUND. Otherwise, return the corresponding error code.\n\n\n\n\nUF_IdentifyTemplate\n\u00b6\n\n\nIdentifies a template.\n\n\nUF_RET_CODE UF_IdentifyTemplate( UINT32 templateSize, BYTE* templateData, UINT32* userID, BYTE* subID )\n\n\nParameters\n\n\ntemplateSize\n\nSize of the template data.\n\ntemplateData\n\nPointer to the template data.\n\nuserID\n\nPointer to the user ID to be returned.\n\nsubID\n\nPointer to the index of the template to be returned.\n\n\nReturn Values\n\nIf matching succeeds, return UF_RET_SUCCESS. If matching fails, return UF_ERR_NOT_FOUND. Otherwise, return the corresponding error code.\n\n\n\n\nUF_IdentifyImage\n\u00b6\n\n\nIdentifies a fingerprint image.\n\n\nUF_RET_CODE UF_IdentifyImage( UINT32 imageSize, BYTE* imageData, UINT32* userID, BYTE* subID )\n  \n\n\nParameters\n\n\nimageSize\n\nSize of the image data.\n\nimageData\n\nPointer to the raw image data. Note that it is not the pointer to UFImage, but the pointer to the raw pixel data without the UFImage header.\n\nuserID\n\nPointer to the user ID to be returned.\n\nsubID\n\nPointer to the index of the template to be returned.\n\n\nReturn Values\n\nIf matching succeeds, return UF_RET_SUCCESS. If matching fails, return UF_ERR_NOT_FOUND. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SetIdentifyCallback\n\u00b6\n\n\nSets the callback function for identification process. This callback is called after receiving UF_PROTO_RET_SCAN_SUCCESS message.\n\n\nvoid UF_SetIdentifyCallback( void (*callback)( BYTE ) )\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.\n\n\nReturn Values\n\nNone\n\n\n\n\n3.12. Verify API\n\u00b6\n\n\nVerifies if a fingerprint input matches the enrolled fingerprints of the specified user id. As in enroll process, there are three ways to verify fingerprints; scanning live fingerprints, using scanned images, or sending templates acquired elsewhere.\n\n\n\n\nUF_Verify: verifies the fingerprint input on the sensor.\n\n\nUF_VerifyTemplate: verifies a template.\n\n\nUF_VerifyHostTemplate: verifies the fingerprint input on the sensor with the templates sent by the host.\n\n\nUF_VerifyImage: verifies a fingerprint image.\n\n\nUF_SetVerifyCallback: sets the callback function for verification process.\n\n\n\n\n\n\nUF_Verify\n\u00b6\n\n\nVerifies if a fingerprint input on the sensor matches the enrolled fingerprints of the specified user id.\n\n\nUF_RET_CODE UF_Verify( UINT32 userID, BYTE* subID )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\nsubID\n\nPointer to the index of the template to be returned.\n\n\nReturn Values\n\nIf matching succeeds, return UF_RET_SUCCESS. If matching fails, return UF_ERR_NOT_MATCH. Otherwise, return the corresponding error code.\n\n\n\n\nUF_VerifyTemplate\n\u00b6\n\n\nVerifies a template.\n\n\nUF_RET_CODE UF_VerifyTemplate( UINT32 templateSize, BYTE* templateData, UINT32 userID, BYTE* subID )\n\n\nParameters\n\n\ntemplateSize\n\nSize of the template data.\n\ntemplateData\n\nPointer to the template data to be sent.\n\nuserID\n\nUser ID.\n\nsubID\n\nPointer to the index of the template to be returned.\n\n\nReturn Values\n\nIf matching succeeds, return UF_RET_SUCCESS. If matching fails, return UF_ERR_NOT_MATCH. Otherwise, return the corresponding error code.\n\n\n\n\nUF_VerifyHostTemplate\n\u00b6\n\n\nTransmits fingerprint templates from the host to the module and verifies if they match the live fingerprint input on the sensor.\n\n\nUF_RET_CODE UF_VerifyHostTemplate( UINT32 numOfTemplate, UINT32 templateSize, BYTE* templateData )\n\n\nParameters\n\n\nnumOfTemplate\n\nNumber of templates to be transferred to the module.\n\ntemplateSize\n\nSize of a template.\n\ntemplateData\n\nPointer to the template data to be transferred to the module.\n\n\nReturn Values\n\nIf matching succeeds, return UF_RET_SUCCESS. If matching fails, return UF_ERR_NOT_MATCH. Otherwise, return the corresponding error code.\n\n\n\n\nUF_VerifyImage\n\u00b6\n\n\nVerifies a fingerprint image.\n\n\nUF_RET_CODE UF_VerifyImage( UINT32 imageSize, BYTE* imageData, UINT32 userID, BYTE* subID )\n\n\nParameters\n\n\nimageSize\n\nSize of the fingerprint image.\n\nimageData\n\nPointer to the raw image data. Note that it is not the pointer to UFImage, but the pointer to the raw pixel data without the UFImage header.\n\nuserID\n\nUser ID.\n\nsubID\n\nPointer to the index of the template to be returned.\n\n\nReturn Values\n\nIf matching succeeds, return UF_RET_SUCCESS. If matching fails, return UF_ERR_NOT_MATCH. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SetVerifyCallback\n\u00b6\n\n\nSets the callback function for verification process. The callback function is called after receiving UF_PROTO_RET_SCAN_SUCCESS message.\n\n\nvoid UF_SetVerifyCallback( void (*callback)( BYTE ) )\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.\n\n\nReturn Values\n\nNone\n\n\n\n\n3.13. Delete API\n\u00b6\n\n\nProvides functions for deleting stored templates.\n\n\n\n\nUF_Delete: deletes the templates of the specified user ID.\n\n\nUF_DeleteOneTemplate: deletes one template of the specified user ID.\n\n\nUF_DeleteMultipleTemplates: deletes the template of multiple user IDs.\n\n\nUF_DeleteAll: deletes all the templates.\n\n\nUF_DeleteAllAfterVerification: deletes templates after administrator\u2019s verification.\n\n\nUF_SetDeleteCallback: sets the callback function for delete process.\n\n\n\n\n\n\nUF_Delete\n\u00b6\n\n\nDeletes the enrolled templates of the specified user ID.\n\n\nUF_RET_CODE UF_Delete( UINT32 userID )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\nReturn Values\n\nIf delete succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_DeleteOneTemplate\n\u00b6\n\n\nDeletes one template of the specified user ID.\n\n\nUF_RET_CODE UF_DeleteOneTemplate( UINT32 userID, int subID )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\nsubID\n\nSub index of the template. It is between 0 and 9.\n\n\nReturn Values\n\nIf delete succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_DeleteMultipleTemplates\n\u00b6\n\n\nDeletes the enrolled templates of multiple user IDs.\n\n\nUF_RET_CODE UF_DeleteMultipleTemplates( UINT32 startUserID, UINT32 lastUserID, int* deletedUserID )\n\n\nParameters\n \n\n\nstartUserID\n\nFirst user ID to be deleted.\n\nlastUserID\n\nLast user ID to be deleted.\n\ndeletedUserID\n  \n\nPointer to the number of IDs to be actually deleted by the module.\n\n\nReturn Values\n\nIf delete succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\nExample\n\u00b6\n\n\n// Delete templates of ID 10 ~ ID 20\n\n\nint\n \nnumOfDeleted\n;\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_DeleteMultipleTemplates\n(\n \n10\n,\n \n20\n,\n \n&\nnumOfDeleted\n \n);\n\n\n\n\n\n\n\nUF_DeleteAll\n\u00b6\n\n\nDeletes all the templates stored in a module.\n\n\nUF_RET_CODE UF_DeleteAll()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf delete succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_DeleteAllAfterVerification\n\u00b6\n\n\nDeletes all the templates after administrator\u2019s verification.\n\n\nUF_RET_CODE UF_DeleteAllAfterVerification()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf delete succeeds, return UF_RET_SUCCESS. If there is no user with corresponding administration level, return UF_ERR_UNSUPPORTED. If administrator\u2019s verification fails, return UF_ERR_NOT_MATCH. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SetDeleteCallback\n\u00b6\n\n\nSets the callback function for delete process. This callback is called after receiving UF_PROTO_RET_SCAN_SUCCESS or UF_PROTO_RET_CONTINUE.\n\n\nvoid UF_SetDeleteCallback( void (*callback)( BYTE ) )\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.\n\n\nReturn Values\n\nNone\n\n\n\n\n3.14. IO API for SFM3500\n\u00b6\n\n\nSFM3500 modules have three input ports, three output ports, and three LED ports which are configurable for specific functions. For BioEntry Smart and Pass, there are two input ports, two output ports, and 2 LED ports. These functions are provided to configure these IO ports.\n\n\n\n\nUF_InitIO: clears the output event caches.\n\n\nUF_SetInputFunction: sets the function of an input port.\n\n\nUF_GetInputFunction: gets the function of an input port.\n\n\nUF_GetInputStatus: gets the status of an input port.\n\n\nUF_GetOutputEventList: gets the output events list assigned to an output port.\n\n\nUF_ClearAllOutputEvent: clears all the output events assigned to an output port.\n\n\nUF_ClearOutputEvent: clears an output event assigned to an output port.\n\n\nUF_SetOutputEvent: adds an output event to an output port.\n\n\nUF_GetOutputEvent: gets the signal data of an output event.\n\n\nUF_SetOutputStatus: sets the status of an output port.\n\n\nUF_SetLegacyWiegandConfig: sets the Wiegand format.\n\n\nUF_GetLegacyWiegandConfig: gets the Wiegand format.\n\n\nUF_MakeIOConfiguration: makes IO configuration data to be saved into a file.\n\n\n\n\nUF_InitIO\n\u00b6\n\n\nTo prevent redundant communication, the SFM SDK caches the output events previously read or written. \nUF_InitIO\n clears the cache. It is called in \nUF_Reconnect\n.\n\n\n\n\nvoid UF_InitIO()\n\u00b6\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nNone\n\n\n\n\nUF_SetInputFunction\n\u00b6\n\n\nSets the function of an input port. Available functions are as follows;\n\n\n\n\n\n\n\n\nFunction\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUF_INPUT_NO_ACTION\n\n\nNo action\n\n\n\n\n\n\nUF_INPUT_ENROLL\n\n\nEnroll\n\n\n\n\n\n\nUF_INPUT_IDENTIFY\n\n\nIdentify\n\n\n\n\n\n\nUF_INPUT_DELETE\n\n\nDelete\n\n\n\n\n\n\nUF_INPUT_DELETE_ALL\n\n\nDelete all\n\n\n\n\n\n\nUF_INPUT_ENROLL_BY_WIEGAND\n\n\nEnroll by Wiegand ID\n\n\n\n\n\n\nUF_INPUT_VERIFY_BY_WIEGAND\n\n\nVerify by Wiegand ID\n\n\n\n\n\n\nUF_INPUT_DELETE_BY_WIEGAND\n\n\nDelete by Wiegand ID\n\n\n\n\n\n\nUF_INPUT_ENROLL_VERIFICATION\n\n\nEnroll after administrator\u2019s verification\n\n\n\n\n\n\nUF_INPUT_ENROLL_BY_WIEGAND_VERIFICATION\n\n\nEnroll by Wiegand ID after administrator\u2019s verification\n\n\n\n\n\n\nUF_INPUT_DELETE_VERIFICATION\n\n\nDelete after administrator\u2019s verification\n\n\n\n\n\n\nUF_INPUT_DELETE_BY_WIEGAND_VERIFICATION\n\n\nDelete by Wiegand ID after administrator\u2019s verification\n\n\n\n\n\n\nUF_INPUT_DELETE_ALL_VERIFICATION\n\n\nDelete all after administrator\u2019s verification\n\n\n\n\n\n\nUF_INPUT_CANCEL\n\n\nCancel\n\n\n\n\n\n\nUF_INPUT_TAMPER_SWITCH_IN\n\n\nTamper switch. When the tamper switch is on, Tamper Switch On(0x64) event occurred. When it gets off, Tamper Switch Off(0x65) event occurred. Both events are recorded in log, too. In BioEntry Smart and Pass, UF_INPUT_PORT2 is assigned to Tamper SW.\n\n\n\n\n\n\nUF_INPUT_RESET\n\n\nReset the module\n\n\n\n\n\n\n\n\nUF_RET_CODE UF_SetInputFunction( UF_INPUT_PORT port, UF_INPUT_FUNC inputFunction, UINT32 minimumTime )\n\n\nParameters\n\n\nport\n\nOne of the three input ports \u2013 UF_INPUT_PORT0, UF_INPUT_PORT1, and UF_INPUT_PORT2. For BioEntry Smart and Pass, UF_INPUT_PORT2 is assigned to Tamper SW and not configurable.\n\ninputFunction\n\nInput function.\n\nminimumTime\n\nMinimum duration after which the input signal is acknowledged as active.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetInputFunction\n\u00b6\n\n\nGets the function assigned to an input port.\n\nUF_RET_CODE UF_GetInputFunction( UF_INPUT_PORT port, UF_INPUT_FUNC* inputFunction, UINT32* minimumTime )\n\n\nParameters\n\n\nport\n\nInput port.\n\ninputFunction\n\nPointer to the input function to be returned.\n\nminimumTime\n\nPointer to the minimum duration of input signal to be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetInputStatus\n\u00b6\n\n\nGets the status of an input port.\n\n\nUF_RET_CODE UF_GetInputStatus( UF_INPUT_PORT port, BOOL remainStatus, UINT32* status )\n\n\nParameters\n\n\nport\n\nInput port.\n\nremainStatus\n\nIf TRUE, don\u2019t change the status of the input port after reading. If FALSE, clear the status of the input port.\n\nstatus\n\nPointer to the status of the input port to be read. 0 for inactive and 1 for active status.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetOutputEventList\n\u00b6\n\n\nGets the list of output events assigned to an output/LED port. Available output events are as follows;\n\n\n\n\n\n\n\n\nCategory\n\n\nEvent\n\n\n\n\n\n\n\n\n\n\nEnroll\n\n\nUF_OUTPUT_ENROLL_WAIT_WIEGAND\n\n\n\n\n\n\n\n\nUF_OUTPUT_ENROLL_WAIT_FINGER\n\n\n\n\n\n\n\n\nUF_OUTPUT_ENROLL_PROCESSING\n\n\n\n\n\n\n\n\nUF_OUTPUT_ENROLL_BAD_FINGER\n\n\n\n\n\n\n\n\nUF_OUTPUT_ENROLL_SUCCESS\n\n\n\n\n\n\n\n\nUF_OUTPUT_ENROLL_FAIL\n\n\n\n\n\n\nVerify\n\n\nUF_OUTPUT_VERIFY_WAIT_WIEGAND\n\n\n\n\n\n\n\n\nUF_OUTPUT_VERIFY_WAIT_FINGER\n\n\n\n\n\n\n\n\nUF_OUTPUT_VERIFY_PROCESSING\n\n\n\n\n\n\n\n\nUF_OUTPUT_VERIFY_BAD_FINGER\n\n\n\n\n\n\n\n\nUF_OUTPUT_VERIFY_SUCCESS\n\n\n\n\n\n\n\n\nUF_OUTPUT_VERIFY_FAIL\n\n\n\n\n\n\nIdentify\n\n\nUF_OUTPUT_IDENTIFY_WAIT_FINGER\n\n\n\n\n\n\n\n\nUF_OUTPUT_IDENTIFY_PROCESSING\n\n\n\n\n\n\n\n\nUF_OUTPUT_IDENTIFY_BAD_FINGER\n\n\n\n\n\n\n\n\nUF_OUTPUT_IDENTIFY_SUCCESS\n\n\n\n\n\n\n\n\nUF_OUTPUT_IDENTIFY_FAIL\n\n\n\n\n\n\nDelete\n\n\nUF_OUTPUT_DELETE_WAIT_WIEGAND\n\n\n\n\n\n\n\n\nUF_OUTPUT_DELETE_WAIT_FINGER\n\n\n\n\n\n\n\n\nUF_OUTPUT_DELETE_PROCESSING\n\n\n\n\n\n\n\n\nUF_OUTPUT_DELETE_BAD_FINGER\n\n\n\n\n\n\n\n\nUF_OUTPUT_DELETE_SUCCESS\n\n\n\n\n\n\n\n\nUF_OUTPUT_DELETE_FAIL\n\n\n\n\n\n\nDetect\n\n\nUF_OUTPUT_DETECT_INPUT0\n\n\n\n\n\n\n\n\nUF_OUTPUT_DETECT_INPUT1\n\n\n\n\n\n\n\n\nUF_OUTPUT_DETECT_INPUT2\n\n\n\n\n\n\n\n\nUF_OUTPUT_DETECT_WIEGAND\n\n\n\n\n\n\n\n\nUF_OUTPUT_DETECT_FINGER\n\n\n\n\n\n\nEnd Processing\n\n\nUF_OUTPUT_END_PROCESSING\n\n\n\n\n\n\nDuress\n\n\nUF_OUTPUT_VERIFY_DURESS\n\n\n\n\n\n\n\n\nUF_OUTPUT_IDENTIFY_DURESS\n\n\n\n\n\n\nTamper SW\n\n\nUF_OUTPUT_TAMPER_SWITCH_ON\n\n\n\n\n\n\n\n\nUF_OUTPUT_TAMPER_SWITCH_OFF\n\n\n\n\n\n\nSystem\n\n\nUF_OUTPUT_SYS_STARTED\n\n\n\n\n\n\nSmartCard (Available only for BioEntry Smart)\n\n\nUF_OUTPUT_DETECT_SMARTCARD   \n UF_OUTPUT_BAD_SMARTCARD   \n UF_OUTPUT_WAIT_SMARTCARD\n\n\n\n\n\n\n\n\nUF_RET_CODE UF_GetOutputEventList( UF_OUTPUT_PORT port, UF_OUTPUT_EVENT* events, int* numOfEvent )\n\n\nParameters\n\n\nport\n\nOutput/LED port.\n\nevents\n\nArray of output events to be returned.\n\nnumOfEvent\n\nPointer to the number of output events to be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\nExample\n\u00b6\n\n\n// To read the output events assigned to OUT0\n\n\nUF_OUTPUT_EVENT\n \nevents\n[\nUF_MAX_OUTPUT_PER_PORT\n];\n\n\nint\n \nnumOfEvent\n;\n\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_GetOutputEventList\n(\n \nUF_OUTPUT_PORT0\n,\n \nevents\n,\n\n\n&\nnumOfEvent\n \n);\n\n\n\n\n\n\n\nUF_ClearAllOutputEvent\n\u00b6\n\n\nClears all the output events assigned to an output/LED port.\n\n\nUF_RET_CODE UF_ClearAllOutputEvent( UF_OUTPUT_PORT port )\n\n\nParameters\n\n\nport\n\nOutput/LED port.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_ClearOutputEvent\n\u00b6\n\n\nClears the specified output event from the output port.\n\n\nUF_RET_CODE UF_ClearOutputEvent( UF_OUTPUT_PORT port, UF_OUTPUT_EVENT event )\n\n\nParameters\n\n\nport\n\nOutput/LED port.\n\nevent\n\nOutput event to be deleted from the output/LED port.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SetOutputEvent\n\u00b6\n\n\nAdds an output event to the specified output/LED port. The characteristics of output signal is also specified.\n\n\n \n\n\ntypedef\n \nstruct\n \n{\n\n    \nunsigned\n \nshort\n \ndelay\n;\n \n// t_delay\n\n    \nunsigned\n \nshort\n \ncount\n;\n \n// t_count\n\n    \nunsigned\n \nshort\n \nactive\n;\n \n// t_high\n\n    \nunsigned\n \nshort\n \ninactive\n;\n \n// t_low\n\n\n}\n \nUFOutputSignal\n;\n\n\n\n\n\nUF_RET_CODE UF_SetOutputEvent( UF_OUTPUT_PORT port, UF_OUTPUT_EVENT event, UFOutputSignal signal )\n\n\nParameters\n\n\nport\n\nOutput/LED port.\n\nevent\n\nOutput event to be added.\n\nsignal\n\nSignal specification of the output event.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\nExample\n\u00b6\n\n\n// To turn on the LED0 for 500ms when verification succeeds,\n\n\nUFOutputSignal\n \nsignal\n;\n\n\nsignal\n.\ndelay\n \n=\n \n0\n;\n\n\nsignal\n.\ncount\n \n=\n \n1\n;\n\n\nsignal\n.\nactive\n \n=\n \n500\n;\n\n\nsignal\n.\ninactive\n \n=\n \n0\n;\n\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_SetOutputEvent\n(\n \nUF_OUTPUT_LED0\n,\n\n\nUF_OUTPUT_VERIFY_SUCCESS\n,\n \nsignal\n \n);\n\n\n\n\n\n\n\nUF_GetOutputEvent\n\u00b6\n\n\nGets the signal data of an output event on the specified output/LED port.\n\nUF_RET_CODE UF_GetOutputEvent( UF_OUTPUT_PORT port, UF_OUTPUT_EVENT event, UFOutputSignal* signal )\n\n\nParameters\n\n\nport\n\nOutput/LED port.\n\nevent\n\nOutput event.\n\nsignal\n\nPointer to the signal data to be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SetOutputStatus\n\u00b6\n\n\nSets the status of an output/LED port.\n\n\nUF_RET_CODE UF_SetOutputStatus( UF_OUTPUT_PORT port, BOOL status )\n\n\nParameters\n\n\nport\n\nOutput/LED port.\n\nstatus\n\nTRUE for active and FALSE for inactive status.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SetLegacyWiegandConfig(Deprecated)\n\u00b6\n\n\nUntil the firmware V1.3, SFM 3500 modules only support 26 bit Wiegand format. Since the firmware V1.4, Extended Wiegand Interface is provided, which is much more powerful and flexible. \nUF_SetLegacyWiegandConfig\n configures the legacy 26 bit Wiegand format and is provided only for firmwares older than V1.4.\n\n\nUF_RET_CODE UF_SetLegacyWiegandConfig( BOOL enableInput, BOOL enableOutput, UINT32 fcBits, UINT32 fcCode )\n\n\nParameters\n\n\nenableInput\n\nIf TRUE, the module starts verification process when receiving Wiegand inputs.\n\nenableOutput\n\nIf TURE, the module outputs the user ID when verification or identification succeeds.\n\nfcBits\n\nSpecifies the number of facility bits.\n\nfcCode\n\nSpecifies the facility code.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetLegacyWiegandConfig(Deprecated)\n\u00b6\n\n\nGets the configuration of the 26 bit Wiegand format.\n\n\nUF_RET_CODE UF_GetLegacyWiegandConfig( BOOL* enableInput, BOOL* enableOutput, UINT32* fcBits, UINT32* fcCode )\n\n\nParameters\n\n\nenableInput\n\nPointer to the input enable status.\n\nenableOutput\n\nPointer to the output enable status.\n\nfcBits\n\nPointer to the number of facility bits to be returned.\n\nfcCode\n\nPointer to the facility code to be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_MakeIOConfiguration\n\u00b6\n\n\nMakes IO configuration data to be saved into a file. See the example of \nUF_SaveConfiguration\n for the usage of this function.\n\n\nUF_RET_CODE UF_MakeIOConfiguration( UFConfigComponentHeader* configHeader, BYTE* configData )\n\n\nParameters\n\n\nconfigHeader\n\nPointer to the configuration header to be returned.\n\nconfigData\n\nPointer to the configuration data to be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\n3.15. GPIO API for SFM3000/4000/5000\n\u00b6\n\n\nSFM3000 series modules have 8 GPIO ports, which are configurable for specific functions. The function of each GPIO can be read and programmed via these APIs. . GPIO port can be configured as input, output, shared I/O, Wiegand input, or Wiegand output. In the input mode, enroll, identify, and delete functions are supported. In the output mode, the port can send output patterns corresponding to the various events such as match success, enroll fail, and so on.\n\n\n\n\nUF_GetGPIOConfiguration: gets the configuration data of a GPIO port.\n\n\nUF_SetInputGPIO: configures an input GPIO port.\n\n\nUF_SetOutputGPIO: configures an output GPIO port.\n\n\nUF_SetSharedGPIO: configures a shared I/O port.\n\n\nUF_DisableGPIO: disables a GPIO port.\n\n\nUF_ClearAllGPIO: clears all the GPIO configurations.\n\n\nUF_SetDefaultGPIO: resets to default GPIO configurations.\n\n\nUF_EnableWiegandInput: enables Wiegand input.\n\n\nUF_EnableWiegandOutput: enables Wiegand output.\n\n\nUF_DisableWiegandInput: disables Wiegand input.\n\n\nUF_DisableWiegandOutput: disables Wiegand output.\n\n\nUF_MakeGPIOConfiguration: makes GPIO configuration data to be saved into a file.\n\n\n\n\n\n\nUF_GetGPIOConfiguration\n\u00b6\n\n\nGets the configuration data of a GPIO port.\n\n\nUF_RET_CODE UF_GetGPIOConfiguration( UF_GPIO_PORT port, UF_GPIO_MODE* mode, int* numOfData, UFGPIOData* data )\n\n\nParameters\n\n\nport\n\nGPIO port from UF_GPIO_0 to UF_GPIO_7.\n\nmode\n\nPointer to the GPIO mode to be returned. Available GPIO modes are as follows;\n\n\n\n\n\n\n\n\nMode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUF_GPIO_INPUT\n\n\nInput port\n\n\n\n\n\n\nUF_GPIO_OUTPUT\n\n\nOutput port\n\n\n\n\n\n\nUF_GPIO_SHARED_IO\n\n\nShared IO port\n\n\n\n\n\n\nUF_GPIO_WIEGAND_INPUT\n\n\nWiegand input port\n\n\n\n\n\n\nUF_GPIO_WIEGAND_OUTPUT\n\n\nWiegand output port\n\n\n\n\n\n\n\n\nnumOfData\n\nNumber of configuration data assigned to the port.\n\ndata\n\nArray of GPIO configuration data to be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\nExample\n\u00b6\n\n\n// To retrieve the configuration data of GPIO 0\n\n\nUFGPIOData\n \nconfigData\n[\nUF_MAX_GPIO_OUTPUT_EVENT\n];\n\n\nUF_GPIO_MODE\n \nmode\n;\n\n\nint\n \nnumOfData\n;\n\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_GetGPIOConfiguration\n(\n \nUF_GPIO_0\n,\n \n&\nmode\n,\n \n&\nnumOfData\n,\n \nconfigData\n \n);\n\n\n\n\n\n\n\nUF_SetInputGPIO\n\u00b6\n\n\nConfigures an input GPIO port.\n\n\nUF_RET_CODE UF_SetInputGPIO( UF_GPIO_PORT port, UFGPIOInputData data )\n\n\nParameters\n\n\nport\n\nGPIO port. Only GPIO 0 to GPIO 3 can be an input port.\n\ndata\n\nUFGPIOInputData is defined as follows;\n\n\ntypedef\n \nstruct\n \n{\n\n    \nunsigned\n \nshort\n \ninputFunction\n;\n \n// See UF_GPIO_INPUT_FUNC\n\n                                  \n// in UF_3000IO.h\n\n    \nunsigned\n \nshort\n \nactivationLevel\n;\n \n// See UF_GPIO_INPUT_ACTIVATION\n\n                                  \n// in UF_3000IO.h\n\n    \nunsigned\n \nshort\n \ntimeout\n;\n \n// valid only if inputFUnction is\n\n                            \n// UF_GPIO_IN_DELETE_ALL or\n\n                            \n// UF_GPIO_IN_DELETE_ALL_VERIFICATION\n\n    \nunsigned\n \nshort\n \nreserved\n;\n\n\n}\n \nUFGPIOInputData\n;\n\n\n\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\nExample\n\u00b6\n\n\n// To assign identify to GPIO 0 with ACTIVE_HIGH signal\n\n\nUFGPIOInputData\n \ninputData\n;\n\n\ninputData\n.\ninputFunction\n \n=\n \nUF_GPIO_IN_IDENTIFY\n;\n\n\ninputData\n.\nactivationLevel\n \n=\n \nUF_GPIO_IN_ACTIVE_HIGH\n;\n\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_SetInputGPIO\n(\n \nUF_GPIO_0\n,\n \ninputData\n \n);\n\n\n\n\n\n\n\nUF_SetOutputGPIO\n\u00b6\n\n\nConfigures an output GPIO port.\n\n\nUF_RET_CODE UF_SetOutputGPIO( UF_GPIO_PORT port, int numOfData, UFGPIOOutputData* data )\n\n\nParameters\n\n\nport\n\nGPIO port.\n\nnumOfData\n\nNumber of UFGPIOOutputData to be assigned to the GPIO port.\n\ndata\n\nArray of UFGPIOOutputData to be assigned to the GPIO port.\nUFGPIOOutputData is defined as follows;\n\n\ntypedef\n \nstruct\n \n{\n\n    \nunsigned\n \nshort\n \nevent\n;\n \n// see UF_GPIO_OUTPUT_EVENT\n\n                          \n// in UF_3000IO.h\n\n    \nunsigned\n \nshort\n \nlevel\n;\n \n// see UF_GPIO_OUTPUT_LEVEL\n\n    \nunsigned\n \nshort\n \ninterval\n;\n \n// in milliseconds\n\n    \nunsigned\n \nshort\n \nblinkingPeriod\n;\n \n// valid only if the level is\n\n                \n// UF_GPIO_OUT_HIGH_BLINK or UF_GPIO_OUT_LOW_BLINK\n\n\n}\n \nUFGPIOOutputData\n;\n\n\n\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SetSharedGPIO\n\u00b6\n\n\nConfigures the shared I/O GPIO port.\n\n\nUF_RET_CODE UF_SetSharedGPIO( UF_GPIO_PORT port, UFGPIOInputData inputData, int numOfOutputData, UFGPIOOutputData* outputData )\n\n\nParameters\n\n\nport\n\nGPIO port. Only GPIO 0 to GPIO 3 can be a shared I/O port.\n\ninputData\n\nInput data to be assigned.\n\nnumOfOutputData\n\nNumber of UFGPIOOutputData to be assigned.\n\noutputData\n\nArray of UFGPIOOutputData to be assigned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_DisableGPIO\n\u00b6\n\n\nDisables a GPIO port.\n\n\nUF_RET_CODE UF_DisableGPIO( UF_GPIO_PORT port )\n\n\nParameters\n\n\nport\n\nGPIO port.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_ClearAllGPIO\n\u00b6\n\n\nClears all the configurations of GPIO ports.\n\n\nUF_RET_CODE UF_ClearAllGPIO()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SetDefaultGPIO\n\u00b6\n\n\nResets the configurations of GPIO ports to default.\n\n\nUF_RET_CODE UF_SetDefaultGPIO()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_EnableWiegandInput\n\u00b6\n\n\nEnables Wiegand input. Wiegand input uses GPIO 2 and GPIO 3 as input signal.\n\n\nUF_RET_CODE UF_EnableWiegandInput( UFGPIOWiegandData data )\n\n\nParameters\n\n\ndata\n\nUFGPIOWiegandData is defined as follows;\n\n\ntypedef\n \nstruct\n \n{\n\n    \nunsigned\n \nshort\n \ntotalBits\n;\n \n// fixed at 26 bit\n\n    \nunsigned\n \nshort\n \nfcBits\n;\n \n// number of facility bits\n\n    \nunsigned\n \nshort\n \nidBits\n;\n \n// number of id bits\n\n    \nunsigned\n \nshort\n \nfcCode\n;\n \n// facility code\n\n\n}\n \nUFGPIOWiegandData\n;\n\n\n\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_EnableWiegandOutput\n\u00b6\n\n\nEnables Wiegand output. Wiegand output use GPIO 4 and GPIO 5 as output signal.\n\n\nUF_RET_CODE UF_EnableWiegandOutput( UFGPIOWiegandData data )\n\n\nParameters\n\n\ndata\n\nWiegand configuration data.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_DisableWiegandInput\n\u00b6\n\n\nDisables Wiegand input.\n\n\nUF_RET_CODE UF_DisableWiegandInput()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_DisableWiegandOutput\n\u00b6\n\n\nDisables Wiegand output.\n\n\nUF_RET_CODE UF_DisableWiegandOutput()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_MakeGPIOConfiguration\n\u00b6\n\n\nMakes GPIO configuration data to be saved into a file.\n\n\nUF_RET_CODE UF_MakeGPIOConfiguration( UFConfigComponentHeader* configHeader, BYTE* configData )\n\n\nParameters\n\n\nconfigHeader\n\nPointer to the configuration header.\n\nconfigData\n\nPointer to the configuration data.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\nExample\n\u00b6\n\n\nSee CUniFingerUI3000IOView::OnGpioSaveFile in UniFingerUI source codes.\n\n\n\n\n3.16. User Memory API\n\u00b6\n\n\nSFM modules reserve 256 bytes for user data. This area can be read and written by these APIs.\n- UF_WriteUserMemory: writes data to the user memory.\n- UF_ReadUserMemory: reads the contents of the user memory.\n\n\n\n\nUF_WriteUserMemory\n\u00b6\n\n\nWrites data into the user memory.\n\n\nUF_RET_CODE UF_WriteUserMemory( BYTE* memory )\n\n\nParameters\n\n\nmemory\n\nPointer to the 256 byte array to be written.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_ReadUserMemory\n\u00b6\n\n\nReads the contents of the user memory.\n\n\nUF_RET_CODE UF_ReadUserMemory( BYTE* memory )\n\n\nParameters\n\n\nmemory\n\nPointer to the 256 byte array to be read.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\n3.17. Log Management API\n\u00b6\n\n\nSFM3500 modules provide logging facility for recording important events. Users can receive logs from the module and delete unwanted ones. The format of a log record is as follows;\n\n\n\n\n\n\n\n\nItem\n\n\nDescription\n\n\nSize\n\n\n\n\n\n\n\n\n\n\nSource\n\n\nUF_LOG_SOURCE_HOST_PORT\n\n\n1 byte\n\n\n\n\n\n\n\n\nUF_LOG_SOURCE_AUX_PORT\n\n\n\n\n\n\n\n\n\n\nUF_LOG_SOURCE_WIEGAND_INPUT\n\n\n\n\n\n\n\n\n\n\nUF_LOG_SOURCE_IN0\n\n\n\n\n\n\n\n\n\n\nUF_LOG_SOURCE_IN1\n\n\n\n\n\n\n\n\n\n\nUF_LOG_SOURCE_IN2\n\n\n\n\n\n\n\n\n\n\nUF_LOG_SOURCE_FREESCAN\n\n\n\n\n\n\n\n\n\n\nUF_LOG_SOURCE_SMARTCARD\n\n\n\n\n\n\n\n\nEvent ID\n\n\nOne of the UF_OUTPUT_EVENT\n\n\n1 byte\n\n\n\n\n\n\nDate\n\n\n(DD << 16) / (MM << 8) / YY\n\n\n3 bytes\n\n\n\n\n\n\nTime\n\n\n(ss << 16) / (mm << 8) / hh\n\n\n3 bytes\n\n\n\n\n\n\nUser ID\n\n\nUser ID\n\n\n4 bytes\n\n\n\n\n\n\nCustom Field\n\n\nCustomizable by user\n\n\n4 bytes\n\n\n\n\n\n\n\n\nIn V1.6 firmware, there are two enhancements for logging functions. First, 4 byte custom field is added to log records. Making use of this field, users can add customized events to log records. Second, the log cache is added for real-time monitoring.\n\n\n\n\nUF_SetTime: sets the time of the module.\n\n\nUF_GetTime: gets the time of the module.\n\n\nUF_GetNumOfLog: gets the number of log records.\n\n\nUF_ReadLog: reads log records.\n\n\nUF_ReadLatestLog: reads latest log records.\n\n\nUF_DeleteOldestLog: deletes oldest log records.\n\n\nUF_DeleteAllLog: deletes all the log records.\n\n\nUF_ClearLogCache: clears the log cache.\n\n\nUF_ReadLogCache: reads the log records in the cache.\n\n\nUF_SetCustomLogField: sets the custom field of log records.\n\n\nUF_GetCustomLogField: gets the custom field of log records.\n\n\n\n\n\n\nUF_SetTime\n\u00b6\n\n\nSets the time of the module.\n\n\nUF_RET_CODE UF_SetTime( time_t timeVal )\n\n\nParameters\n\n\ntimeVal\n\nNumber of seconds elapsed since midnight (00:00:00), January 1, 1970.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetTime\n\u00b6\n\n\nGets the time of the module.\n\n\nUF_RET_CODE UF_GetTime( time_t* timeVal )\n\n\nParameters\n\n\ntimeVal\n\nPointer to the time value to be returned by the module.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetNumOfLog\n\u00b6\n\n\nRetrieves the number of log records.\n\n\nUF_RET_CODE UF_GetNumOfLog( int* numOfLog, int* numOfTotalLog )\n\n\nParameters\n\n\nnumOfLog\n\nPointer to the number of log records to be returned.\n\nnumOfTotalLog\n\nPointer to the maximum log records to be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_ReadLog\n\u00b6\n\n\nReads log records.\n\n\nUF_RET_CODE UF_ReadLog( int startIndex, int count, UFLogRecord* logRecord, int* readCount )\n\n\nParameters\n\n\nstartIndex\n\nStart index of log records to be read.\n\ncount\n\nNumber of log records to be read.\n\nlogRecord\n\nPointer to the log records to be read.\n\nreadCount\n\nPointer to the number of log records actually read.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_ReadLatestLog\n\u00b6\n\n\nReads latest log records.\n\n\nUF_RET_CODE UF_ReadLatestLog( int count, UFLogRecord* logRecord, int* readCount )\n\n\nParameters\n\n\ncount\n\nNumber of latest log records to be read.\n\nlogRecord\n\nPointer to the log records to be read.\n\nreadCount\n\nPointer to the number of log records actually read.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_DeleteOldestLog\n\u00b6\n\n\nDeletes oldest log records.\n\n\nUF_RET_CODE UF_DeleteOldestLog( int count, int* deletedCount )\n\n\nParameters\n\n\ncount\n\nNumber of oldest log records to be deleted. It should be a multiple of 256.\n\ndeletedCount\n\nPointer to the number of log records actually deleted.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_DeleteAllLog\n\u00b6\n\n\nDeletes all the log records.\n\n\nUF_RET_CODE UF_DeleteAllLog()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_ClearLogCache\n\u00b6\n\n\nClears the log cache.\n\n\nUF_RET_CODE UF_ClearLogCache()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_ReadLogCache\n\u00b6\n\n\nReads the log records in the cache. After reading, the cache will be cleared. The maximum number of log records in the cache is 256.\n\n\nUF_RET_CODE UF_ReadLogCache( int dataPacketSize, int* numOfLog, UFLogRecord* logRecord )\n\n\nParameters\n\n\ndataPacketSize\n\nData packet size used in Extended Data Transfer protocol.\n\nnumOfLog\n\nPointer to the number of log records to be returned.\n\nlogRecord\n\nPointer to the log records to be returned. This pointer should be preallocated large enough to store the log records.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SetCustomLogField\n\u00b6\n\n\nThere is a 4 byte reserved field in each log record. This function is used for setting this custom value. If the custom field is not set, it will be filled with NULL.\n\n\nUF_RET_CODE UF_SetCustomLogField( UF_LOG_SOURCE source, unsigned customField )\n\n\nParameters\n\n\nsource\n\nUsers can set 4 different custom values according to the source of log records.\n\n\n\n\n\n\n\n\nSource\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUF_LOG_SOURCE_OTHER\n\n\nIf the log is generated by Packet Protocol commands or freescan, this value will be used.\n\n\n\n\n\n\nUF_LOG_SOURCE_IN0   \n UF_LOG_SOURCE_IN1   \n UF_LOG_SOURCE_IN2\n\n\nIf the log is generated by an Input port, the respective values will be used.\n\n\n\n\n\n\n\n\ncustomField\n\n4 byte custom value.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetCustomLogField\n\u00b6\n\n\nReads the custom value of the specified log source.\n\n\nUF_RET_CODE UF_GetCustomLogField( UF_LOG_SOURCE source, unsigned* customField )\n\n\nParameters\n  \n\n\nsource\n\nLog source.\n\ncustomField\n\nPointer to the 4 byte custom value to be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\n3.18. Extended Wiegand API\n\u00b6\n\n\nExtended Wiegand Interface supports up to 64 bit Wiegand formats. The only constraint is that the ID field is limited to 32 bits. It also supports advanced options such as Fail ID and Inverse Parity on Fail.\n\n\n\n\nUF_SetWiegandFormat: configures the Wiegand format.\n\n\nUF_GetWiegandFormat: gets the Wiegand format information.\n\n\nUF_SetWiegandIO: configures the Wiegand IO ports.\n\n\nUF_GetWiegandIO: gets the configurations of the Wiegand IO ports.\n\n\nUF_SetWiegandOption: sets the advanced options.\n\n\nUF_GetWiegandOption: gets the advanced options.\n\n\nUF_SetAltValue: sets the alternative value of a field.\n\n\nUF_ClearAltValue: clears the alternative value of a field.\n\n\nUF_GetAltValue: gets the alternative value of a field.\n\n\nUF_MakeWiegandConfiguration: makes Wiegand configuration data to be saved into a file.\n\n\n\n\n\n\nUF_SetWiegandFormat\n\u00b6\n\n\nConfigures the Wiegand format.\n\n\nUF_RET_CODE UF_SetWiegandFormat( UFWiegandFormatHeader* header, UFWiegandFormatData* data, int pulseWidth, int pulseInterval )\n\n\nParameters\n\n\nheader\n\nUFWiegandFormatHeader is defined as follows;\n\n\ntypedef\n \nstruct\n \n{\n\n    \nUF_WIEGAND_FORMAT\n \nformat\n;\n \n// UF_WIEGAND_26BIT,\n\n                             \n// UF_WIEGAND_PASS_THRU,\n\n                             \n// UF_WIEGAND_CUSTOM\n\n    \nint\n             \ntotalBits\n;\n\n\n}\n \nUFWiegandFormatHeader\n;\n\n\n\n\n\ndata\n\nWiegand format data. If the format is UF_WIEGAND_26BIT, there is no format data and this parameter will be ignored. UFWiegandFormatData is defined as follows;\n\n\ntypedef\n \nstruct\n \n{\n\n    \nint\n                \nnumOfIDField\n;\n\n    \nUFWiegandField\n     \nfield\n[\nMAX_WIEGAND_FIELD\n];\n\n\n}\n \nUFWiegandPassThruData\n;\n\n\n\ntypedef\n \nstruct\n \n{\n\n    \nint\n                \nnumOfField\n;\n\n    \nUINT32\n             \nidFieldMask\n;\n\n    \nUFWiegandField\n     \nfield\n[\nMAX_WIEGAND_FIELD\n];\n\n    \nint\n                \nnumOfParity\n;\n\n    \nUFWiegandParity\n    \nparity\n[\nMAX_WIEGAND_PARITY\n];\n\n\n}\n \nUFWiegandCustomData\n;\n\n\n\ntypedef\n \nunion\n \n{\n\n    \nUFWiegandPassThruData\n   \npassThruData\n;\n\n    \nUFWiegandCustomData\n     \ncustomData\n;\n\n\n}\n \nUFWiegandFormatData\n;\n\n\n\n\n\npulseWidth\n\nSpecifies the width of Wiegand signal.\n\npulseInterval\n\nSpecifies the interval of Wiegand signal.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetWiegandFormat\n\u00b6\n\n\nGets the Wiegand format data.\n\n\nUF_RET_CODE UF_GetWiegandFormat( UFWiegandFormatHeader* header, UFWiegandFormatData* data, int* pulseWidth, int* pulseInterval )\n\n\nParameters\n\n\nheader\n\nPointer to the format header to be returned.\n\ndata\n\nPointer to the format data to be returned.\n\npulseWidth\n\nPointer to the width of Wiegand signal.\n\npulseInterval\n\nPointer to the interval of Wiegand signal.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SetWiegandIO\n\u00b6\n\n\nConfigures the Wiegand IO ports.\n\n\nUF_RET_CODE UF_SetWiegandIO( UF_WIEGAND_INPUT_MODE inputMode, UF_WIEGAND_OUTPUT_MODE outputMode, int numOfChar )\n\n\nParameters\n\n\ninputMode\n  \n\n\n\n\n\n\n\n\nMode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUF_WIEGAND_INPUT_DISABLE\n\n\nIgnores Wiegand inputs.\n\n\n\n\n\n\nUF_WIEGAND_INPUT_VERIFY\n\n\nStarts verification after receiving Wiegand inputs.\n\n\n\n\n\n\n\n\noutputMode\n  \n\n\n\n\n\n\n\n\nMode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUF_WIEGAND_OUTPUT_DISABLE\n\n\nDisables Wiegand output.\n\n\n\n\n\n\nUF_WIEGAND_OUTPUT_WIEGAND_ONLY\n\n\nOutputs Wiegand signal only if the verification is initiated by Wiegand input.\n\n\n\n\n\n\nUF_WIEGAND_OUTPUT_ALL\n\n\nOutputs Wiegand signal if matching succeeds.\n\n\n\n\n\n\nUF_WIEGAND_OUTPUT_ABA_TRACK_II\n\n\nOutputs ABA Track II characters instead of Wiegand signal.\n\n\n\n\n\n\n\n\nnumOfChar\n\nNumber of characters in ABA Track II output format. It is ignored if\noutputMode is not UF_WIEGAND_OUTPUT_ABA_TRACK_II.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetWiegandIO\n\u00b6\n\n\nGets the configurations of Wiegand IO ports.\n\n\nUF_RET_CODE UF_GetWiegandIO( UF_WIEGAND_INPUT_MODE* inputMode, UF_WIEGAND_OUTPUT_MODE* outputMode, int* numOfChar )\n\n\nParameters\n\n\ninputMode\n\nPointer to Wiegand input mode to be returned.\n\noutputMode\n\nPointer to Wiegand output mode to be returned.\n\nnumOfChar\n\nPointer to the number of characters in ABA Track II output format. It is ignored if outputMode is not UF_WIEGAND_OUTPUT_ABA_TRACK_II.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SetWiegandOption\n\u00b6\n\n\nSets advanced options.\n\n\nUF_RET_CODE UF_SetWiegandOption( BOOL useFailID, UINT32 failID, BOOL inverseParityOnFail )\n\n\nParameters\n\n\nuseFailID\n\nNormally the module outputs Wiegand signal only if matching succeeds. If this option is TRUE, the module outputs the fail ID when matching fails.\n\nfailID\n\nID to be output if useFailID is TRUE.\n\ninverseParityOnFail\n\nIf this option is TRUE, the module outputs Wiegand signals with inverted parities when matching fails.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetWiegandOption\n\u00b6\n\n\nGets the advanced options.\n\n\nUF_RET_CODE UF_GetWiegandOption( BOOL* useFailID, UINT32* failID, BOOL* inverseParityOnFail )\n\n\nParameters\n\n\nuserFailID\n\nPointer to the useFailID option to be returned.\n\nfailID\n\nPointer to the fail ID to be returned.\n\ninverseParityOnFail\n\nPointer to the inverseParityOnFail option to be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SetAltValue\n\u00b6\n\n\nIf the Wiegand format is UF_WIEGAND_26BIT or UF_WIEGAND_CUSTOM, users can set alternative values for non-ID fields. If an alternative value is set for a non-ID field, the module will replace the field with the alternative value before outputting the signal.\n\n\nUF_RET_CODE UF_SetAltValue( int fieldIndex, UINT32 value )\n\n\nParameters\n\n\nfieldIndex\n\nIndex of the field.\n\nvalue\n\nAlternative value of the field.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_ClearAltValue\n\u00b6\n\n\nClears the alternative value of a field.\n\n\nUF_RET_CODE UF_ClearAltValue( int fieldIndex )\n\n\nParameters\n\n\nfieldIndex\n\nIndex of the field.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetAltValue\n\u00b6\n\n\nGets the alternative value of a field.\n\n\nUF_RET_CODE UF_GetAltValue( int fieldIndex, UINT32* value )\n\n\nParameters\n\n\nfieldIndex\n\nIndex of the field.\n\nvalue\n\nAlternative value of the field to be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. If alternative value is not set to the field, return UF_ERR_NOT_FOUND. Otherwise, return the corresponding error code.\n\n\n\n\nUF_MakeWiegandConfiguration\n\u00b6\n\n\nMakes Wiegand configuration data to be saved into a file.\n\n\nUF_RET_CODE UF_MakeWiegandConfiguration( UFConfigComponentHeader* configHeader, BYTE* configData )\n\n\nParameters\n\n\nconfigHeader\n\nPointer to the configuration header to be returned.\n\nconfigData\n\nPointer to the configuration data to be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\nExample\n\u00b6\n\n\nSee CUniFingerUIWiegandView::OnWiegandSaveFile in UniFingerUI source codes.\n\n\n\n\n3.19. Wiegand Command Card API\n\u00b6\n\n\nUsers can map an input function to a Wiegand ID. When the module detects the mapped IDs in Wiegand input port, it will execute the corresponding input function.\n\n\n\n\nUF_AddWiegandCommandCard: adds a mapping of input function to the specified ID.\n\n\nUF_GetWiegandCommandCardList: gets all the mapping data.\n\n\nUF_ClearAllWiegandCommandCard: clears all the mappings.\n\n\n\n\n\n\nUF_AddWiegandCommandCard\n\u00b6\n\n\nMaps the input function to the specified ID.\n\n\nUF_RET_CODE UF_AddWiegandCommandCard( UINT32 userID, UF_INPUT_FUNC function )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\nfunction\n\nAmong the input functions, the followings can be assigned to command cards.\n\n\n\n\n\n\n\n\nFunction\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUF_INPUT_ENROLL\n\n\nEnroll\n\n\n\n\n\n\nUF_INPUT_IDENTIFY\n\n\nIdentify\n\n\n\n\n\n\nUF_INPUT_DELETE\n\n\nDelete\n\n\n\n\n\n\nUF_INPUT_DELETE_ALL\n\n\nDelete all\n\n\n\n\n\n\nUF_INPUT_ENROLL_BY_WIEGAND\n\n\nEnroll by Wiegand ID\n\n\n\n\n\n\nUF_INPUT_DELETE_BY_WIEGAND\n\n\nDelete by Wiegand ID\n\n\n\n\n\n\nUF_INPUT_ENROLL_VERIFICATION\n\n\nEnroll after administrator\u2019s verification\n\n\n\n\n\n\nUF_INPUT_ENROLL_BY_WIEGAND_VERIFICATION\n\n\nEnroll by Wiegand ID after administrator\u2019s verification\n\n\n\n\n\n\nUF_INPUT_DELETE_VERIFICATION\n\n\nDelete after administrator\u2019s verification\n\n\n\n\n\n\nUF_INPUT_DELETE_BY_WIEGAND_VERIFICATION\n\n\nDelete by Wiegand ID after administrator\u2019s verification\n\n\n\n\n\n\nUF_INPUT_DELETE_ALL_VERIFICATION\n\n\nDelete all after administrator\u2019s verification\n\n\n\n\n\n\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetWiegandCommandCardList\n\u00b6\n\n\nGets the list of all the command cards.\n\n\nUF_RET_CODE UF_GetWiegandCommandCardList( int* numOfCard, UFWiegandCommandCard* commandCard )\n\n\nParameters\n\n\nnumOfCard\n\nNumber of command cards to be returned.\n\ncommandCard\n\nArray of command card information to be returned. UFWiegandCommandCard is defined as follows;\n\n\ntypedef\n \nstruct\n \n{\n\n    \nUINT32\n          \nuserID\n;\n\n    \nUF_INPUT_FUNC\n   \nfunction\n;\n\n\n}\n \nUFWiegandCommandCard\n;\n\n\n\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\nUF_ClearAllWiegandCommandCard\n\u00b6\n\n\nClears all the command card mappings.\n\n\nUF_RET_CODE UF_ClearAllWiegandCommandCard()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\n3.20. SmartCard API\n\u00b6\n\n\nBioEntry Smart readers support MIFARE types of smartcards. These functions provide basic functionalities such as read, write, and format smartcards.\n\n\n\n\nUF_ReadSmartCard: reads a smartcard.\n\n\nUF_ReadSmartCardWithAG: reads a smartcard with access group information.\n\n\nUF_WriteSmartCard: writes templates into a smartcard.\n\n\nUF_WriteSmartCardWithAG: writes templates and access group information into a smartcard.\n\n\nUF_WriteSmartCardWithEntranceLimit: writes templates, access group information, and entrance limit into a smartcard.\n\n\nUF_FormatSmartCard: formats a smartcard.\n\n\nUF_SetSmartCardMode: sets the operation mode.\n\n\nUF_GetSmartCardMode: gets the operation mode.\n\n\nUF_ChangePrimaryKey: changes the primary key.\n\n\nUF_ChangeSecondaryKey: changes the secondary key.\n\n\nUF_SetKeyOption: sets the site key options.\n\n\nUF_GetKeyOption: gets the site key options.\n\n\nUF_SetCardLayout: sets the layout of smartcard.\n\n\nUF_GetCardLayout: gets the layout of smartcard.\n\n\nUF_SetSmartCardCallback: sets the callback function for smartcard operation.\n\n\n\n\n\n\nUF_ReadSmartCard\n\u00b6\n\n\nReads a smart card.\n\n\nUF_RET_CODE UF_ReadSmartCard( UFCardHeader* header, BYTE* template1, BYTE* template2 )\n\n\nParameters\n\n\nheader\n\nUFCardHeader is defined as follows;\n\n\ntypedef\n \nstruct\n \n{\n\n    \nUINT32\n \ncsn\n;\n \n// 4 byte card serial number\n\n    \nUINT32\n \nwiegandLower\n;\n \n// lower 4 bytes of Wiegand string\n\n    \nUINT32\n \nwiegandHigher\n;\n// higher 4 bytes of Wiegand string\n\n    \nBYTE\n \nversion\n;\n\n    \nBYTE\n \ncommandType\n;\n \n// reserved for command cards. In V1.7 or\n\n                \n// later firmware, this field is used for\n\n                \n// storing entrance limit for non-command cards.\n\n    \nBYTE\n \nsecurityLevel\n;\n \n// security level of the user\n\n    \nBYTE\n \nnumOfTemplate\n;\n \n// number of templates stored\n\n                        \n// in the card\n\n    \nBYTE\n \ntemplate1Duress\n;\n \n// 1 if the template1 is\n\n                        \n// of duress finger\n\n    \nBYTE\n \ntemplate1Length\n[\n2\n];\n \n// length of template1\n\n    \nBYTE\n \ntemplate2Duress\n;\n\n    \nBYTE\n \ntemplate2Length\n[\n2\n];\n\n\n}\n \nUFCardHeader\n;\n\n\n\n\n\ntemplate1\n\nPointer to the first template data read from the smartcard.\n\ntemplate2\n\nPointer to the second template data read from the smartcard.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_ReadSmartCardWithAG\n\u00b6\n\n\nReads a smart card with access group information. As for access group, see \nUF_AddAccessGroup.\n\n\nUF_RET_CODE UF_ReadSmartCardWithAG( UFCardHeader* header, BYTE* template1, BYTE* template2, int* numOfAccessGroup, BYTE* accessGroup )\n\n\nParameters\n\n\nheader\n\nPointer to the UFCardHeader to be returned.\n\ntemplate1\n\nPointer to the first template data read from the smartcard.\n\ntemplate2\n\nPointer to the second template data read from the smartcard.\n\nnumOfAccessGroup\n\nPointer to the number of access groups assigned to the smartcard.\n\naccessGroup\n\nPointer to the IDs of access groups assigned to the smartcard. The length of each ID is 1 byte.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_WriteSmartCard\n\u00b6\n\n\nWrites template data and header information into a smartcard.\n\n\nUF_RET_CODE UF_WriteSmartCard( UINT32 userID, UF_CARD_SECURITY_LEVEL securityLevel, int numOfTemplate, int templateSize, BYTE* template1, BOOL duress1, BYTE* template2, BOOL duress2 )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\nsecurityLevel\n\nSecurity level. If it is set to UF_SECURITY_READER_DEFAULT, the security level is same as defined in the BioEntry reader. If it is set to UF_SECURITY_BYPASS, the BioEntry reader will bypass the fingerprint authentication.\n\nnumOfTemplate\n\nNumber of templates to be written.\n\ntemplateSize\n\nSize of a template.\n\ntemplate1\n\nPointer to the first template data.\n\nduress1\n\nSpecifies if the first template is of a duress finger.\n\ntemplate2\n\nPointer to the second template data.\n\nduress2\n\nSpecifies if the second template is of a duress finger.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_WriteSmartCardWithAG\n\u00b6\n\n\nWrites template data and access group information into a smartcard.\n\n\nUF_RET_CODE UF_WriteSmartCardWithAG( UINT32 userID, UF_CARD_SECURITY_LEVEL securityLevel, int numOfTemplate, int templateSize, BYTE* template1, BOOL duress1, BYTE* template2, BOOL duress2, int numOfAccessGroup, BYTE* accessGroup )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\nsecurityLevel\n\nSecurity level. If it is set to UF_SECURITY_READER_DEFAULT, the security level is same as defined in the BioEntry reader. If it is set to UF_SECURITY_BYPASS, the BioEntry reader will bypass the fingerprint authentication.\n\nnumOfTemplate\n\nNumber of templates to be written.\n\ntemplateSize\n\nSize of a template.\n\ntemplate1\n\nPointer to the first template data.\n\nduress1\n\nSpecifies if the first template is of a duress finger.\n\ntemplate2\n\nPointer to the second template data.\n\nduress2\n\nSpecifies if the second template is of a duress finger.\n\nnumOfAccessGroup\n\nNumber of access groups assigned to the smartcard.\n\naccessGroup\n\nPointer to the IDs of access group to be written.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_WriteSmartCardWithEntranceLimit\n\u00b6\n\n\nWrites template data, access group, and entrance limit information into a smartcard.\n\n\nUF_RET_CODE UF_WriteSmartCardWithEntranceLimit( UINT32 userID, UF_CARD_SECURITY_LEVEL securityLevel, int entranceLimit, int numOfTemplate, int templateSize, BYTE* template1, BOOL duress1, BYTE* template2, BOOL duress2, int numOfAccessGroup, BYTE* accessGroup )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\nsecurityLevel\n\nSecurity level. If it is set to UF_SECURITY_READER_DEFAULT, the security level is same as defined in the BioEntry reader. If it is set to UF_SECURITY_BYPASS, the BioEntry reader will bypass the fingerprint authentication.\n\nentranceLimit\n\nEntrance limit between 0 and 7.\n\nnumOfTemplate\n\nNumber of templates to be written.\n\ntemplateSize\n\nSize of a template.\n\ntemplate1\n\nPointer to the first template data.\n\nduress1\n\nSpecifies if the first template is of a duress finger.\n\ntemplate2\n\nPointer to the second template data.\n\nduress2\n\nSpecifies if the second template is of a duress finger.\n\nnumOfAccessGroup\n\nNumber of access groups assigned to the smartcard.\n\naccessGroup\n\nPointer to the IDs of access group to be written.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_FormatSmartCard\n\u00b6\n\n\nFormats a smartcard.\n\n\nUF_RET_CODE UF_FormatSmartCard( BOOL templateOnly )\n\n\nParameters\n\n\ntemplateOnly\n\nIf TRUE, erases only the template area and don\u2019t change the header\ninformation. If FALSE, erase the header information, too.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SetSmartCardMode\n\u00b6\n\n\nSets the operation mode of the BioEntry Smart reader.\n\n\nUF_RET_CODE UF_SetSmartCardMode( UF_CARD_MODE mode )\n\n\nParameters\n\n\nmode\n\nOperation mode.\n\n\n\n\n\n\n\n\nMode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUF_CARD_DISABLE\n\n\nDisables the smartcard operation.\n\n\n\n\n\n\nUF_CARD_VERIFY_ID\n\n\nAfter detecting a smartcard, verifies the fingerprint input with the templates stored in the BioEntry reader.\n\n\n\n\n\n\nUF_CARD_VERIFY_TEMPLATE\n\n\nAfter detecting a smartcard, verifies the fingerprint input with the templates stored in the card.\n\n\n\n\n\n\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetSmartCardMode\n\u00b6\n\n\nGets the operation mode.\n\n\nUF_RET_CODE UF_GetSmartCardMode( UF_CARD_MODE* mode )\n\n\nParameters\n\n\nmode\n\nPointer to the operation mode to be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_ChangePrimaryKey\n\u00b6\n\n\nTo prevent illegal access, MIFARE card is encrypted using 48bit site key. The site key should be handled with utmost caution. If it is disclosed, the data on the smartcard will not be secure any more. \nUF_ChangePrimaryKey\n is used to change the primary site key.\n\n\nUF_RET_CODE UF_ChangePrimaryKey( BYTE* oldPrimaryKey, BYTE* newPrimaryKey )\n\n\nParameters\n\n\noldPrimaryKey\n\nPointer to the old site key.\n\nnewPrimaryKey\n\nPointer to the new site key.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_ChangeSecondaryKey\n\u00b6\n\n\nChanges the secondary site key. The secondary site key is used only when the useSecondaryKey option is set by \nUF_SetKeyOption.\n\n\nUF_RET_CODE UF_ChangeSecondaryKey( BYTE* primaryKey, BYTE* newSecondaryKey )\n\n\nParameters\n\n\nprimaryKey\n\nPointer to the primary key.\n\nnewSecondaryKey\n\nPointer to the new secondary key.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_ChangeSecondaryKey\n\u00b6\n\n\nChanges the secondary site key. The secondary site key is used only when the useSecondaryKey option is set by \nUF_SetKeyOption.\n\n\nUF_RET_CODE UF_ChangeSecondaryKey( BYTE* primaryKey, BYTE* newSecondaryKey )\n\n\nParameters\n\n\nprimaryKey\n\nPointer to the primary key.\n\nnewSecondaryKey\n\nPointer to the new secondary key.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\nUF_SetKeyOption\n\u00b6\n\n\nWhen changing the site key, BioEntry readers have to handle cards with new site key and cards with old site key at the same time. In that case, useSecondaryKey option can be used. If the secondary key is set to old site key, the reader will handle both types of cards. If autoUpdate option is on, the reader automatically replaces the old site key with new one whenever detecting a smartcard with old key.\n\n\nUF_RET_CODE UF_SetKeyOption( BYTE* primaryKey, BOOL useSecondaryKey, BOOL autoUpdate )\n\n\nParameters\n\n\nprimaryKey\n\nPointer to the primary key.\n\nuseSecondaryKey\n\nIf TRUE, process the cards encrypted with the secondary key.\n\nautoUpdate\n\nIf TRUE, replace the secondary key with primary key when detecting a smartcard encrypted with the secondary key.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetKeyOption\n\u00b6\n\n\nGets the site key options.\n\n\nUF_RET_CODE UF_GetKeyOption( BOOL* useSecondaryKey, BOOL* autoUpdate )\n\n\nParameters\n\n\nuseSecondaryKey\n\nPointer to userSecondaryKey option.\n\nautoUpdate\n\nPointer to autoUpdate option.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SetCardLayout\n\u00b6\n\n\nChanges the layout of the smartcard. By default, a smartcard stores two fingerprint templates. If there are not sufficient spaces on the card, or some blocks of it are reserved for other data, users can change the layout using this function. Changing card layout should be handled with utmost caution. If you aren\u2019t sure what to do, contact to \nsupport@supremainc.com\n first before trying yourself.\n\n\nUF_RET_CODE UF_SetCardLayout( UFCardLayout* layout )\n\n\nParameters\n\n\nlayout\n\nPointer to the layout information. UFCardLayout is defined as follows;\n\n\ntypedef\n \nstruct\n \n{\n\n    \nunsigned\n \nshort\n    \ntemplateSize\n;\n\n    \nBYTE\n              \nheaderBlock\n;\n\n    \nBYTE\n              \ntemplate1StartBlock\n;\n\n    \nBYTE\n              \ntemplate1BlockSize\n;\n\n    \nBYTE\n              \ntemplate2StartBlock\n;\n\n    \nBYTE\n              \ntemplate2BlockSize\n;\n\n\n}\n \nUFCardLayout\n;\n\n\n\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetCardLayout\n\u00b6\n\n\nGets the card layout information.\n\n\nUF_RET_CODE UF_GetCardLayout( UFCardLayout* layout )\n\n\nParameters\n\n\nlayout\n\nPointer to UFCardLayout.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SetSmartCardCallback\n\u00b6\n\n\nSets the callback function for smartcard operation. This callback is called after scanning a smartcard successfully.\n\n\nvoid UF_SetSmartCardCallback( void (*callback)( BYTE ) )\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\n3.21. Access Control API\n\u00b6\n\n\nSince V1.6 firmware, BioEntry readers provide access control features such as time schedule and access group. By using these functions, user\u2019s access can be controlled in finer detail.\n\n\n\n\nUF_AddTimeSchedule: adds a time schedule.\n\n\nUF_GetTimeSchedule: reads the specified time schedule.\n\n\nUF_DeleteTimeSchedule: deletes a time schedule.\n\n\nUF_DeleteAllTimeSchedule: deletes all time schedules.\n\n\nUF_AddHoliday: adds a holiday schedule.\n\n\nUF_GetHoliday: reads the specified holiday schedule.\n\n\nUF_DeleteHoliday: deletes a holiday schedule.\n\n\nUF_DeleteAllHoliday: deletes all holiday schedules.\n\n\nUF_AddAccessGroup: adds an access group.\n\n\nUF_GetAccessGroup: reads the specified access group.\n\n\nUF_DeleteAccessGroup: deletes an access group.\n\n\nUF_DeleteAllAccessGroup: deletes all access groups.\n\n\nUF_SetUserAccessGroup: assigns access groups to a user.\n\n\nUF_GetUserAccessGroup: gets the access groups of a user.\n\n\n\n\n\n\nUF_AddTimeSchedule\n\u00b6\n\n\nA BioEntry reader can store up to 64 time schedules. Each time schedule consists of 7 daily schedules and an optional holiday schedule. And each daily schedule may have up to 5 time segments.\n\n\n#define UF_TIMECODE_PER_DAY       5\n\n\n\ntypedef\n \nstruct\n \n{\n\n    \nunsigned\n \nshort\n \nstartTime\n;\n \n// start time in minutes\n\n    \nunsigned\n \nshort\n \nendTime\n;\n \n// end time in minutes\n\n\n}\n \nUFTimeCodeElem\n;\n\n\n\ntypedef\n \nstruct\n \n{\n\n    \nUFTimeCodeElem\n \ncodeElement\n[\nUF_TIMECODE_PER_DAY\n];\n\n\n}\n \nUFTimeCode\n;\n\n\n\ntypedef\n \nstruct\n \n{\n\n    \nint\n \nscheduleID\n;\n\n    \nUFTimeCode\n \ntimeCode\n[\n7\n];\n \n// 0 - Sunday, 1 - Monday, ...\n\n    \nint\n \nholidayID\n;\n\n\n}\n \nUFTimeSchedule\n;\n\n\n\n\n\nUF_RET_CODE UF_AddTimeSchedule( UFTimeSchedule* schedule )\n\n\nParameters\n\n\nschedule\n\nPointer to the time schedule to be added.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\nExample\n\u00b6\n\n\nUFTimeSchedule\n \ntimeSchedule\n;\n\n\n\nmemset\n(\n \n&\ntimeSchedule\n,\n \n0\n,\n \nsizeof\n(\nUFTimeSchedule\n)\n \n);\n \n// clear the structure\n\n\n\ntimeSchedule\n.\nscheduleID\n \n=\n \n1\n;\n\n\ntimeSchedule\n.\nholidayID\n \n=\n \n1\n;\n\n\n\n// Monday- 09:00 ~ 18:00\n\n\ntimeSchedule\n.\ntimeCode\n[\n1\n].\ncodeElement\n[\n0\n].\nstartTime\n \n=\n \n9\n \n*\n \n60\n;\n\n\ntimeSchedule\n.\ntimeCode\n[\n1\n].\ncodeElement\n[\n0\n].\nendTime\n \n=\n \n18\n \n*\n \n60\n;\n\n\n\n// Tuesday- 08:00 ~ 12:00 and 14:30 ~ 20:00\n\n\ntimeSchedule\n.\ntimeCode\n[\n2\n].\ncodeElement\n[\n0\n].\nstartTime\n \n=\n \n8\n \n*\n \n60\n;\n\n\ntimeSchedule\n.\ntimeCode\n[\n2\n].\ncodeElement\n[\n0\n].\nendTime\n \n=\n \n12\n \n*\n \n60\n;\n\n\ntimeSchedule\n.\ntimeCode\n[\n2\n].\ncodeElement\n[\n1\n].\nstartTime\n \n=\n \n14\n \n*\n \n60\n \n+\n \n30\n;\n\n\ntimeSchedule\n.\ntimeCode\n[\n2\n].\ncodeElement\n[\n1\n].\nendTime\n \n=\n \n20\n \n*\n \n60\n;\n\n\n\n// \u2026\n\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_AddTimeSchedule\n(\n \n&\ntimeSchedule\n \n);\n\n\n\n\n\n\n\nUF_GetTimeSchedule\n\u00b6\n\n\nReads the specified time schedule.\n\n\nUF_RET_CODE UF_GetTimeSchedule( int ID, UFTimeSchedule* schedule )\n\n\nParameters\n\n\nID\n\nID of the time schedule.\n\nschedule\n\nPointer to the time schedule to be read.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_DeleteTimeSchedule\n\u00b6\n\n\nDeletes the specified time schedule.\n\n\nUF_RET_CODE UF_DeleteTimeSchedule( int ID )\n\n\nParameters\n\n\nID\n\nID of the time schedule.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_DeleteAllTimeSchedule\n\u00b6\n\n\nDeletes all the time schedules stored in a BioEntry reader.\n\n\nUF_RET_CODE UF_DeleteAllTimeSchedule()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the\ncorresponding error code.\n\n\n\n\nUF_AddHoliday\n\u00b6\n\n\nEach time schedule may have an optional holiday schedule. A holiday schedule consists of a holiday list and a daily schedule for it.\n\n\ntypedef\n \nstruct\n \n{\n\n    \nint\n \nholidayID\n;\n\n    \nint\n \nnumOfHoliday\n;\n\n    \nunsigned\n \nshort\n \nholiday\n[\n32\n];\n \n// (month << 8) | day\n\n    \nUFTimeCode\n \ntimeCode\n;\n\n\n}\n \nUFHoliday\n;\n\n\n\n\n\nUF_RET_CODE UF_AddHoliday( UFHoliday* holiday )\n\n\nParameters\n\n\nholiday\n\nPointer to the holiday schedule to be added.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\nExample\n\u00b6\n\n\nUFHoliday\n \nholiday\n;\n\n\n\nmemset\n(\n \n&\nholiday\n,\n \n0\n,\n \nsizeof\n(\nUFHoliday\n)\n \n);\n \n// clear the structure\n\n\n\nholiday\n.\nholidayID\n \n=\n \n1\n;\n\n\nholiday\n.\nnumOfHoliday\n \n=\n \n10\n;\n\n\n\n// Jan. 1 is holiday\n\n\nholiday\n.\nholiday\n[\n0\n]\n \n=\n \n(\n1\n \n<<\n \n8\n)\n \n|\n \n1\n;\n\n\n\n// Mar. 5 is holiday\n\n\nholiday\n.\nholiday\n[\n1\n]\n \n=\n \n(\n3\n \n<<\n \n8\n)\n \n|\n \n5\n;\n\n\n\n// \u2026\n\n\n\n// Access is granted during 09:00 ~ 10:00 on holideys\n\n\nholiday\n.\ntimeCode\n.\ncodeElement\n[\n0\n].\nstartTime\n \n=\n \n9\n \n*\n \n60\n;\n\n\nholiday\n.\ntimeCode\n.\ncodeElement\n[\n0\n].\nendTime\n \n=\n \n10\n \n*\n \n60\n;\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_AddHoliday\n(\n \n&\nholiday\n \n);\n\n\n\n\n\n\n\nUF_GetHoliday\n\u00b6\n\n\nReads the specified holiday schedule.\n\n\nUF_RET_CODE UF_GetHoliday( int ID, UFHoliday* holiday )\n\n\nParameters\n\n\nID\n\nID of the holiday schedule.\n\nholiday\n\nPointer to the holiday schedule to be read.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_DeleteHoliday\n\u00b6\n\n\nDeletes the specified holiday schedule.\n\n\nUF_RET_CODE UF_DeleteHoliday( int ID )\n\n\nParameters\n\n\nID\n\nID of the holiday schedule.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_DeleteAllHoliday\n\u00b6\n\n\nDeletes all the holiday schedules stored in a BioEntry reader.\n\n\nUF_RET_CODE UF_DeleteAllHoliday()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_AddAccessGroup\n\u00b6\n\n\nEach access group may have up to 16 time schedules. The access of members is granted only when the time belongs to the time schedules of the group.\n\n\n#define UF_SCHEDULE_PER_GROUP    16\n\n\n\ntypedef\n \nstruct\n \n{\n\n    \nint\n \ngroupID\n;\n\n    \nint\n \nnumOfSchedule\n;\n\n    \nint\n \nscheduleID\n[\nUF_SCHEDULE_PER_GROUP\n];\n\n\n}\n \nUFAccessGroup\n;\n\n\n\n\n\nUF_RET_CODE UF_AddAccessGroup( UFAccessGroup* group )\n\n\nParameters\n\n\ngroup\n\nPointer to the access group to be added.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetAccessGroup\n\u00b6\n\n\nReads the specified access group.\n\n\nUF_RET_CODE UF_GetAccessGroup( int ID, UFAccessGroup* group )\n\n\nParameters\n\n\nID\n\nID of the access group.\n\ngroup\n\nPointer to the access group to be read.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_DeleteAccessGroup\n\u00b6\n\n\nDeletes the specified access group.\n\n\nUF_RET_CODE UF_DeleteAccessGroup( int ID )\n\n\nParameters\n\n\nID\n\nID of the access group.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_DeleteAllAccessGroup\n\u00b6\n\n\nDeletes all the access groups stored in a BioEntry reader.\n\n\nUF_RET_CODE UF_DeleteAllAccessGroup()\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_SetUserAccessGroup\n\u00b6\n\n\nAssigns access groups to a user. A user can be a member of up to 4 access groups.\n\n\nUF_RET_CODE UF_SetUserAccessGroup( UINT32 userID, int numOfGroup, int* groupID )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\nnumOfGroup\n\nNumber of access groups to be assigned.\n\ngroupID\n\nArray of access group IDs to be assigned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetUserAccessGroup\n\u00b6\n\n\nReads the IDs of access groups assigned to a user.\n\n\nUF_RET_CODE UF_GetUserAccessGroup( UINT32 userID, int* numOfGroup, int* groupID )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\nnumOfGroup\n\nPointer to the number of access groups to be returned.\n\ngroupID\n\nArray of access group IDs to be returned.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\n3.22. Blacklist API\n\u00b6\n\n\nWhen a user ID is added to the blacklist, authentication will always fail regardless of fingerprint matching result. The blacklist takes precedence over the authentication type of a user. For example, though the authentication mode of a user is UF_AUTH_BYPASS, the authentication would fail if it is in the blacklist. The blacklist can store up to 1022 user IDs.\n\n\n\n\nUF_AddBlacklist: adds an ID to the blacklist.\n\n\nUF_DeleteBlacklist: deletes an ID from the blacklist.\n\n\nUF_GetBlacklist: reads the IDs in the blacklist.\n\n\nUF_DeleteAllBlacklist: clears the blacklist.\n\n\n\n\n\n\nUF_AddBlacklist\n\u00b6\n\n\nAdds a user ID to the blacklist.\n\n\nUF_RET_CODE UF_AddBlacklist( UINT32 userID, int* numOfBlacklistedID )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\nnumOfBlacklistedID\n\nNumber of IDs in the blacklist after adding.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_DeleteBlacklist\n\u00b6\n\n\nDeletes an ID from the blacklist.\n\n\nUF_RET_CODE UF_DeleteBlacklist( UINT32 userID, int* numOfBlacklistedID )\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\nnumOfBlacklistedID\n\nNumber of IDs in the blacklist after deleting.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_GetBlacklist\n\u00b6\n\n\nReceive user IDs in the blacklist.\n\n\nUF_RET_CODE UF_GetBlacklist( int* numOfBlacklistedID, UINT32* userID )\n\n\nParameters\n\n\nnumOfBlacklistedID\n\nPointer to the number of IDs in the blacklist.\n\nuserID\n\nArray of user IDs in the blacklist. This should be pre-allocated large enough.\n\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\nUF_DeleteAllBlacklist\n\u00b6\n\n\nClears the blacklist.\n\n\nUF_RET_CODE UF_DeleteAllBlacklist()\n\n\nParameters\n\nNone\n\nReturn Values\n\nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.\n\n\n\n\n3.23. WSQ API\n\u00b6\n\n\n\n\nUF_ScanImageEx\n\u00b6\n\n\n\n\nUF_ReadImageEx\n\u00b6\n\n\n\n\nUF_WSQ_Decode\n\u00b6\n\n\n\n\nContact Info\n\u00b6\n\n\n\n\nHeadquarters\n\n\n\n\nSuprema, Inc. (\nhttp://www.supremainc.com\n)\n16F Parkview Office Tower,\nJoengja-dong, Bundang-gu,\nSeongnam, Gyeonggi, 463-863 Korea\nTel: +82-31-783-4505\nFax:+82-31-783-4506\nEmail: \nsales@supremainc.com\n, \nsupport@supremainc.com",
            "title": "API Specification"
        },
        {
            "location": "/documents/API_Specification/#3-api-specification",
            "text": "",
            "title": "3. API Specification"
        },
        {
            "location": "/documents/API_Specification/#31-return-codes",
            "text": "Most APIs in the SDK return UF_RET_CODE. The return codes and their meanings are as follows;     Category  Code  Description      Success  UF_RET_SUCCESS  The function succeeds.    Serial Comm.  UF_ERR_CANNOT_OPEN_SEREIAL  Cannot open the specified serial port.     UF_ERR_CANNOT_SETUP_SERIAL  Cannot set the baud rate.     UF_ERR_CANNOT_WRITE_SERIAL  Cannot write data to the serial port.     UF_ERR_WRITE_SERIAL_TIMEOUT  Write timeout.     UF_ERR_CANNOT_READ_SERIAL  Cannot read data from the serial port.     UF_ERR_READ_SERIAL_TIMEOUT  Read timeout.     UF_ERR_CHECKSUM_ERROR  Received packet has wrong checksum.     UF_ERR_CANNOT_SET_TIMEOUT  Cannot set communication timeout.    Socket  UF_ERR_CANNOT_START_SOCKET  Cannot initialize the socket interface.     UF_ERR_CANNOT_OPEN_SOCKET  Cannot open the socket.     UF_ERR_CANNOT_CONNECT_SOCKET  Cannot connect to the socket.     UF_ERR_CANNOT_READ_SOCKET  Cannot read data from the socket.     UF_ERR_READ_SOCKET_TIMEOUT  Read timeout.     UF_ERR_CANNOT_WRITE_SOCKET  Cannot write data to the socket.     UF_ERR_WRITE_SOCKET_TIMEOUT  Write timeout.    Protocol  UF_ERR_SCAN_FAIL  Sensor or fingerprint input has failed.     UF_ERR_NOT_FOUND  Identification failed, or the requested data is not found.     UF_ERR_NOT_MATCH  Fingerprint does not match.     UF_ERR_TRY_AGAIN  Fingerprint image is not good.     UF_ERR_TIME_OUT  Timeout for fingerprint input.     UF_ERR_MEM_FULL  No more templates are allowed.     UF_ERR_EXIST_ID  The specified user ID already exists.     UF_ERR_FINGER_LIMIT  The number of fingerprints enrolled in same ID exceeds its limit.     UF_ERR_UNSUPPORTED  The command is not supported.     UF_ERR_INVALID_ID  The requested user ID is invalid or missing.     UF_ERR_TIMEOUT_MATCH  Timeout for fingerprint identification.     UF_ERR_BUSY  Module is processing another command.     UF_ERR_CANCELED  The command is canceled.     UF_ERR_DATA_ERROR  The checksum of a data packet is incorrect.     UF_ERR_EXIST_FINGER  The finger is already enrolled.     UF_ERR_DURESS_FINGER  A duress finger is detected.     UF_ERR_CARD_ERROR  Cannot read a smart card.     UF_ERR_LOCKED  Module is locked.     UF_ERR_ACCESS_NOT_GRANTED  Access is not granted by time schedule and access group.     UF_ERR_REJECTED_ID  Authentication type of the user is UF_AUTH_REJECT or the ID is in the blacklist.     UF_ERR_FAKE_DETECTED  Scanned finger is determined as a fake finger.     UF_ERR_EXCEED_ENTRANCE_LIMIT  Entrance limit is exceeded.    Application  UF_ERR_OUT_OF_MEMORY  Out of memory.     UF_ERR_INVALID_PARAMETER  Invalid parameter.     UF_ERR_FILE_IO  File I/O failed     UF_ERR_INVALID_FILE  The configuration or DB file is invalid.",
            "title": "3.1. Return Codes"
        },
        {
            "location": "/documents/API_Specification/#32-serial-communication-api",
            "text": "To communicate with SFM modules, users should configure the serial port first.   UF_InitCommPort: configures serial port parameters.  UF_CloseCommPort: closes the serial port.  UF_Reconnect: resets system parameters and IO settings.  UF_SetBaudrate: changes the baud rate.  UF_SetAsciiMode: changes the packet translation mode.",
            "title": "3.2. Serial Communication API"
        },
        {
            "location": "/documents/API_Specification/#uf_initcommport",
            "text": "Opens a serial port and configures communication parameters. This function should be called first before calling any other APIs.  UF_RET_CODE UF_InitCommPort( const char* commPort, int baudrate, BOOL asciiMode )  Parameters     commPort \nPointer to a null-terminated string that specifies the name of the serial port.    baudrate \nSpecifies the baud rate at which the serial port operates. Available baud rates are 9600, 19200, 38400, 57600, 115200bps (230400bps and 460800bps are available in later version of 5.0). The default setting of SFM modules is 115200bps.    asciiMode \nDetermines the packet translation mode. If it is set to TRUE, the binary packet is converted to ASCII format first before being sent to the module. Response packets are in ASCII format, too. The default setting of SFM modules is binary mode.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.    Example  UF_RET_CODE   result   =   UF_InitCommPort (   \u201c COM1 \u201d ,   115200 ,   FALSE   );",
            "title": "UF_InitCommPort"
        },
        {
            "location": "/documents/API_Specification/#uf_closecommport",
            "text": "Closes the serial port opened by  UF_InitCommPort.  UF_RET_CODE UF_CloseCommPort()  Parameters \nNone  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_CloseCommPort"
        },
        {
            "location": "/documents/API_Specification/#uf_reconnect",
            "text": "To improve communication efficiency, the SDK caches basic information of a module such as system parameters and I/O settings.  UF_Reconnect  clears this cached information. When changing the modules connected to the serial port, this function should be called.  void UF_Reconnect()  Parameters \nNone  Return Values \nNone",
            "title": "UF_Reconnect"
        },
        {
            "location": "/documents/API_Specification/#uf_setbaudrate",
            "text": "Changes the baud rate.  UF_RET_CODE UF_SetBaudrate( int baudrate )  Parameters  baudrate \nSpecifies the baud rate at which the serial port operates. Available baud rates are 9600, 19200, 38400, 57600, 115200bps. The default setting of SFM modules is 115200bps.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the\ncorresponding error code.",
            "title": "UF_SetBaudrate"
        },
        {
            "location": "/documents/API_Specification/#uf_setasciimode",
            "text": "Changes the packet translation mode.  void UF_SetAsciiMode( BOOL asciiMode )  Parameters  asciiMode \nTRUE for ascii format, FALSE for binary format.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetAsciiMode"
        },
        {
            "location": "/documents/API_Specification/#33-socket-api",
            "text": "In addition to serial ports, users can connect to the module by Ethernet-to-Serial converters. In this case, socket API should be used in place of serial API.   UF_InitSocket: opens a socket and connects to the specified IP address.  UF_CloseSocket: closes the socket.",
            "title": "3.3. Socket API"
        },
        {
            "location": "/documents/API_Specification/#uf_initsocket",
            "text": "Initializes the socket interface and connects to the module with specified IP address.  UF_RET_CODE UF_InitSocket( const char* inetAddr, int port, BOOL asciiMode )  Parameters  inetAddr \nIP address of the Ethernet-to-Serial converter. port \nTCP port of the socket interface. asciiMode \nDetermines the packet translation mode. If it is set to TRUE, the binary packet is converted to ASCII format first before being sent to the module. Response packets are in ASCII format, too. The default setting of SFM modules is binary mode.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_InitSocket"
        },
        {
            "location": "/documents/API_Specification/#example",
            "text": "UF_RET_CODE   result   =   UF_InitSocket (   \u201c 192.168.1.41 \u201d ,   1470 ,   FALSE   );",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_closesocket",
            "text": "Closes the socket interface.  UF_RET_CODE UF_CloseSocket()  Parameters \nNone  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_CloseSocket"
        },
        {
            "location": "/documents/API_Specification/#34-low-level-packet-api",
            "text": "These functions provide direct interface to the low-level packet exchanges. In most cases, users need not to call these functions directly. Command API and other high level APIs are implemented on top of this API.\nPacket API also let users set callback functions for data transfer. Examples of using these callback functions for GUI application can be found in UniFingerUI V4.0 source codes.   UF_SendPacket: sends a 13 byte packet.  UF_SendNetworkPacket: sends a 15 byte network packet.  UF_ReceivePacket: receives a 13 byte packet.  UF_ReceiveNetworkPacket: receives a 15 byte network packet.  UF_SendRawData: sends raw data.  UF_ReceiveRawData: receives raw data.  UF_SendDataPacket: sends data using Extended Data Transfer Protocol.  UF_ReceiveDataPacket: receives data using Extended Data Transfer Protocol.  UF_SetSendPacketCallback: sets the callback function of sending packets.  UF_SetReceivePacketCallback: sets the callback function of receiving packets.  UF_SetSendDataPacketCallback: sets the callback function of sending data packets.  UF_SetReceiveDataPacketCallback: sets the callback function of receiving data packets.  UF_SetSendRawDataCallback: sets the callback function of sending raw data.  UF_SetReceiveRawDataCallback: sets the callback function of receiving raw data.  UF_SetDefaultPacketSize: sets the size of data packets.  UF_GetDefaultPacketSize: gets the size of data packets.",
            "title": "3.4. Low-Level Packet API"
        },
        {
            "location": "/documents/API_Specification/#uf_sendpacket",
            "text": "Sends a 13 byte packet to the module. The packet is composed as follows;     Start code  Command  Param  Size  Flag/Error  Checksum  End code      1byte  1byte  4bytes  4bytes  1byte  1byte  1byte      Start code: 1 byte. Indicates the beginning of a packet. It always should be 0x40.  Command: 1 byte. Refer to the Packet Protocol Manual for available commands.  Param: 4 bytes. The meaning of this field varies according to each command.  Size: 4 bytes. The meaning of this field varies according to each command.  Flag/Error: 1 byte. Indicates flag data in the request packet, and error code in the response packet.  Checksum: 1 byte. Checks the validity of a packet. Checksum is a remainder of the sum of each field, from the Start code to Flag/Error, divided by 256 (0x100).  End code: 1 byte. Indicates the end of a packet. It always should be 0x0A. It is also used as a code indicating the end of binary data such as fingerprint templates.   UF_RET_CODE UF_SendPacket( BYTE command, UINT32 param, UINT32 size, BYTE flag, int timeout )  Parameters  command \nCommand field of a packet. Refer to the Packet Protocol Manual for available commands. param \nParam field of a packet. size \nSize field of a packet. flag \nFlag field of a packet. timeout \nSets the timeout in milliseconds. If sending does not complete within this limit, UF_ERR_WRITE_SERIAL_TIMEOUT will be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SendPacket"
        },
        {
            "location": "/documents/API_Specification/#example_1",
            "text": "// To send ES command with user ID 10 and ADD_NEW(0x79) option,  UF_RET_CODE   result   =   UF_SendPacket (   UF_COM_ES ,   10 ,   0 ,   0x79 ,   2000   );  If (   result   !=   UF_RET_SUCCESS   )  { \n     Return   result ;  }",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_sendnetworkpacket",
            "text": "Sends a 15 byte network packet to the specified module. In order to support RS422 or RS485 network interfaces, SFM modules support Network Packet Protocol. Network packet is composed of 15 bytes, whose start code is different from the standard packet, and includes 2 bytes for terminal ID. The terminal ID is equal to the lower 2 bytes of Module ID of system parameter.     Field  Start code  Terminal ID  Command  Param  Size  Flag / Error  Checksum  End code      Bytes  1  2  1  4  4  1  1  1    Value  0x41  1 ~ 0xFFFF    Same as standard protocol   Checksum of 13 bytes  0x0A     UF_SendNetworkPacket( BYTE command, USHORT terminalID, UINT32 param, UINT32 size, BYTE flag, int timeout )  Parameters     command \nCommand field of a packet. Refer to the Packet Protocol Manual for available commands. terminalID \nSpecifies the terminal ID of the receiving module. param \nParam field of a packet. size \nSize field of a packet. flag \nFlag field of a packet. timeout \nSets the timeout in milliseconds. If sending does not complete within this limit, UF_ERR_WRITE_SERIAL_TIMEOUT will be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SendNetworkPacket"
        },
        {
            "location": "/documents/API_Specification/#uf_receivepacket",
            "text": "Receives a 13 byte packet from the module. Most commands of Packet Protocol can be implemented by a pair of  UF_SendPacket/UF_ReceivePacket  or  UF_SendNetworkPacket/UF_ReceiveNetworkPacket.  UF_RET_CODE UF_ReceivePacket( BYTE* packet, int timeout )  Parameters  packet \nPointer to the 13 byte packet. timeout \nSets the timeout in milliseconds. If receiving does not complete within this limit, UF_ERR_READ_SERIAL_TIMEOUT will be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ReceivePacket"
        },
        {
            "location": "/documents/API_Specification/#uf_receivenetworkpacket",
            "text": "Receives a 15 byte network packet from the specified module.  UF_ReceiveNetworkPacket( BYTE* packet, int timeout )  Parameters  packet \nPointer to the 15 byte packet. timeout \nSets the timeout in milliseconds. If receiving does not complete within this limit, UF_ERR_READ_SERIAL_TIMEOUT will be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ReceiveNetworkPacket"
        },
        {
            "location": "/documents/API_Specification/#uf_sendrawdata",
            "text": "Some commands such as ET(Enroll Template) and IT(Identify Template) send additional data after the 13/15 byte request packet.  UF_SendRawData  is used in these cases for sending the data.  UF_RET_CODE UF_SendRawData( BYTE* buf, UINT32 size, int timeout )  Parameters  buf \nPointer to a data buffer. size \nNumber of bytes to be sent. timeout \nSets the timeout in milliseconds. If sending does not complete within this limit, UF_ERR_WRITE_SERIAL_TIMEOUT will be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SendRawData"
        },
        {
            "location": "/documents/API_Specification/#uf_receiverawdata",
            "text": "Some commands such as ST(Scan Template) and RT(Read Template) return additional data after the 13/15 byte response packet.  UF_ReceiveRawData  is used in these cases for receiving the data.  UF_RET_CODE UF_ReceiveRawData( BYTE* buf, UINT32 size, int timeout, BOOL checkEndCode )  Parameters  buf \nPointer to a data buffer. size \nNumber of bytes to be received. timeout \nSets the timeout in milliseconds. If receiving does not complete within this limit, UF_ERR_READ_SERIAL_TIMEOUT will be returned. checkEndCode \nData transfer ends with \u20180x0a\u2019. If this parameter is FALSE, the function returns without checking the end code.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ReceiveRawData"
        },
        {
            "location": "/documents/API_Specification/#uf_senddatapacket",
            "text": "Sends data using Extended Data Transfer Protocol. Dividing large data into small blocks can reduce communication errors between the host and the module. Extended Data Transfer Protocol is an extension of Packet Protocol to provide a reliable and customizable communication for large data. In Extended Data Transfer Protocol, data is divided into multiple data packets. And a data packet consists of fixed-length header, variable-length data body, and 4 byte checksum. Commands which use the Extended Data Transfer Protocols are EIX, VIX, IIX, RIX, SIX, and UG.  UF_SendDataPacket( BYTE command, BYTE* buf, UINT32 dataSize, UINT32 dataPacketSize )  Parameters  command \nCommand field of a packet. Valid commands are EIX, VIX, IIX, RIX, SIX, and UG. buf \nPointer to a data buffer. dataSize \nNumber of bytes to be sent. dataPacketSize \nSize of data packet. For example, if dataSize is 16384 bytes and dataPacketSize is 4096 bytes, the data will be divided into 4 data packets.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SendDataPacket"
        },
        {
            "location": "/documents/API_Specification/#uf_receivedatapacket",
            "text": "Receives data using Extended Data Transfer Protocol. The size of data packet should be specified before calling this function.  UF_ReceiveDataPacket( BYTE command, BYTE* buf, UINT32 dataSize )  Parameters  command \nCommand field of a packet. Valid commands are EIX, VIX, IIX, RIX, SIX, and UG. buf \nPointer to a data buffer. dataSize \nNumber of bytes to be received.  Return Values     If the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ReceiveDataPacket"
        },
        {
            "location": "/documents/API_Specification/#uf_setsendpacketcallback",
            "text": "If  SendPacketCallback  is specified, it is called after sending a packet successfully. The argument of the callback is the pointer to the packet.  void UF_SetSendPacketCallback( void (*callback)( BYTE* ) )  Parameters  callback \nPointer to the callback function.  Return Values \nNone",
            "title": "UF_SetSendPacketCallback"
        },
        {
            "location": "/documents/API_Specification/#example_2",
            "text": "See CMainFrame::SendPacketCallback in UniFingerUI source codes.",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_setreceivepacketcallback",
            "text": "If  ReceivePacketCallback  is specified, it is called after receiving a packet successfully. The argument of the callback is the pointer to the received packet.  void UF_SetReceivePacketCallback( void (*callback)( BYTE* ) )  Parameters  callback \nPointer to the callback function.  Return Values \nNone",
            "title": "UF_SetReceivePacketCallback"
        },
        {
            "location": "/documents/API_Specification/#example_3",
            "text": "See CMainFrame::ReceivePacketCallback in UniFingerUI source codes.",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_setsenddatapacketcallback",
            "text": "If  SendDataPacketCallback  is specified, it is called after sending a data packet successfully. The argument of the callback is the index of the data packet and the number of total data packets.  UF_SetSendDataPacketCallback( void (*callback)( int index, int numOfPacket ) )  Parameters  callback \nPointer to the callback function.  Return Values \nNone",
            "title": "UF_SetSendDataPacketCallback"
        },
        {
            "location": "/documents/API_Specification/#example_4",
            "text": "See CMainFrame::DataPacketCallback in UniFingerUI source codes.",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_setreceivedatapacketcallback",
            "text": "If  ReceiveDataPacketCallback  is specified, it is called after receiving a data packet successfully. The argument of the callback is the index of the data packet and the number of total data packets.  void UF_SetReceiveDataPacketCallback( void (*callback)( int index, int numOfPacket ) )  Parameters  callback \nPointer to the callback function.  Return Values \nNone",
            "title": "UF_SetReceiveDataPacketCallback"
        },
        {
            "location": "/documents/API_Specification/#example_5",
            "text": "See CMainFrame::DataPacketCallback in UniFingerUI source codes.",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_setsendrawdatacallback",
            "text": "If  SendRawDataCallback  is specified, it is called during sending raw data. The argument of the callback is the written length and the total length of data.  void UF_SetSendRawDataCallback( void (*callback)( int writtenLen, int totalSize ) )  Parameters  callback \nPointer to the callback function.  Return Values \nNone",
            "title": "UF_SetSendRawDataCallback"
        },
        {
            "location": "/documents/API_Specification/#example_6",
            "text": "See CMainFrame::RawDataCallback in UniFingerUI source codes.",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_setreceiverawdatacallback",
            "text": "If  ReceiveRawDataCallback  is specified, it is called during receiving data. The argument of the callback is the read length and the total length of data.  void UF_SetReceiveRawDataCallback( void (*callback)( int readLen, int totalSize ) )  Parameters  callback \nPointer to the callback function.  Return Values \nNone",
            "title": "UF_SetReceiveRawDataCallback"
        },
        {
            "location": "/documents/API_Specification/#example_7",
            "text": "See CMainFrame::RawDataCallback in UniFingerUI source codes.",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_setdefaultpacketsize",
            "text": "Sets the size of data packets used in Extended Data Transfer protocol. The default value is 4096. When BEACon is used as an Ethernet-to-Serial converter, this value should not be larger than 256. void UF_SetDefaultPacketSize( int defaultSize )  Parameters  defaultSize \nSize of data packet.  Return Values \nNone",
            "title": "UF_SetDefaultPacketSize"
        },
        {
            "location": "/documents/API_Specification/#uf_getdefaultpacketsize",
            "text": "Returns the size of data packet used in Extended Data Transfer protocol.  int UF_GetDefaultPacketSize()  Parameters \nNone  Return Values \nThe size of data packet.",
            "title": "UF_GetDefaultPacketSize"
        },
        {
            "location": "/documents/API_Specification/#35-generic-command-api",
            "text": "The commands defined in the Packet Protocol Manual can be classified into several categories according to the types of packet exchange. Generic Command API provides functions which encapsulate these categories. Like low-level Packet API, users need not to call these functions directly. Most commands have corresponding high-level API in the SDK.   UF_Command: encapsulates the commands composed of one request packet and one response packet.  UF_CommandEx: encapsulates the commands composed of one request packet and multiple response packets.  UF_CommandSendData: encapsulates the commands which send additional data after a request packet.  UF_CommandSendDataEx: encapsulates the commands which send additional data and have multiple response packets.  UF_Cancel: cancels the previously issued command.  UF_SetProtocol: sets the type of packet protocol.  UF_GetProtocol: gets the type of packet protocol.  UF_GetModuleID: gets the module ID.  UF_SetGenericCommandTimeout: sets the timeout for generic commands.  UF_SetInputCommandTimeout: sets the timeout for commands which require user inputs.  UF_GetGenericCommandTimeout: gets the timeout for generic commands.  UF_GetInputCommandTimeout: gets the timeout for commands which   require user inputs.  UF_SetNetworkDelay: sets the delay for the Network Packet Protocol.  UF_GetNetworKDelay: gets the delay for the Network Packet Protocol.",
            "title": "3.5. Generic Command API"
        },
        {
            "location": "/documents/API_Specification/#uf_command",
            "text": "Encapsulates the commands composed of one request packet and one response packet. The majority of commands can be implemented using  UF_Command.  UF_RET_CODE UF_Command( BYTE command, UINT32* param, UINT32* size, BYTE* flag )  Parameters  command \nCommand field of a packet. Refer to the Packet Protocol Manual for available commands. param \nParam field of a packet. This parameter is used both for input and output. size \nSize field of a packet. This parameter is used both for input and output. flag \nFlag field of a packet. This parameter is used both for input and output.  Return Values \nIf packets are transferred successfully, return UF_RET_SUCCESS. Otherwise, return the corresponding error code. UF_RET_SUCCESS only means that request packet is received successfully. To know if the operation succeeds, the flag field should be checked.",
            "title": "UF_Command"
        },
        {
            "location": "/documents/API_Specification/#example_8",
            "text": "// To read Timeout(0x62) system parameter,  UINT32   param   =   0 ;  UINT32   size   =   0 ;  BYTE   flag   =   0x62 ;  UINT32   timeout ;  UF_RET_CODE   result   =   UF_Command (   UF_COM_SR ,   & param ,   & size ,   & flag   );  If (   result   !=   UF_RET_SUCCESS   )   // communication error  { \n     return   result ;  }  If (   flag   !=   UF_PROTO_RET_SUCCESS   )   // protocol error  { \n     return   UF_GetErrorCode (   result   );  }  // succeed  timeout   =   size ;",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_commandex",
            "text": "Encapsulates the commands composed of one request packet and multiple response packets. Command such as ES(Enroll) and IS(Identify) can have more than one response packet. To handle these cases,  UF_CommandEx  requires a message callback function, which should return TRUE when the received packet is the last one.  UF_RET_CODE UF_CommandEx( BYTE command, UINT32* param, UINT32* size, BYTE* flag, BOOL (*msgCallback)(BYTE) )  Parameters  command \nCommand field of a packet. Refer to the Packet Protocol Manual for available commands. param \nParam field of a packet. This parameter is used both for input and output. size \nSize field of a packet. This parameter is used both for input and output. flag \nFlag field of a packet. This parameter is used both for input and output. msgCallback \nPointer to the callback function. This callback is called when a response packet is received. If the callback return TRUE,  UF_CommandEx  will return immediately. If the callback return FALSE,  UF_CommandEx  will wait for another response packet.  Return Values \nIf packets are transferred successfully, return UF_RET_SUCCESS. Otherwise, return the corresponding error code. UF_RET_SUCCESS only means that request packet is received successfully. To know if the operation succeeds, the flag field should be checked.",
            "title": "UF_CommandEx"
        },
        {
            "location": "/documents/API_Specification/#example_9",
            "text": "// UF_Identify() is implemented as follows;  /**  * Message callback for identification  */  BOOL   UF_IdentifyMsgCallback (   BYTE   errCode   )  { \n     if (   errCode   ==   UF_PROTO_RET_SCAN_SUCCESS   ) \n     { \n         if (   s_IdentifyCallback   ) \n         { \n             ( * s_IdentifyCallback )(   errCode   ); \n         } \n         return   FALSE ; \n     } \n     else \n     { \n         return   TRUE ; \n     }  }  /**  * Identify  */  UF_RET_CODE   UF_Identify (   UINT32 *   userID ,   BYTE *   subID   )  { \n     UINT32   param   =   0 ; \n     UINT32   size   =   0 ; \n     BYTE   flag   =   0 ; \n\n     int   result   =   UF_CommandEx (   UF_COM_IS ,   & param ,   & size ,   & flag , \n     UF_IdentifyMsgCallback   ); \n\n     if (   result   !=   UF_RET_SUCCESS   ) \n     { \n         return   result ; \n     } \n     else   if (   flag   !=   UF_PROTO_RET_SUCCESS   ) \n     { \n         return   UF_GetErrorCode (   flag   ); \n     } \n     * userID   =   param ; \n     * subID   =   size ; \n\n     return   UF_RET_SUCCESS ;  }",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_commandsenddata",
            "text": "Encapsulates the commands which send additional data after a request packet. For example, GW(Write GPIO Configuration) command should send configuration data after the request packet.  UF_RET_CODE UF_CommandSendData( BYTE command, UINT32* param, UINT32* size, BYTE* flag, BYTE* data, UINT32 dataSize )  Parameters  command \nCommand field of a packet. Refer to the Packet Protocol Manual for available commands. param \nParam field of a packet. This parameter is used both for input and output. size \nSize field of a packet. This parameter is used both for input and output. flag \nFlag field of a packet. This parameter is used both for input and output. data \nPointer to the data buffer to be sent. dataSize \nNumber of bytes to be sent.  Return Values \nIf packets are transferred successfully, return UF_RET_SUCCESS. Otherwise, return the corresponding error code. UF_RET_SUCCESS only means that request packet is received successfully. To know if the operation succeeds, the flag field should be checked.",
            "title": "UF_CommandSendData"
        },
        {
            "location": "/documents/API_Specification/#uf_commandsenddataex",
            "text": "Encapsulates the commands which send additional data and have multiple response packets. For example, ET(Enroll Template) command sends template data after request packet and can have multiple response packets.  UF_RET_CODE UF_CommandSendDataEx( BYTE command, UINT32* param, UINT32* size, BYTE* flag, BYTE* data, UINT32 dataSize, BOOL (*msgCallback)(BYTE), BOOL waitUserInput )  Parameters  command \nCommand field of a packet. Refer to the Packet Protocol Manual for available commands. param \nParam field of a packet. This parameter is used both for input and output. size \nSize field of a packet. This parameter is used both for input and output. flag \nFlag field of a packet. This parameter is used both for input and output. data \nPointer to the data buffer to be sent. dataSize \nNumber of bytes to be sent. msgCallback \nPointer to the callback function. This callback is called when a response packet is received. If the callback return TRUE,  UF_CommandSendDataEx  will return immediately. If the callback return FALSE,  UF_CommandSendDataEx  will wait for another response packet. waitUserInput \nTRUE if the command needs user input. Otherwise, FALSE.  Return Values \nIf packets are transferred successfully, return UF_RET_SUCCESS. Otherwise, return the corresponding error code. UF_RET_SUCCESS only means that request packet is received successfully. To know if the operation succeeds, the flag field should be checked.",
            "title": "UF_CommandSendDataEx"
        },
        {
            "location": "/documents/API_Specification/#uf_cancel",
            "text": "Cancels the command which is being processed by the module. When the module is executing a command which needs user input to proceed, the status of the module will be changed to UF_SYS_BUSY. If users want to execute another command before finishing the current one, they can explicitly cancel it by this function.  UF_RET_CODE UF_Cancel( BOOL receivePacket )  Parameters  receivePacket \nIf TRUE,  UF_Cancel  waits until the response packet is received. If FALSE,  UF_Cancel  returns immediately after sending the request packet.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_Cancel"
        },
        {
            "location": "/documents/API_Specification/#uf_setprotocol",
            "text": "Selects packet protocol. If the host connects to the single module through RS232 interface, use UF_SINGLE_PROTOCOL. If there are multiple modules in RS422/485 networks, use UF_NETWORK_PROTOCOL. The protocol should also be compatible with the Network Mode system parameter.     Network Mode   Supported Protocol       13 byte Packet Protocol  15 byte Network Packet Protocol    Single(0x30)  O  O    Network (0x31/0x32)  X  O     void UF_SetProtocol( UF_PROTOCOL protocol, UINT32 moduleID )  Parameters  protocol \nUF_SINGLE_PROTOCOL for 13 byte packet protocol, UF_NETWORK_PROTOCOL\nfor 15 byte network packet protocol. moduleID \nSpecifies the ID of the module. This parameter is applicable when the protocol is set to UF_NETWORK_PROTOCOL.  Return Values \nNone",
            "title": "UF_SetProtocol"
        },
        {
            "location": "/documents/API_Specification/#uf_getprotocol",
            "text": "Gets the selected protocol.  UF_PROTOCOL UF_GetProtocol()  Parameters \nNone  Return Values \nUF_SINGLE_PROTOCOL or UF_NETWORK_PROTOCOL.",
            "title": "UF_GetProtocol"
        },
        {
            "location": "/documents/API_Specification/#uf_getmoduleid",
            "text": "Gets the ID of the module.  UINT32 UF_GetModuleID()  Parameters \nNone  Return Values \nID of the module.",
            "title": "UF_GetModuleID"
        },
        {
            "location": "/documents/API_Specification/#uf_setgenericcommandtimeout",
            "text": "Sets the timeout for generic commands. The default timeout is 2,000ms.  void UF_SetGenericCommandTimeout( int timeout )  Parameters  timeout \nSpecifies the timeout period in milliseconds.  Return Values \nNone",
            "title": "UF_SetGenericCommandTimeout"
        },
        {
            "location": "/documents/API_Specification/#uf_setinputcommandtimeout",
            "text": "Sets the timeout for commands which need user input. The default timeout is 10,000ms.  void UF_SetInputCommandTimeout( int timeout )  Parameters  timeout \nSpecifies the timeout period in milliseconds.  Return Values \nNone",
            "title": "UF_SetInputCommandTimeout"
        },
        {
            "location": "/documents/API_Specification/#uf_getgenericcommandtimeout",
            "text": "Gets the timeout for generic commands.  int UF_GetGenericCommandTimeout()  Parameters \nNone  Return Values \nTimeout for generic commands.",
            "title": "UF_GetGenericCommandTimeout"
        },
        {
            "location": "/documents/API_Specification/#uf_getinputcommandtimeout",
            "text": "Gets the timeout for commands which need user input.  int UF_GetInputCommandTimeout()  Parameters \nNone  Return Values \nTimeout for commands which need user input.",
            "title": "UF_GetInputCommandTimeout"
        },
        {
            "location": "/documents/API_Specification/#uf_setnetworkdelay",
            "text": "In half duplex mode, the same communication lines are shared for sending and receiving data. To prevent packet collisions on the shared line, there should be some delay between receiving and sending data. The default delay is set to 40ms. This value can be optimized for specific environments.  void UF_SetNetworkDelay( int delay )  Parameters  delay \nSpecified the delay in milliseconds.  Return Values \nNone",
            "title": "UF_SetNetworkDelay"
        },
        {
            "location": "/documents/API_Specification/#uf_getnetworkdelay",
            "text": "Gets the network delay.  int UF_GetNetworkDelay()  Parameters \nNone  Return Values \nDelay in milliseconds.",
            "title": "UF_GetNetworkDelay"
        },
        {
            "location": "/documents/API_Specification/#36-module-api",
            "text": "These functions provide basic information about the module.   UF_GetModuleInfo: gets the basic module information.  UF_GetModuleString: gets a string describing the module.  UF_SearchModule: searches a module and find out communication parameters.  UF_SearchModuleID: searches an ID of a module.  UF_SearchModuleBySocket: searches a module through socket interface.  UF_SearchModuleIDEx: searches multiple models in a network.  UF_CalibrateSensor: calibrates a sensor.  UF_Upgrade: upgrades firmware.  UF_Reset: resets the module.  UF_Lock: locks the module.  UF_Unlock: unlocks the module.  UF_ChangePassword: changes the master password of a module.  UF_PowerOff : Programmatically turns off a module (SFM4000 only).",
            "title": "3.6. Module API"
        },
        {
            "location": "/documents/API_Specification/#uf_getmoduleinfo",
            "text": "Retrieves the type, version and sensor information of the module.  UF_RET_CODE UF_GetModuleInfo( UF_MODULE_TYPE* type, UF_MODULE_VERSION* version, UF_MODULE_SENSOR* sensorType )  Parameters  type \nAvailable types are as follows;     Value  Description      UF_MODULE_3000  SFM 3000 series modules    UF_MODULE_3500  SFM 3500 series modules    UF_MODULE_4000  SFM 4000 series modules    UF_MODULE_5000  SFM_5000 series modules    UF_BIOENTRY_SMART  BioEntry Smart    UF_BIOENTRY_PASS  BioEntry Pass     version \nVersion number of the module.  sensorType \nSensor type of the module.     Value  Sensor Type      UF_SENSOR_FL  Authentec AF-S2    UF_SENSOR_FC  Atmel FingerChip    UF_SENSOR_OP  Optical Sensor I (OP2/OP3/OP4)    UF_SENSOR_TC  UPEK TouchChip (TC1/TC2/TC2S)    UF_SENSOR_OC2  Optical Sensor II (OC2/OD)    UF_SENSOR_TS  UPEK TouchStrip (TS4)    UF_SENSOR_OL  Optical Sensor III (OL)    UF_SENSOR_OH  Optical Sensor IV (OH)     Return Values     If the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetModuleInfo"
        },
        {
            "location": "/documents/API_Specification/#uf_getmodulestring",
            "text": "Retrieves a string that describes the module information. This function should be called after  UF_GetModuleInfo.  char* UF_GetModuleString( UF_MODULE_TYPE type, UF_MODULE_VERSION version, UF_MODULE_SENSOR sensorType )  Parameters  type \nSpecifies the type of the module. version \nSpecifies the version number of the module. sensorType \nSpecifies the sensor type of the module.  Return Values \nNull-terminated string that describes the module information. This pointer is a static data in the SDK. So, it should not be shared or freed by applications.",
            "title": "UF_GetModuleString"
        },
        {
            "location": "/documents/API_Specification/#uf_searchmodule",
            "text": "Search a module connected to the specified serial port.  UF_SearchModule  tries all combinations of communication parameters. If it finds any module on the serial port, it returns the communication parameters and its module ID.  UF_RET_CODE UF_SearchModule( const char* port, int* baudrate, BOOL* asciiMode, UF_PROTOCOL* protocol, UINT32* moduleID, void (*callback)( const char* comPort, int baudrate ) )  Parameters  port \nSerial port. baudrate \nPointer to the baud rate to be returned. asciiMode   \nPointer to the packet translation mode to be returned. protocol \nPointer to the protocol type to be returned. moduleID \nPointer to the module ID to be returned. callback \nPointer to the callback function. The callback function can be used for displaying the progress of the search. This parameter can be NULL.  Return Values \nIf it finds a module, return UF_RET_SUCCESS. If the search fails, return UF_ERR_NOT_FOUND. Otherwise, return the corresponding error code.",
            "title": "UF_SearchModule"
        },
        {
            "location": "/documents/API_Specification/#uf_searchmoduleid",
            "text": "Until firmware V1.3, SFM modules respond both standard and network packets regardless of Network Mode system parameter. However, since firmware V1.4, the modules only respond to 15 byte network packets if Network Mode system parameter is not Single(0x30). So, if users don\u2019t know ID of the module, they cannot communicate with it in network environments.  UF_SerachModuleID  can be used to retrieve the ID of the module in these cases. Refer to ID command section in the Packet Protocol Manual for details.  UF_RET_CODE UF_SearchModuleID( UINT32* moduleID )  Parameters  moduleID \nPointer to the module ID to be returned.  Return Values \nIf it finds a module, return UF_RET_SUCCESS. If the search fails, return UF_ERR_NOT_FOUND. Otherwise, return the corresponding error code.",
            "title": "UF_SearchModuleID"
        },
        {
            "location": "/documents/API_Specification/#uf_searchmodulebysocket",
            "text": "Search a module connected to the specified IP address. If it finds any module, it will return the communication parameters and the module ID.  UF_RET_CODE UF_SearchModuleBySocket( const char* inetAddr, int tcpPort, BOOL* asciiMode, UF_PROTOCOL* protocol, UINT32* moduleID )  Parameters  inetAddr \nIP address. tcpPort \nTCP port. asciiMode \nPointer to the packet translation mode to be returned. protocol \nPointer to the protocol type to be returned. moduleID \nPointer to the module ID to be returned.  Return Values \nIf it finds a module, return UF_RET_SUCCESS. If the search fails, return UF_ERR_NOT_FOUND. Otherwise, return the corresponding error code.",
            "title": "UF_SearchModuleBySocket"
        },
        {
            "location": "/documents/API_Specification/#uf_searchmoduleidex",
            "text": "UF_SearchModuleID  is used for searching a module. To search multiple modules in a RS422/485 network,  UF_SearchModuleIDEx  should be used instead. By calling this function repetitively, users can search all the modules connected to a network.  UF_RET_CODE UF_SearchModuleIDEx( unsigned short* foundModuleID, int numOfFoundID, unsigned short* moduleID, int* numOfID )  Parameters  foundModuleID \nPointer to the array of module IDs, which are already found. When the ID of a module is in this array, the module will ignore the search command. numOfFoundID \nNumber of module IDs, which are already found. moduleID \nPointer to the array of module IDs, which will be filled with newly found IDs. numOfID \nPointer to the number of module IDs to be returned.  Return Values \nIf it finds one or more modules, return UF_RET_SUCCESS. If the search fails, return UF_ERR_NOT_FOUND. Otherwise, return the corresponding error code.",
            "title": "UF_SearchModuleIDEx"
        },
        {
            "location": "/documents/API_Specification/#example_10",
            "text": "int   numOfModuleID ;  unsigned   short   moduleID [ 32 ];  int   numOfFoundID   =   0 ;  BOOL   foundNewID   =   FALSE ;  do   { \n     result   =   UF_SearchModuleIDEx (   moduleID ,   numOfFoundID ,   moduleID   +  numOfFoundID ,   & numOfModuleID   ); \n\n     if (   result   ==   UF_RET_SUCCESS   ) \n     { \n         foundNewID   =   TRUE ; \n\n         numOfFoundID   +=   numOfModuleID ; \n     } \n     else \n     { \n         foundNewID   =   FALSE ; \n     }  }   while (   foundNewID   &&   numOfFoundID   <   32   );",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_calibratesensor",
            "text": "Calibrates fingerprint sensor. This function is supported for AuthenTec\u2019s FingerLoc AF-S2 and UPEK\u2019s TouchChip. After using the  UF_CalibrateSensor ,  UF_Save  should be called to save calibration data into flash memory.  UF_RET_CODE UF_CalibrateSensor()  Parameters \nNone  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_CalibrateSensor"
        },
        {
            "location": "/documents/API_Specification/#uf_upgrade",
            "text": "Upgrades the firmware of the module. Users should not turn off the module when upgrade is in progress.  UF_RET_CODE UF_Upgrade( const char* firmwareFilename, int data++PacketSize++)  Parameters  firmwareFilename \nNull-terminated string that specifies the firmware file name. dataPacketSize \nThe packet size of firmware data. If it is 16384, the firmware is divided into 16384 byte packets before transferring to the module.  Return Values \nIf upgrade succeeds, return UF_RET_SUCCESS. Otherwise, return the\ncorresponding error code.",
            "title": "UF_Upgrade"
        },
        {
            "location": "/documents/API_Specification/#uf_reset",
            "text": "Resets the module.  UF_RET_CODE UF_Reset()  Parameters \nNone  Return Values \nUF_RET_SUCCESS",
            "title": "UF_Reset"
        },
        {
            "location": "/documents/API_Specification/#uf_lock",
            "text": "Locks the module. When the module is locked, it returns UF_ERR_LOCKED to functions other than  UF_Unlock.  UF_RET_CODE UF_Lock()  Parameters \nNone  Return Values \nIf the module is locked successfully, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_Lock"
        },
        {
            "location": "/documents/API_Specification/#uf_unlock",
            "text": "Unlocks a locked module.  UF_RET_CODE UF_Unlock( const unsigned char* password )  Parameters  password \n16 byte master password. The default password is a string of 16 NULL\ncharacters.  Return Values \nIf the password is wrong, return UF_ERR_NOT_MATCH. If it is successful, return UF_RET_SUCCESS.",
            "title": "UF_Unlock"
        },
        {
            "location": "/documents/API_Specification/#uf_changepassword",
            "text": "Changes the master password.  UF_RET_CODE UF_ChangePassword( const unsigned char* newPassword, const unsigned char* oldPassword )  Parameters  newPassword \n16 byte new password. oldPassword \n16 byte old password.  Return Values \nIf the old password is wrong, return UF_ERR_NOT_MATCH. If it is successful, return UF_RET_SUCCESS.",
            "title": "UF_ChangePassword"
        },
        {
            "location": "/documents/API_Specification/#uf_poweroff",
            "text": "Programmatically turns off a module. This function is only available with SFM4000 series.  UF_RET_CODE UF_PowerOff()  Parameters \nNone  Return Values \nThe module is powered off successfully, return UF_RET_SUCCESS.",
            "title": "UF_PowerOff"
        },
        {
            "location": "/documents/API_Specification/#37-system-parameters-api",
            "text": "Functions for managing system parameters. Available system parameters are defined in UF_SysParameter.h. See the Packet Protocol Manual for available values for each parameter.\nThis API also provides functions for saving and loading system configurations.   UF_InitSysParameter: clears the system parameter cache.  UF_GetSysParameter: gets the value of a system parameter.  UF_SetSysParameter: sets the value of a system parameter.  UF_GetMultiSysParameter: gets the values of multiple system parameters.  UF_SetMultiSysParameter: sets the values of multiple system parameters.  UF_Save: saves system parameters into the flash memory.  UF_SaveConfiguration: saves system configurations into the specified file.  UF_ReadConfigurationHeader: reads configuration information stored in a file.  UF_LoadConfiguration: loads system configurations from the specified file.  UF_MakeParameterConfiguration: makes parameter configuration data to be saved.",
            "title": "3.7. System Parameters API"
        },
        {
            "location": "/documents/API_Specification/#uf_initsysparameter",
            "text": "To prevent redundant communication, the SFM SDK caches the system parameters previously read or written.  UF_InitSysParameter  clears this cache. It is called in  UF_Reconnect .  void UF_InitSysParameter()     Parameters \nNone  Return Values \nNone",
            "title": "UF_InitSysParameter"
        },
        {
            "location": "/documents/API_Specification/#uf_getsysparameter",
            "text": "Reads the value of a system parameter.  UF_RET_CODE UF_GetSysParameter( UF_SYS_PARAM parameter, UINT32* value )  Parameters  parameter \nSystem parameter to be read. value \nPointer to the value of the specified system parameter to be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. If there is no such parameter, return UF_ERR_NOT_FOUND. Otherwise, return the corresponding error code.",
            "title": "UF_GetSysParameter"
        },
        {
            "location": "/documents/API_Specification/#uf_setsysparameter",
            "text": "Writes the value of a system parameter. The parameter value is changed in memory only. To make the change permanent,  UF_Save  should be called after this function. For BioEntry Smart and Pass, users cannot change the UF_SYS_MODULE_ID system parameter.  UF_RET_CODE UF_SetSysParameter( UF_SYS_PARAM parameter, UINT32 value )  Parameters  parameter \nSystem parameter to be written. value \nValue of the system parameter. Refer to the Packet Protocol Manual for available values for each parameter.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. If there is no such parameter, return UF_ERR_NOT_FOUND. Otherwise, return the corresponding error code.",
            "title": "UF_SetSysParameter"
        },
        {
            "location": "/documents/API_Specification/#uf_getmultisysparameter",
            "text": "Reads the values of multiple system parameters.  UF_RET_CODE UF_GetMultiSysParameter( int parameterCount, UF_SYS_PARAM* parameters, UINT32* values )  Parameters  parameterCount \nNumber of system parameters to be read. parameters \nArray of system parameters to be read. values \nArray of the values of the specified system parameters to be read.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetMultiSysParameter"
        },
        {
            "location": "/documents/API_Specification/#example_11",
            "text": "// To read 3 system parameters, UF_SYS_TIMEOUT, UF_SYS_ENROLL_MODE,  // UF_SYS_SECURITY_LEVEL,  UF_SYS_PARAM   parameters [ 3 ]   =   {   UF_SYS_TIMEOUT ,   UF_SYS_ENROLL_MODE ,   UF_SYS_SECURITY_LEVEL   };  UINT32   values [ 3 ];  UF_RET_CODE   result   =   UF_GetMultiSysParameter (   3 ,   parameters ,   values   );",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_setmultisysparameter",
            "text": "Writes the values of multiple system parameters. The parameter value is changed in memory only. To make the change permanent,  UF_Save  should be called.  UF_RET_CODE UF_SetMultiSysParameter( int parameterCount, UF_SYS_PARAM* parameters, UINT32* values )  Parameters  parameterCount \nNumber of system parameters to be written. parameters \nArray of system parameters to be written. values \nArray of the values of the specified system parameters to be written.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetMultiSysParameter"
        },
        {
            "location": "/documents/API_Specification/#uf_save",
            "text": "Saves the system parameters into the flash memory.  UF_RET_CODE UF_Save()  Parameters \nNone  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_Save"
        },
        {
            "location": "/documents/API_Specification/#uf_saveconfiguration",
            "text": "Saves system configurations into the specified file. The configuration file consists of a file header and multiple configuration components. There are 5 configuration components to be saved. typedef   enum   { \n     UF_CONFIG_PARAMETERS    =   0x01 ,   // System parameters \n     UF_CONFIG_GPIO          =   0x02 ,   // GPIO configurations for \n                                   // SFM3000 \n     UF_CONFIG_IO            =   0x04 ,   // IO configurations for \n                                   // SFM3500 \n     UF_CONFIG_WIEGAND       =   0x08 ,   // Extended Wiegand \n     UF_CONFIG_USER_MEMORY   =   0x10 ,   // User memory  }   UF_CONFIG_TYPE ;   UF_RET_CODE UF_SaveConfiguration( const char* filename, const char* description, int numOfComponent, UFConfigComponentHeader* componentHeader, void** componentData )  Parameters  filename \nNull-terminated string that specifies the file name. description \nNull-terminated string describing the configuration file. The maximum length of description is 256 bytes. numOfComponent \nNumber of components to be saved. componentHeader \nPointer to an array of UFConfigComponentHeader structures to be saved.  typedef   struct   { \n     UF_CONFIG_TYPE   type ; \n     UINT32   dataSize ; \n     UINT32   checksum ;  }   UFConfigComponentHeader ;   componentData \nPointer to an array of component data to be saved.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SaveConfiguration"
        },
        {
            "location": "/documents/API_Specification/#example_12",
            "text": "// To save system parameters and IO configuration  // of a SFM 3500 module into \u201cSFM3500.cfg\u201d file,  UF_ConfigComponentHeader   configHeader [ 2 ];  void *   configData [ 2 ];  // Make system parameter component  UFConfigParameter *   parameter   =   ( UFConfigParameter * ) malloc (   sizeof ( int )   + \n     NUM_OF_PARAMETER   *   sizeof ( UFConfigParameterItem )   );  UF_MakeParameterConfiguration (   & configHeader [ 0 ],( BYTE * ) parameter   );  configData [ 0 ]   =   ( void * ) parameter ;  // Make IO component  UFConfigIO *   io   =   ( UFConfigIO * ) malloc (   sizeof ( UFConfigIO )   + \n     sizeof ( UFConfigOutputItem )   *   ( UF_MAX_OUTPUT_EVENT   -   1 )   );  UF_MakeIOConfiguration (   & configHeader [ 1 ],   ( BYTE * ) io   );  configData [ 1 ]   =   ( void * ) io ;  UF_RET_CODE   result   =   UF_SaveConfiguration (   \u201c SFM3500 . cfg \u201d ,   \u201c Configuration \n     file   for   SFM3500 \u201d ,   2 ,   configHeader ,   configData   );",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_readconfigurationheader",
            "text": "Reads the header information from a file which is saved by  UF_SaveConfiguration.  UF_RET_CODE UF_ReadConfigurationHeader( const char* filename, UFConfigFileHeader* header )  Parameters  filename \nNull-terminated string that specifies the file name. header \nPointer to the UFConfigFileHeader to be read.  typedef   struct   { \n     UINT32   magicNo ;   // if valid, UF_VALID_CONFIG_FILE \n     UINT32   numOfComponent ; \n     char   description [ 256 ];  }   UFConfigFileHeader ;   Return Values \nIf the header is read successfully, return UF_RET_SUCCESS. If the file is of invalid type, return UF_ERR_INVALID_FILE. Otherwise, return the corresponding error code.",
            "title": "UF_ReadConfigurationHeader"
        },
        {
            "location": "/documents/API_Specification/#uf_loadconfiguration",
            "text": "Loads system configurations into a module from the specified file. To make permanent the configuration changes,  UF_Save  should be called after  UF_LoadConfiguration .  UF_RET_CODE UF_LoadConfiguration( const char* filename, int numOfComponent, UF_CONFIG_TYPE* type )  Parameters  filename \nNull-terminated string that specifies the file name. numOfComponent \nNumber of configuration components to be loaded. type \nArray of component types to be loaded.  Return Values \nIf the configurations are loaded successfully, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_LoadConfiguration"
        },
        {
            "location": "/documents/API_Specification/#example_13",
            "text": "// To load system parameters and IO configuration  // of a SFM 3500 module from \u201cSFM3500.cfg\u201d file,  UF_CONFIG_TYPE   configType [ 2 ]   =   {   UF_CONFIG_PARAMETERS ,   UF_CONFIG_IO   };  UF_RET_CODE   result   =   UF_LoadConfiguration (   \u201c SFM3500 . cfg \u201d ,   2 ,   configType   );",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_makeparameterconfiguration",
            "text": "Make a UFConfigComponentHeader and a UFConfigParameter structure to be used in  UF_SaveConfiguration .  UF_RET_CODE     UF_MakeParameterConfiguration( UFConfigComponentHeader* configHeader, BYTE* configData )     Parameters  configHeader \nPointer to the UFConfigComponentHeader structure. configData \nPointer to the UFConfigParameter structure. It should be preallocated large enough to store all the parameter information.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_MakeParameterConfiguration"
        },
        {
            "location": "/documents/API_Specification/#38-template-management-api",
            "text": "These functions provide template management interfaces such as read, delete and fix. Users can also manage user ids and administration levels associated with templates using these APIs.   UF_GetNumOfTemplate: gets the number of template stored in a module.  UF_GetMaxNumOfTemplate: gets the template capacity of a module.  UF_GetAllUserInfo: gets all the template and user information stored in a module.  UF_GetAllUserInfoEx: gets all the template and user information stored in a BioEntry reader.  UF_SortUserInfo: sorts UFUserInfo structures.  UF_SetUserInfoCallback: sets the callback function for getting user information.  UF_SetAdminLevel: sets the administration level of a user.  UF_GetAdminLevel: gets the administration level of a user.  UF_ClearAllAdminLevel: clears all the administration levels of users.  UF_SaveDB: saves templates and user information into the specified file.  UF_LoadDB: loads templates and user information from the specified file.  UF_CheckTemplate: checks if the specified ID has templates.  UF_ReadTemplate: reads the templates of the specified user ID.  UF_ReadOneTemplate: reads one template of the specified user ID.  UF_SetScanCallback: sets the callback function for scanning fingerprints.  UF_ScanTemplate: scans a fingerprint on the sensor and retrieves the fingerprint template.  UF_FixProvisionalTemplate: saves the provisional templates into the flash memory.  UF_SetSecurityLevel: sets the security level of a user.  UF_GetSecurityLevel: gets the security level of a user.  UF_SetAuthType: sets the authentication type of a user.  UF_GetAuthType: gets the authentication type of a user.  UF_GetUserIDByAuthType: gets the user IDs with specified authentication type.  UF_ResetAllAuthType: resets the authentication types of all users.  UF_SetEntranceLimit: sets the entrance limit of a user.  UF_GetEntranceLimit: gets the entrance limit of a user.  UF_ClearAllEntranceLimit: clears the entrance limits of all users.",
            "title": "3.8. Template Management API"
        },
        {
            "location": "/documents/API_Specification/#uf_getnumoftemplate",
            "text": "Gets the number of templates stored in the module.  UF_RET_CODE UF_GetNumOfTemplate( UINT32* numOfTemplate )  Parameters  numOfTemplate \nPointer to the number of templates to be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetNumOfTemplate"
        },
        {
            "location": "/documents/API_Specification/#uf_getmaxnumoftemplate",
            "text": "Gets the template capacity of the module.  UF_RET_CODE UF_GetMaxNumOfTemplate( UINT32* maxNumOfTemplate )  Parameters  maxNumOfTemplate \nPointer to the template capacity to be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetMaxNumOfTemplate"
        },
        {
            "location": "/documents/API_Specification/#uf_getalluserinfo",
            "text": "Retrieves all the user and template information stored in the module.  UF_RET_CODE UF_GetAllUserInfo( UFUserInfo* userInfo, UINT32* numOfUser, UINT32* numOfTemplate )  Parameters  userInfo \nArray of UFUserInfo structures, which will store all the information. This pointer should be preallocated large enough to store all the information. UFUserInfo structure is defined as follows;  typedef   struct   { \n     UINT32   userID ; \n     BYTE   numOfTemplate ; \n     BYTE   adminLevel ;   // See UF_SetAdminLevel \n     BYTE   securityLevel ;   // See UF_SetSecurityLevel \n     BYTE   reserved ;  }   UFUserInfo ;   numOfUser \nPointer to the number of users to be returned. numOfTemplate \nPointer to the number of templates to be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetAllUserInfo"
        },
        {
            "location": "/documents/API_Specification/#example_14",
            "text": "UINT32   maxUser ;  UINT32   numOfUser ,   numOfTemplate ;  UF_RET_CODE   result   =   UF_GetSysParameter (   UF_SYS_ENROLLED_FINGER ,   & maxUser   );  UFUserInfo *   userInfo   =   ( UFUserInfo * ) malloc (   maxUser   *   sizeof ( UFUserInfo )   );  result   =   UF_GetAllUserInfo (   userInfo ,   & numOfUser ,   & numOfTemplate   );",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_getalluserinfoex",
            "text": "Retrieves all the user and template information stored in the BioEntry reader.  UF_RET_CODE UF_GetAllUserInfoEx( UFUserInfoEx* userInfo, UINT32* numOfUser, UINT32* numOfTemplate )  Parameters  userInfo \nArray of UFUserInfoEx structures, which will store all the information. This pointer should be preallocated large enough to store all the information. UFUserInfoEx structure is defined as follows;  typedef   struct   { \n     UINT32   userID ; \n     UINT32   checksum [ 10 ];   // checksum of each template data \n     BYTE   numOfTemplate ; \n     BYTE   adminLevel ; \n     BYTE   duress [ 10 ]; \n     BYTE   securityLevel ;  }   UFUserInfoEx ;   numOfUser \nPointer to the number of users to be returned. numOfTemplate \nPointer to the number of templates to be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetAllUserInfoEx"
        },
        {
            "location": "/documents/API_Specification/#uf_sortuserinfo",
            "text": "Sorts an UFUserInfo array in ascending order of user ID.  void UF_SortUserInfo( UFUserInfo* userInfo, int numOfUser )  Parameters  userInfo \nArray of UFUserInfo structures. numOfUser \nNumber of UFUserInfo.  Return Values \nNone",
            "title": "UF_SortUserInfo"
        },
        {
            "location": "/documents/API_Specification/#uf_setuserinfocallback",
            "text": "Sets the callback function for getting user information. It is also called when enrolling templates in  UF_LoadDB  and reading templates in  UF_SaveDB .  void UF_SetUserInfoCallback( void (*callback)( int index, int numOfTemplate ) )  Parameters  callback \nPointer to the callback function. Return Values \nNone",
            "title": "UF_SetUserInfoCallback"
        },
        {
            "location": "/documents/API_Specification/#example_15",
            "text": "See CMainFrame::UserInfoCallback in UniFingerUI source codes.",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_setadminlevel",
            "text": "Sets the administration level of a user. See  UF_EnrollAfterVerification  and  UF_DeleteAllAfterVerificatoin  for usage of administration level.  UF_RET_CODE UF_SetAdminLevel( UINT32 userID, UF_ADMIN_LEVEL adminLevel )  Parameters  userID \nUser ID. adminLevel \nSpecifies the administration level of the user.     Value  Note      UF_ADMIN_NONE     UF_ADMIN_ENROLL  Can enroll users.    UF_ADMIN_DELETE  Can delete users.    UF_ADMIN_ALL  Can enroll and delete users.     Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetAdminLevel"
        },
        {
            "location": "/documents/API_Specification/#uf_getadminlevel",
            "text": "Gets the administration level of a user.  UF_RET_CODE UF_GetAdminLevel( UINT32 userID, UF_ADMIN_LEVEL* adminLevel )  Parameters  userID \nUser ID. adminLevel \nPointer to the administration level of the user to be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetAdminLevel"
        },
        {
            "location": "/documents/API_Specification/#uf_clearalladminlevel",
            "text": "Resets administration levels of all users to UF_ADMIN_NONE.  UF_RET_CODE UF_ClearAllAdminLevel()  Parameters \nNone  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ClearAllAdminLevel"
        },
        {
            "location": "/documents/API_Specification/#uf_savedb",
            "text": "Saves all the templates and user information stored in a module into the specified file.  UF_RET_CODE UF_SaveDB( const char* fileName )  Parameters  fileName \nNull-terminated string that specifies the file name.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SaveDB"
        },
        {
            "location": "/documents/API_Specification/#uf_loaddb",
            "text": "Loads templates and user information from the specified file. All the templates previously stored in the module will be erased before loading the DB.  UF_RET_CODE UF_LoadDB( const char* fileName )  Parameters  fileName \nNull-terminated string that specifies the file name. Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_LoadDB"
        },
        {
            "location": "/documents/API_Specification/#uf_checktemplate",
            "text": "Checks if the specified user ID has enrolled templates.  UF_RET_CODE UF_CheckTemplate( UINT32 userID, UINT32* numOfTemplate )  Parameters  userID \nUser ID. numOfTemplate \nPointer to the number of templates of the user ID to be returned.  Return Values \nIf there are templates of the user ID, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_CheckTemplate"
        },
        {
            "location": "/documents/API_Specification/#uf_readtemplate",
            "text": "Reads  the templates of the specified user ID.  UF_RET_CODE UF_ReadTemplate( UINT32 userID, UINT32* numOfTemplate, BYTE* templateData )  Parameters  userID \nUser ID. numOfTemplate \nPointer to the number of templates of the user ID to be returned. templateData \nPointer to the template data to be returned. This pointer should be\npreallocated large enough to store all the template data.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ReadTemplate"
        },
        {
            "location": "/documents/API_Specification/#uf_readonetemplate",
            "text": "Reads one template of the specified user ID.  UF_RET_CODE UF_ReadOneTemplate( UINT32 userID, int subID, BYTE*templateData )  Parameters  userID \nUser ID. subID \nSub index of the template. It is between 0 and 9. templateData \nPointer to the template data to be returned. This pointer should be\npreallocated large enough to store all the template data.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ReadOneTemplate"
        },
        {
            "location": "/documents/API_Specification/#uf_setscancallback",
            "text": "Sets the callback function of scanning fingerprints. This callback is called when SCAN_SUCCESS message is received.  void UF_SetScanCallback( void (*callback)( BYTE ) )  Parameters  callback \nPointer to the callback function.  Return Values \nNone",
            "title": "UF_SetScanCallback"
        },
        {
            "location": "/documents/API_Specification/#uf_scantemplate",
            "text": "Scans a fingerprint on the sensor and receives the template of it.  UF_RET_CODE UF_ScanTemplate( BYTE* templateData, UINT32* templateSize, UINT32* imageQuality )  Parameters  templateData \nPointer to the template data to be returned. templateSize \nPointer to the template size to be returned. imageQuality \nPointer to the image quality score to be returned. The score shows the quality of scanned fingerprint and is in the range of 0 ~ 100.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ScanTemplate"
        },
        {
            "location": "/documents/API_Specification/#uf_fixprovisionaltemplate",
            "text": "UF_SYS_PROVISIONAL_ENROLL determines if enrolled templates are saved\npermanently into flash memory or temporarily into DRAM. With provisional enroll, enrolled templates on DRAM will be erased if the module is turned off.  UF_FixProvisionalTemplate  saves the provisional templates into the flash memory.  UF_RET_CODE UF_FixProvisionalTemplate()  Parameters \nNone  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_FixProvisionalTemplate"
        },
        {
            "location": "/documents/API_Specification/#uf_setsecuritylevel",
            "text": "Since V1.6 firmware, the security level can be assigned per user basis for 1:1 matching. 1:N matching \u2013 identification \u2013 is not affected by this setting.  UF_RET_CODE UF_SetSecurityLevel( UINT32 userID, UF_USER_SECURITY_LEVEL securityLevel )  Parameters  userID \nUser ID. securityLevel \nSpecifies the security level of the user.     Value  Note      UF_USER_SECURITY_DEFAULT  Same as defined by Security Level     system parameter    UF_USER_SECURITY_1_TO_1000     \u2026     UF_USER_SECURITY_1_TO_100000000      Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetSecurityLevel"
        },
        {
            "location": "/documents/API_Specification/#uf_getsecuritylevel",
            "text": "Gets the security level of a user.  UF_RET_CODE UF_GetSecurityLevel( UINT32 userID, UF_SECURITY_LEVEL* securityLevel )  Parameters  userID \nUser ID. securityLevel \nPointer to the security level of the user to be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetSecurityLevel"
        },
        {
            "location": "/documents/API_Specification/#uf_setauthtype",
            "text": "Sets the authentication type of a user. UF_AUTH_BYPASS can be used for 1:1 matching, when it is necessary to allow access without matching fingerprints. UF_AUTH_REJECT can be used for disabling some IDs temporarily. The default authentication mode is UF_AUTH_FINGERPRINT.  UF_RET_CODE UF_SetAuthType( UINT32 userID, UF_AUTH_TYPE authType )  Parameters  userID \nUser ID. authType \nSpecifies the authentication type of the user.     Value  Note      UF_AUTH_FINGERPRINT  Fingerprint authentication.    UF_AUTH_BYPASS  Authentication will succeed without matching fingerprints.    UF_AUTH_REJECT  Authentication will always fail.     Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetAuthType"
        },
        {
            "location": "/documents/API_Specification/#uf_getauthtype",
            "text": "Gets the authentication type of a user.  UF_RET_CODE UF_GetAuthType( UINT32 userID, UF_AUTH_TYPE* authType )  Parameters  userID \nUser ID. authType \nPointer to the authentication type of the user to be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetAuthType"
        },
        {
            "location": "/documents/API_Specification/#uf_getuseridbyauthtype",
            "text": "Receive user IDs with the specified authentication type.  UF_RET_CODE UF_GetUserIDByAuthType( UF_AUTH_TYPE authType, int* numOfID, UINT32* userID )  Parameters  authType \nAuthentication type. numOfID \nPointer to the number of user IDs to be returned. userID \nArray of user IDs which have the specified authentication type.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetUserIDByAuthType"
        },
        {
            "location": "/documents/API_Specification/#uf_resetallauthtype",
            "text": "Resets the authentication types of all users to UF_AUTH_FINGERPRINT.  UF_RET_CODE UF_ResetAllAuthType()  Parameters \nNone  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ResetAllAuthType"
        },
        {
            "location": "/documents/API_Specification/#uf_setentrancelimit",
            "text": "Specifies how many times the user is permitted to access per day. The available options are between 0 and 7. The default value is 0, which means that there is no limit. If the user tries to authenticate after the limit is reached, UF_ERR_EXCEED_ENTRANCE_LIMIT error will be returned.  UF_RET_CODE UF_SetEntranceLimit( UINT32 userID, int entranceLimit )  Parameters  userID \nUser ID. entranceLimit \nEntrance limit between 0 and 7.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetEntranceLimit"
        },
        {
            "location": "/documents/API_Specification/#uf_getentrancelimit",
            "text": "Gets the entrance limit of a user.  UF_RET_CODE UF_GetEntranceLimit( UINT32 userID, int* entranceLimit, int* entranceCount )  Parameters  userID \nUser ID. entranceLimit \nPointer to the entrance limit of the user. entranceCount \nPointer to the number of entrance for today. This count is reset to 0 at midnight.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetEntranceLimit"
        },
        {
            "location": "/documents/API_Specification/#uf_clearallentrancelimit",
            "text": "Resets the entrance limits of of all users to 0 \u2013 infinite.  UF_RET_CODE UF_ClearAllEntranceLimit()  Parameters \nNone  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ClearAllEntranceLimit"
        },
        {
            "location": "/documents/API_Specification/#39-image-manipulation-api",
            "text": "UFImage is a data structure for exchanging image data between the host and the module. It consists of 28 byte header and raw image data. typedef   struct   { \n     int   width ;   // width of the fingerprint image \n     int   height ;   // height of the fingerprint image \n     int   compressed ;   // compression status \u2013 currently not used \n     int   encrypted ;   // encryption status \u2013 currently not used \n     int   format ;   // 0- gray, 1- binary, 2- 4bit gray \n     int   imgLen ;   // width * height \n     int   templateLen ;   // size of fingerprint template \u2013 currently not used \n     BYTE   buffer [ 1 ]; // pointer to the raw pixel data  }   UFImage ;  \n- UF_ConvertToBitmap: converts a UFImage structure into HBITMAP.\n- UF_SaveImage: saves a UFImage structure into BMP file.\n- UF_LoadImage: loads a BMP file and convert it into a UFImage structure.\n- UF_ReadImage: retrieves the last scanned fingerprint image.\n- UF_ScanImage: scans a fingerprint on the sensor and retrieves the image data.",
            "title": "3.9. Image Manipulation API"
        },
        {
            "location": "/documents/API_Specification/#uf_converttobitmap",
            "text": "To display a UFImage on the PC screen, it should be converted to a bitmap first.  UF_ConvertToBitmap  converts a UFImage into a device independent bitmap and returns the handle of it. After drawing the bitmap, it should be destroyed by calling DeleteObject().  HBITMAP UF_ConvertToBitmap( UFImage* image )  Parameters  image \nPointer to the UFImage structure to be converted.  Return Values \nIf the function succeeds, return the HBITMAP of the bitmap. Otherwise, return NULL.",
            "title": "UF_ConvertToBitmap"
        },
        {
            "location": "/documents/API_Specification/#example_16",
            "text": "// The following snippet is from FingerprintViewer.cpp in UniFingerUI  // source codes  class   CFingerprintViewer   :   public   CStatic  { \n     // \u2026  Private : \n     UFImage *   m_Image ; \n     HBITMAP   m_Bitmap ;  };  void   CFingerprintViewer :: OnPaint ()  { \n     CPaintDC   dc (   this   ); \n     CBitmap   bmp ; \n\n     if (   m_Bitmap   ) \n     { \n         DeleteObject (   m_Bitmap   ); \n     } \n\n     if (   m_Image   ) \n     { \n         m_Bitmap   =   UF_ConvertToBitmap (   m_Image   ); \n         bmp . Attach (   m_Bitmap   ); \n     } \n     else \n     { \n         bmp . LoadBitmap (   IDB_LOGO   ); \n     } \n     CDC   bmDC ; \n     bmDC . CreateCompatibleDC ( & dc ); \n     CBitmap   * pOldbmp   =   bmDC . SelectObject ( & bmp ); \n\n     BITMAP   bi ; \n     bmp . GetBitmap ( & bi ); \n\n     CRect   rect ; \n     this -> GetClientRect ( & rect ); \n\n     dc . SetStretchBltMode (   HALFTONE   ); \n     dc . StretchBlt (   1 ,   1 ,   rect . Width ()   -   2 ,   rect . Height ()   -   2 ,   & bmDC ,   0 ,   0 ,  bi . bmWidth ,   bi . bmHeight ,   SRCCOPY   ); \n     bmDC . SelectObject ( pOldbmp );  }",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_saveimage",
            "text": "Converts a UFImage into a bitmap and save it into the specified file.  UF_RET_CODE UF_SaveImage( const char* fileName, UFImage* image )  Parameters  fileName   \nNull-terminated string that specifies the file name. image \nPointer to the UFImage to be saved.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SaveImage"
        },
        {
            "location": "/documents/API_Specification/#uf_loadimage",
            "text": "Loads a bmp file into a UFImage structure.  UF_RET_CODE UF_LoadImage( const char* fileName, UFImage* image )  Parameters  fileName \nNull-terminated string that specifies the file name. image \nPointer to the UFImage structure.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_LoadImage"
        },
        {
            "location": "/documents/API_Specification/#uf_readimage",
            "text": "Reads the last scanned fingerprint image.  UF_RET_CODE UF_ReadImage( UFImage* image )  Parameters  image \nPointer to the UFImage structure.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ReadImage"
        },
        {
            "location": "/documents/API_Specification/#example_17",
            "text": "UFImage *   image   =   ( UFImage * ) malloc (   UF_IMAGE_HEADER_SIZE   + \n                   UF_MAX_IMAGE_SIZE   );  UF_RET_CODE   result   =   UF_ReadImage (   image   );",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_scanimage",
            "text": "Scans a fingerprint input on the sensor and retrieves the image of it.  UF_RET_CODE UF_ScanImage( UFImage* image )  Parameters  image \nPointer to the UFImage structure.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ScanImage"
        },
        {
            "location": "/documents/API_Specification/#310-enroll-api",
            "text": "There are three ways to enroll fingerprints; scanning live fingerprints, using scanned images, or sending templates acquired elsewhere. The enrollment process varies according to UF_SYS_ENROLL_MODE parameter. Users can also fine tune the enrollment process by selecting enroll options.   UF_Enroll: enrolls fingerprint inputs on the sensor.  UF_EnrollContinue: continues the enrollment process when the enroll mode is UF_ENROLL_TWO_TIMES2 or UF_ENROLL_TWO_TEMPLATES2.  UF_EnrollAfterVerification: enrolls after an administrator is verified.  UF_EnrollTemplate: enrolls a template.  UF_EnrollMultipleTemplates: enrolls multiple templates to the specified ID.  UF_EnrollImage: enrolls a fingerprint image.  UF_SetEnrollCallback: sets the callback function for enrollment process.",
            "title": "3.10. Enroll API"
        },
        {
            "location": "/documents/API_Specification/#uf_enroll",
            "text": "Enrolls fingerprint inputs on the sensor. The enrollment process varies according to the UF_SYS_ENROLL_MODE system parameter.     Enroll Mode  Description      UF_ENROLL_ONE_TIME  Scans a fingerprint and enrolls it.    UF_ENROLL_TWO_TIMES1  Scans two fingerprints and enrolls the better one of the two. The scanning of the second fingerprint starts automatically.    UF_ENROLL_TWO_TIMES2  Same as UF_ENROLL_TWO_TIMES1, but the scanning of the second fingerprint should be initiated by another request packet.    UF_ENROLL_TWO_TEMPLATES1  Scans two fingerprints and enrolls both of them. The scanning of the second fingerprint starts automatically.    UF_ENROLL_TWO_TEMPLATES2  Same as UF_ENROLL_TWO_TEMPLATES1, but the scanning of the second fingerprint should be initiated by another request packet.     Users can also fine tune the enrollment process by selecting one of the following UF_ENROLL_OPTIONs.     Option  Description      UF_ENROLL_NONE  Overwrites existing templates of the same ID.    UF_ENROLL_ADD_NEW  Adds templates to the same user ID.     The maximum number of templates per user is 10.    UF_ENROLL_AUTO_ID  The user ID will be assigned automatically by the module.    UF_ENROLL_CHECK_ID  Before enrolling, checks if the user ID has already some templates. If it does, UF_ERR_EXIST_ID will be returned. This option is useful when users do not want to overwrite existing templates.    UF_ENROLL_CHECK_FINGER  Before enrolling, checks if the same fingerprint is already enrolled. If the identification succeeds, return UF_ERR_EXIST_FINGER error. If the identification fails, continue enroll process with UF_ENROLL_ADD_NEW option.    UF_ENROLL_CHECK_FINGER_AUTO_ID  Before enrolling, checks if the same fingerprint is already enrolled. If the identification succeeds, return UF_ERR_EXIST_FINGER error. If the identification fails, continue enroll process with UF_ENROLL_AUTO_ID option.    UF_ENROLL_DURESS  Adds another fingerprint as duress finger to the specified user ID. Under duress, users can authenticate with duress finger to notify the threat. When duress finger is matched, the module will return UF_ERR_DURESS_FINGER error code and write a log. Users can also setup output signals for duress events. When enrolling, the duress finger should not match with nonduress fingerprints of the same ID. If it is the case, UF_ERR_EXIST_FINGER error will be returned.     UF_RET_CODE UF_Enroll( UINT32 userID, UF_ENROLL_OPTION option, UINT32* enrollID, UINT32* imageQuality )  Parameters  userID \nUser ID. option \nEnroll option. enrollID \nPointer to the enrolled user ID. This parameter can be different from userID when AUTO_ID option is used. imageQuality \nPointer to the image quality score to be returned. The score shows the quality of scanned fingerprint and is in the range of 0 ~ 100.  Return Values \nIf enroll succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_Enroll"
        },
        {
            "location": "/documents/API_Specification/#uf_enrollcontinue",
            "text": "Continues the enrollment process when the enroll mode is UF_ENROLL_TWO_TIMES2 or UF_ENROLL_TWO_TEMPLATES2.  UF_RET_CODE UF_EnrollContinue( UINT32 userID, UINT32* enrollID, UINT32* imageQuality )  Parameters  userID \nUser ID. enrollID \nPointer to the enrolled user ID. This parameter can be different from userID when AUTO_ID option is used. imageQuality \nPointer to the image quality score to be returned. The score shows the quality of scanned fingerprint and is in the range of 0 ~ 100.  Return Values \nIf enroll succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_EnrollContinue"
        },
        {
            "location": "/documents/API_Specification/#example_18",
            "text": "// To enroll user ID 10 with enroll option of ADD_NEW,  UINT32   mode ;  UF_RET_CODE   result   =   UF_GetSysParameter (   UF_SYS_ENROLL_MODE ,   & mode   );  UINT32   userID ,   imageQuality ;  result   =   UF_Enroll (   10 ,   UF_ENROLL_ADD_NEW ,   & userID ,   & imageQuality   );  // If enroll mode is UF_ENROLL_TWO_TIMES2 or UF_ENROLL_TWO_TEMPLATES2  If (   result   ==   UF_RET_SUCCESS \n     &&   ( mode   ==   UF_ENROLL_TWO_TEMPLATES2 \n         ||   mode   ==   UF_ENROLL_TWO_TIMES2   )   )  { \n     result   =   UF_EnrollContinue (   10 ,   & userID ,   & imageQuality   );  }",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_enrollafterverification",
            "text": "Enroll and Delete functions change the fingerprint DB stored in the module. For some applications, it might be necessary to obtain administrator\u2019s permission before enrolling or deleting fingerprints. To process these functions, a user with proper administration level should verify himself first. If there is no user with co1rresponding administration level, these commands will fail with UF_ERR_UNSUPPORTED error code. If the verification fails, UF_ERR_NOT_MATCH error code will be returned. The only exception is that  UF_EnrollAfterVerification  will succeed when the fingerprint DB is empty. In that case, the first user enrolled by  UF_EnrollAfterVerification  will have UF_ADMIN_LEVEL_ALL.  UF_RET_CODE UF_EnrollAfterVerification( UINT32 userID, UF_ENROLL_OPTION option, UINT32* enrollID, UINT32* imageQuality )  Parameters  userID \nUser ID. option \nEnroll option. enrollID \nPointer to the enrolled user ID. This parameter can be different from userID when AUTO_ID option is used. imageQuality \nPointer to the image quality score to be returned. The score shows the quality of scanned fingerprint and is in the range of 0 ~ 100.  Return Values \nIf enroll succeeds, return UF_RET_SUCCESS. If there is no user with corresponding administration level, return UF_ERR_UNSUPPORTED. If administrator\u2019s verification fails, return UF_ERR_NOT_MATCH. Otherwise, return the corresponding error code.",
            "title": "UF_EnrollAfterVerification"
        },
        {
            "location": "/documents/API_Specification/#uf_enrolltemplate",
            "text": "Enrolls a fingerprint template.  UF_RET_CODE UF_EnrollTemplate( UINT32 userID, UF_ENROLL_OPTION option, UINT32 templateSize, BYTE* templateData, UINT32* enrollID )  Parameters  userID \nUser ID. option \nEnroll option. templateSize \nSize of the template data. templateData \nPointer to the template data. enrollID \nPointer to the enrolled user ID. This parameter can be different from userID when AUTO_ID option is used.  Return Values \nIf enroll succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_EnrollTemplate"
        },
        {
            "location": "/documents/API_Specification/#uf_enrollmultipletemplates",
            "text": "Enrolls multiple templates to the specified ID.  UF_RET_CODE UF_EnrollMultipleTemplates( UINT32 userID, UF_ENROLL_OPTION option, int numOfTemplate, UINT32 templateSize, BYTE* templateData, UINT32* enrollID )  Parameters  userID \nUser ID. option \nEnroll option. numOfTemplate \nNumber of templates to be enrolled. templateSize \nSize of one template data. For example, when enroll 3 templates of 384 byte, this parameter is 384 not 1152. templateData \nPointer to the template data. enrollID \nPointer to the enrolled user ID. This parameter can be different from userID when AUTO_ID option is used.  Return Values \nIf enroll succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_EnrollMultipleTemplates"
        },
        {
            "location": "/documents/API_Specification/#uf_enrollimage",
            "text": "Enrolls a fingerprint image.  UF_RET_CODE UF_EnrollImage( UINT32 userID, UF_ENROLL_OPTION option, UINT32 imageSize, BYTE* imageData, UINT32* enrollID, UINT32* imageQuality )  Parameters  userID \nUser ID. option \nEnroll option. imageSize \nSize of the image data. imageData \nPointer to the raw image data. Note that it is not the pointer to UFImage, but the pointer to the raw pixel data without the UFImage header. enrollID \nPointer to the enrolled user ID. This parameter can be different from userID when AUTO_ID option is used.. imageQuality \nPointer to the image quality score to be returned. The score shows the quality of scanned fingerprint and is in the range of 0 ~ 100.  Return Values \nIf enroll succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_EnrollImage"
        },
        {
            "location": "/documents/API_Specification/#uf_setenrollcallback",
            "text": "Sets the callback function for enrollment process. This callback is called after receiving response packets with UF_PROTO_RET_SCAN_SUCCESS, UF_PROTO_RET_SUCCESS, or UF_PROTO_RET_CONTINUE messages.  void UF_SetEnrollCallback( void (*callback)( BYTE errCode, UF_ENROLL_MODE enrollMode, int numOfSuccess ) )  Parameters  callback \nPointer to the callback function.  Return Values \nNone",
            "title": "UF_SetEnrollCallback"
        },
        {
            "location": "/documents/API_Specification/#311-identify-api",
            "text": "Checks if a fingerprint input is among the enrolled user ids. While verification checks only the fingerprints of a specified user id, identification searches all the enrolled fingerprints until a match is found. As in enrollment, there are three ways to identify fingerprints; scanning live fingerprints, using scanned images, or sending templates acquired elsewhere.   UF_Identify: identifies the fingerprint input on the sensor.  UF_IdentifyTemplate: identifies a template.  UF_IdentifyImage: identifies a fingerprint image.  UF_SetIdentifyCallback: sets the callback function for identification.",
            "title": "3.11. Identify API"
        },
        {
            "location": "/documents/API_Specification/#uf_identify",
            "text": "Identifies the fingerprint input on the sensor.  UF_RET_CODE UF_Identify( UINT32* userID, BYTE* subID )  Parameters  userID \nPointer to the user ID to be returned. subID \nPointer to the index of the template to be returned.  Return Values \nIf matching succeeds, return UF_RET_SUCCESS. If matching fails, return UF_ERR_NOT_FOUND. Otherwise, return the corresponding error code.",
            "title": "UF_Identify"
        },
        {
            "location": "/documents/API_Specification/#uf_identifytemplate",
            "text": "Identifies a template.  UF_RET_CODE UF_IdentifyTemplate( UINT32 templateSize, BYTE* templateData, UINT32* userID, BYTE* subID )  Parameters  templateSize \nSize of the template data. templateData \nPointer to the template data. userID \nPointer to the user ID to be returned. subID \nPointer to the index of the template to be returned.  Return Values \nIf matching succeeds, return UF_RET_SUCCESS. If matching fails, return UF_ERR_NOT_FOUND. Otherwise, return the corresponding error code.",
            "title": "UF_IdentifyTemplate"
        },
        {
            "location": "/documents/API_Specification/#uf_identifyimage",
            "text": "Identifies a fingerprint image.  UF_RET_CODE UF_IdentifyImage( UINT32 imageSize, BYTE* imageData, UINT32* userID, BYTE* subID )     Parameters  imageSize \nSize of the image data. imageData \nPointer to the raw image data. Note that it is not the pointer to UFImage, but the pointer to the raw pixel data without the UFImage header. userID \nPointer to the user ID to be returned. subID \nPointer to the index of the template to be returned.  Return Values \nIf matching succeeds, return UF_RET_SUCCESS. If matching fails, return UF_ERR_NOT_FOUND. Otherwise, return the corresponding error code.",
            "title": "UF_IdentifyImage"
        },
        {
            "location": "/documents/API_Specification/#uf_setidentifycallback",
            "text": "Sets the callback function for identification process. This callback is called after receiving UF_PROTO_RET_SCAN_SUCCESS message.  void UF_SetIdentifyCallback( void (*callback)( BYTE ) )  Parameters  callback \nPointer to the callback function.  Return Values \nNone",
            "title": "UF_SetIdentifyCallback"
        },
        {
            "location": "/documents/API_Specification/#312-verify-api",
            "text": "Verifies if a fingerprint input matches the enrolled fingerprints of the specified user id. As in enroll process, there are three ways to verify fingerprints; scanning live fingerprints, using scanned images, or sending templates acquired elsewhere.   UF_Verify: verifies the fingerprint input on the sensor.  UF_VerifyTemplate: verifies a template.  UF_VerifyHostTemplate: verifies the fingerprint input on the sensor with the templates sent by the host.  UF_VerifyImage: verifies a fingerprint image.  UF_SetVerifyCallback: sets the callback function for verification process.",
            "title": "3.12. Verify API"
        },
        {
            "location": "/documents/API_Specification/#uf_verify",
            "text": "Verifies if a fingerprint input on the sensor matches the enrolled fingerprints of the specified user id.  UF_RET_CODE UF_Verify( UINT32 userID, BYTE* subID )  Parameters  userID \nUser ID. subID \nPointer to the index of the template to be returned.  Return Values \nIf matching succeeds, return UF_RET_SUCCESS. If matching fails, return UF_ERR_NOT_MATCH. Otherwise, return the corresponding error code.",
            "title": "UF_Verify"
        },
        {
            "location": "/documents/API_Specification/#uf_verifytemplate",
            "text": "Verifies a template.  UF_RET_CODE UF_VerifyTemplate( UINT32 templateSize, BYTE* templateData, UINT32 userID, BYTE* subID )  Parameters  templateSize \nSize of the template data. templateData \nPointer to the template data to be sent. userID \nUser ID. subID \nPointer to the index of the template to be returned.  Return Values \nIf matching succeeds, return UF_RET_SUCCESS. If matching fails, return UF_ERR_NOT_MATCH. Otherwise, return the corresponding error code.",
            "title": "UF_VerifyTemplate"
        },
        {
            "location": "/documents/API_Specification/#uf_verifyhosttemplate",
            "text": "Transmits fingerprint templates from the host to the module and verifies if they match the live fingerprint input on the sensor.  UF_RET_CODE UF_VerifyHostTemplate( UINT32 numOfTemplate, UINT32 templateSize, BYTE* templateData )  Parameters  numOfTemplate \nNumber of templates to be transferred to the module. templateSize \nSize of a template. templateData \nPointer to the template data to be transferred to the module.  Return Values \nIf matching succeeds, return UF_RET_SUCCESS. If matching fails, return UF_ERR_NOT_MATCH. Otherwise, return the corresponding error code.",
            "title": "UF_VerifyHostTemplate"
        },
        {
            "location": "/documents/API_Specification/#uf_verifyimage",
            "text": "Verifies a fingerprint image.  UF_RET_CODE UF_VerifyImage( UINT32 imageSize, BYTE* imageData, UINT32 userID, BYTE* subID )  Parameters  imageSize \nSize of the fingerprint image. imageData \nPointer to the raw image data. Note that it is not the pointer to UFImage, but the pointer to the raw pixel data without the UFImage header. userID \nUser ID. subID \nPointer to the index of the template to be returned.  Return Values \nIf matching succeeds, return UF_RET_SUCCESS. If matching fails, return UF_ERR_NOT_MATCH. Otherwise, return the corresponding error code.",
            "title": "UF_VerifyImage"
        },
        {
            "location": "/documents/API_Specification/#uf_setverifycallback",
            "text": "Sets the callback function for verification process. The callback function is called after receiving UF_PROTO_RET_SCAN_SUCCESS message.  void UF_SetVerifyCallback( void (*callback)( BYTE ) )  Parameters  callback \nPointer to the callback function.  Return Values \nNone",
            "title": "UF_SetVerifyCallback"
        },
        {
            "location": "/documents/API_Specification/#313-delete-api",
            "text": "Provides functions for deleting stored templates.   UF_Delete: deletes the templates of the specified user ID.  UF_DeleteOneTemplate: deletes one template of the specified user ID.  UF_DeleteMultipleTemplates: deletes the template of multiple user IDs.  UF_DeleteAll: deletes all the templates.  UF_DeleteAllAfterVerification: deletes templates after administrator\u2019s verification.  UF_SetDeleteCallback: sets the callback function for delete process.",
            "title": "3.13. Delete API"
        },
        {
            "location": "/documents/API_Specification/#uf_delete",
            "text": "Deletes the enrolled templates of the specified user ID.  UF_RET_CODE UF_Delete( UINT32 userID )  Parameters  userID \nUser ID.  Return Values \nIf delete succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_Delete"
        },
        {
            "location": "/documents/API_Specification/#uf_deleteonetemplate",
            "text": "Deletes one template of the specified user ID.  UF_RET_CODE UF_DeleteOneTemplate( UINT32 userID, int subID )  Parameters  userID \nUser ID. subID \nSub index of the template. It is between 0 and 9.  Return Values \nIf delete succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_DeleteOneTemplate"
        },
        {
            "location": "/documents/API_Specification/#uf_deletemultipletemplates",
            "text": "Deletes the enrolled templates of multiple user IDs.  UF_RET_CODE UF_DeleteMultipleTemplates( UINT32 startUserID, UINT32 lastUserID, int* deletedUserID )  Parameters    startUserID \nFirst user ID to be deleted. lastUserID \nLast user ID to be deleted. deletedUserID    \nPointer to the number of IDs to be actually deleted by the module.  Return Values \nIf delete succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_DeleteMultipleTemplates"
        },
        {
            "location": "/documents/API_Specification/#example_19",
            "text": "// Delete templates of ID 10 ~ ID 20  int   numOfDeleted ;  UF_RET_CODE   result   =   UF_DeleteMultipleTemplates (   10 ,   20 ,   & numOfDeleted   );",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_deleteall",
            "text": "Deletes all the templates stored in a module.  UF_RET_CODE UF_DeleteAll()  Parameters \nNone  Return Values \nIf delete succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_DeleteAll"
        },
        {
            "location": "/documents/API_Specification/#uf_deleteallafterverification",
            "text": "Deletes all the templates after administrator\u2019s verification.  UF_RET_CODE UF_DeleteAllAfterVerification()  Parameters \nNone  Return Values \nIf delete succeeds, return UF_RET_SUCCESS. If there is no user with corresponding administration level, return UF_ERR_UNSUPPORTED. If administrator\u2019s verification fails, return UF_ERR_NOT_MATCH. Otherwise, return the corresponding error code.",
            "title": "UF_DeleteAllAfterVerification"
        },
        {
            "location": "/documents/API_Specification/#uf_setdeletecallback",
            "text": "Sets the callback function for delete process. This callback is called after receiving UF_PROTO_RET_SCAN_SUCCESS or UF_PROTO_RET_CONTINUE.  void UF_SetDeleteCallback( void (*callback)( BYTE ) )  Parameters  callback \nPointer to the callback function.  Return Values \nNone",
            "title": "UF_SetDeleteCallback"
        },
        {
            "location": "/documents/API_Specification/#314-io-api-for-sfm3500",
            "text": "SFM3500 modules have three input ports, three output ports, and three LED ports which are configurable for specific functions. For BioEntry Smart and Pass, there are two input ports, two output ports, and 2 LED ports. These functions are provided to configure these IO ports.   UF_InitIO: clears the output event caches.  UF_SetInputFunction: sets the function of an input port.  UF_GetInputFunction: gets the function of an input port.  UF_GetInputStatus: gets the status of an input port.  UF_GetOutputEventList: gets the output events list assigned to an output port.  UF_ClearAllOutputEvent: clears all the output events assigned to an output port.  UF_ClearOutputEvent: clears an output event assigned to an output port.  UF_SetOutputEvent: adds an output event to an output port.  UF_GetOutputEvent: gets the signal data of an output event.  UF_SetOutputStatus: sets the status of an output port.  UF_SetLegacyWiegandConfig: sets the Wiegand format.  UF_GetLegacyWiegandConfig: gets the Wiegand format.  UF_MakeIOConfiguration: makes IO configuration data to be saved into a file.",
            "title": "3.14. IO API for SFM3500"
        },
        {
            "location": "/documents/API_Specification/#uf_initio",
            "text": "To prevent redundant communication, the SFM SDK caches the output events previously read or written.  UF_InitIO  clears the cache. It is called in  UF_Reconnect .",
            "title": "UF_InitIO"
        },
        {
            "location": "/documents/API_Specification/#void-uf_initio",
            "text": "Parameters \nNone  Return Values \nNone",
            "title": "void UF_InitIO()"
        },
        {
            "location": "/documents/API_Specification/#uf_setinputfunction",
            "text": "Sets the function of an input port. Available functions are as follows;     Function  Description      UF_INPUT_NO_ACTION  No action    UF_INPUT_ENROLL  Enroll    UF_INPUT_IDENTIFY  Identify    UF_INPUT_DELETE  Delete    UF_INPUT_DELETE_ALL  Delete all    UF_INPUT_ENROLL_BY_WIEGAND  Enroll by Wiegand ID    UF_INPUT_VERIFY_BY_WIEGAND  Verify by Wiegand ID    UF_INPUT_DELETE_BY_WIEGAND  Delete by Wiegand ID    UF_INPUT_ENROLL_VERIFICATION  Enroll after administrator\u2019s verification    UF_INPUT_ENROLL_BY_WIEGAND_VERIFICATION  Enroll by Wiegand ID after administrator\u2019s verification    UF_INPUT_DELETE_VERIFICATION  Delete after administrator\u2019s verification    UF_INPUT_DELETE_BY_WIEGAND_VERIFICATION  Delete by Wiegand ID after administrator\u2019s verification    UF_INPUT_DELETE_ALL_VERIFICATION  Delete all after administrator\u2019s verification    UF_INPUT_CANCEL  Cancel    UF_INPUT_TAMPER_SWITCH_IN  Tamper switch. When the tamper switch is on, Tamper Switch On(0x64) event occurred. When it gets off, Tamper Switch Off(0x65) event occurred. Both events are recorded in log, too. In BioEntry Smart and Pass, UF_INPUT_PORT2 is assigned to Tamper SW.    UF_INPUT_RESET  Reset the module     UF_RET_CODE UF_SetInputFunction( UF_INPUT_PORT port, UF_INPUT_FUNC inputFunction, UINT32 minimumTime )  Parameters  port \nOne of the three input ports \u2013 UF_INPUT_PORT0, UF_INPUT_PORT1, and UF_INPUT_PORT2. For BioEntry Smart and Pass, UF_INPUT_PORT2 is assigned to Tamper SW and not configurable. inputFunction \nInput function. minimumTime \nMinimum duration after which the input signal is acknowledged as active.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetInputFunction"
        },
        {
            "location": "/documents/API_Specification/#uf_getinputfunction",
            "text": "Gets the function assigned to an input port. UF_RET_CODE UF_GetInputFunction( UF_INPUT_PORT port, UF_INPUT_FUNC* inputFunction, UINT32* minimumTime )  Parameters  port \nInput port. inputFunction \nPointer to the input function to be returned. minimumTime \nPointer to the minimum duration of input signal to be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetInputFunction"
        },
        {
            "location": "/documents/API_Specification/#uf_getinputstatus",
            "text": "Gets the status of an input port.  UF_RET_CODE UF_GetInputStatus( UF_INPUT_PORT port, BOOL remainStatus, UINT32* status )  Parameters  port \nInput port. remainStatus \nIf TRUE, don\u2019t change the status of the input port after reading. If FALSE, clear the status of the input port. status \nPointer to the status of the input port to be read. 0 for inactive and 1 for active status.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetInputStatus"
        },
        {
            "location": "/documents/API_Specification/#uf_getoutputeventlist",
            "text": "Gets the list of output events assigned to an output/LED port. Available output events are as follows;     Category  Event      Enroll  UF_OUTPUT_ENROLL_WAIT_WIEGAND     UF_OUTPUT_ENROLL_WAIT_FINGER     UF_OUTPUT_ENROLL_PROCESSING     UF_OUTPUT_ENROLL_BAD_FINGER     UF_OUTPUT_ENROLL_SUCCESS     UF_OUTPUT_ENROLL_FAIL    Verify  UF_OUTPUT_VERIFY_WAIT_WIEGAND     UF_OUTPUT_VERIFY_WAIT_FINGER     UF_OUTPUT_VERIFY_PROCESSING     UF_OUTPUT_VERIFY_BAD_FINGER     UF_OUTPUT_VERIFY_SUCCESS     UF_OUTPUT_VERIFY_FAIL    Identify  UF_OUTPUT_IDENTIFY_WAIT_FINGER     UF_OUTPUT_IDENTIFY_PROCESSING     UF_OUTPUT_IDENTIFY_BAD_FINGER     UF_OUTPUT_IDENTIFY_SUCCESS     UF_OUTPUT_IDENTIFY_FAIL    Delete  UF_OUTPUT_DELETE_WAIT_WIEGAND     UF_OUTPUT_DELETE_WAIT_FINGER     UF_OUTPUT_DELETE_PROCESSING     UF_OUTPUT_DELETE_BAD_FINGER     UF_OUTPUT_DELETE_SUCCESS     UF_OUTPUT_DELETE_FAIL    Detect  UF_OUTPUT_DETECT_INPUT0     UF_OUTPUT_DETECT_INPUT1     UF_OUTPUT_DETECT_INPUT2     UF_OUTPUT_DETECT_WIEGAND     UF_OUTPUT_DETECT_FINGER    End Processing  UF_OUTPUT_END_PROCESSING    Duress  UF_OUTPUT_VERIFY_DURESS     UF_OUTPUT_IDENTIFY_DURESS    Tamper SW  UF_OUTPUT_TAMPER_SWITCH_ON     UF_OUTPUT_TAMPER_SWITCH_OFF    System  UF_OUTPUT_SYS_STARTED    SmartCard (Available only for BioEntry Smart)  UF_OUTPUT_DETECT_SMARTCARD     UF_OUTPUT_BAD_SMARTCARD     UF_OUTPUT_WAIT_SMARTCARD     UF_RET_CODE UF_GetOutputEventList( UF_OUTPUT_PORT port, UF_OUTPUT_EVENT* events, int* numOfEvent )  Parameters  port \nOutput/LED port. events \nArray of output events to be returned. numOfEvent \nPointer to the number of output events to be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetOutputEventList"
        },
        {
            "location": "/documents/API_Specification/#example_20",
            "text": "// To read the output events assigned to OUT0  UF_OUTPUT_EVENT   events [ UF_MAX_OUTPUT_PER_PORT ];  int   numOfEvent ;  UF_RET_CODE   result   =   UF_GetOutputEventList (   UF_OUTPUT_PORT0 ,   events ,  & numOfEvent   );",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_clearalloutputevent",
            "text": "Clears all the output events assigned to an output/LED port.  UF_RET_CODE UF_ClearAllOutputEvent( UF_OUTPUT_PORT port )  Parameters  port \nOutput/LED port.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ClearAllOutputEvent"
        },
        {
            "location": "/documents/API_Specification/#uf_clearoutputevent",
            "text": "Clears the specified output event from the output port.  UF_RET_CODE UF_ClearOutputEvent( UF_OUTPUT_PORT port, UF_OUTPUT_EVENT event )  Parameters  port \nOutput/LED port. event \nOutput event to be deleted from the output/LED port.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ClearOutputEvent"
        },
        {
            "location": "/documents/API_Specification/#uf_setoutputevent",
            "text": "Adds an output event to the specified output/LED port. The characteristics of output signal is also specified.     typedef   struct   { \n     unsigned   short   delay ;   // t_delay \n     unsigned   short   count ;   // t_count \n     unsigned   short   active ;   // t_high \n     unsigned   short   inactive ;   // t_low  }   UFOutputSignal ;   UF_RET_CODE UF_SetOutputEvent( UF_OUTPUT_PORT port, UF_OUTPUT_EVENT event, UFOutputSignal signal )  Parameters  port \nOutput/LED port. event \nOutput event to be added. signal \nSignal specification of the output event.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetOutputEvent"
        },
        {
            "location": "/documents/API_Specification/#example_21",
            "text": "// To turn on the LED0 for 500ms when verification succeeds,  UFOutputSignal   signal ;  signal . delay   =   0 ;  signal . count   =   1 ;  signal . active   =   500 ;  signal . inactive   =   0 ;  UF_RET_CODE   result   =   UF_SetOutputEvent (   UF_OUTPUT_LED0 ,  UF_OUTPUT_VERIFY_SUCCESS ,   signal   );",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_getoutputevent",
            "text": "Gets the signal data of an output event on the specified output/LED port. UF_RET_CODE UF_GetOutputEvent( UF_OUTPUT_PORT port, UF_OUTPUT_EVENT event, UFOutputSignal* signal )  Parameters  port \nOutput/LED port. event \nOutput event. signal \nPointer to the signal data to be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetOutputEvent"
        },
        {
            "location": "/documents/API_Specification/#uf_setoutputstatus",
            "text": "Sets the status of an output/LED port.  UF_RET_CODE UF_SetOutputStatus( UF_OUTPUT_PORT port, BOOL status )  Parameters  port \nOutput/LED port. status \nTRUE for active and FALSE for inactive status.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetOutputStatus"
        },
        {
            "location": "/documents/API_Specification/#uf_setlegacywiegandconfigdeprecated",
            "text": "Until the firmware V1.3, SFM 3500 modules only support 26 bit Wiegand format. Since the firmware V1.4, Extended Wiegand Interface is provided, which is much more powerful and flexible.  UF_SetLegacyWiegandConfig  configures the legacy 26 bit Wiegand format and is provided only for firmwares older than V1.4.  UF_RET_CODE UF_SetLegacyWiegandConfig( BOOL enableInput, BOOL enableOutput, UINT32 fcBits, UINT32 fcCode )  Parameters  enableInput \nIf TRUE, the module starts verification process when receiving Wiegand inputs. enableOutput \nIf TURE, the module outputs the user ID when verification or identification succeeds. fcBits \nSpecifies the number of facility bits. fcCode \nSpecifies the facility code.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetLegacyWiegandConfig(Deprecated)"
        },
        {
            "location": "/documents/API_Specification/#uf_getlegacywiegandconfigdeprecated",
            "text": "Gets the configuration of the 26 bit Wiegand format.  UF_RET_CODE UF_GetLegacyWiegandConfig( BOOL* enableInput, BOOL* enableOutput, UINT32* fcBits, UINT32* fcCode )  Parameters  enableInput \nPointer to the input enable status. enableOutput \nPointer to the output enable status. fcBits \nPointer to the number of facility bits to be returned. fcCode \nPointer to the facility code to be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetLegacyWiegandConfig(Deprecated)"
        },
        {
            "location": "/documents/API_Specification/#uf_makeioconfiguration",
            "text": "Makes IO configuration data to be saved into a file. See the example of  UF_SaveConfiguration  for the usage of this function.  UF_RET_CODE UF_MakeIOConfiguration( UFConfigComponentHeader* configHeader, BYTE* configData )  Parameters  configHeader \nPointer to the configuration header to be returned. configData \nPointer to the configuration data to be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_MakeIOConfiguration"
        },
        {
            "location": "/documents/API_Specification/#315-gpio-api-for-sfm300040005000",
            "text": "SFM3000 series modules have 8 GPIO ports, which are configurable for specific functions. The function of each GPIO can be read and programmed via these APIs. . GPIO port can be configured as input, output, shared I/O, Wiegand input, or Wiegand output. In the input mode, enroll, identify, and delete functions are supported. In the output mode, the port can send output patterns corresponding to the various events such as match success, enroll fail, and so on.   UF_GetGPIOConfiguration: gets the configuration data of a GPIO port.  UF_SetInputGPIO: configures an input GPIO port.  UF_SetOutputGPIO: configures an output GPIO port.  UF_SetSharedGPIO: configures a shared I/O port.  UF_DisableGPIO: disables a GPIO port.  UF_ClearAllGPIO: clears all the GPIO configurations.  UF_SetDefaultGPIO: resets to default GPIO configurations.  UF_EnableWiegandInput: enables Wiegand input.  UF_EnableWiegandOutput: enables Wiegand output.  UF_DisableWiegandInput: disables Wiegand input.  UF_DisableWiegandOutput: disables Wiegand output.  UF_MakeGPIOConfiguration: makes GPIO configuration data to be saved into a file.",
            "title": "3.15. GPIO API for SFM3000/4000/5000"
        },
        {
            "location": "/documents/API_Specification/#uf_getgpioconfiguration",
            "text": "Gets the configuration data of a GPIO port.  UF_RET_CODE UF_GetGPIOConfiguration( UF_GPIO_PORT port, UF_GPIO_MODE* mode, int* numOfData, UFGPIOData* data )  Parameters  port \nGPIO port from UF_GPIO_0 to UF_GPIO_7. mode \nPointer to the GPIO mode to be returned. Available GPIO modes are as follows;     Mode  Description      UF_GPIO_INPUT  Input port    UF_GPIO_OUTPUT  Output port    UF_GPIO_SHARED_IO  Shared IO port    UF_GPIO_WIEGAND_INPUT  Wiegand input port    UF_GPIO_WIEGAND_OUTPUT  Wiegand output port     numOfData \nNumber of configuration data assigned to the port. data \nArray of GPIO configuration data to be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetGPIOConfiguration"
        },
        {
            "location": "/documents/API_Specification/#example_22",
            "text": "// To retrieve the configuration data of GPIO 0  UFGPIOData   configData [ UF_MAX_GPIO_OUTPUT_EVENT ];  UF_GPIO_MODE   mode ;  int   numOfData ;  UF_RET_CODE   result   =   UF_GetGPIOConfiguration (   UF_GPIO_0 ,   & mode ,   & numOfData ,   configData   );",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_setinputgpio",
            "text": "Configures an input GPIO port.  UF_RET_CODE UF_SetInputGPIO( UF_GPIO_PORT port, UFGPIOInputData data )  Parameters  port \nGPIO port. Only GPIO 0 to GPIO 3 can be an input port. data \nUFGPIOInputData is defined as follows;  typedef   struct   { \n     unsigned   short   inputFunction ;   // See UF_GPIO_INPUT_FUNC \n                                   // in UF_3000IO.h \n     unsigned   short   activationLevel ;   // See UF_GPIO_INPUT_ACTIVATION \n                                   // in UF_3000IO.h \n     unsigned   short   timeout ;   // valid only if inputFUnction is \n                             // UF_GPIO_IN_DELETE_ALL or \n                             // UF_GPIO_IN_DELETE_ALL_VERIFICATION \n     unsigned   short   reserved ;  }   UFGPIOInputData ;   Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetInputGPIO"
        },
        {
            "location": "/documents/API_Specification/#example_23",
            "text": "// To assign identify to GPIO 0 with ACTIVE_HIGH signal  UFGPIOInputData   inputData ;  inputData . inputFunction   =   UF_GPIO_IN_IDENTIFY ;  inputData . activationLevel   =   UF_GPIO_IN_ACTIVE_HIGH ;  UF_RET_CODE   result   =   UF_SetInputGPIO (   UF_GPIO_0 ,   inputData   );",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_setoutputgpio",
            "text": "Configures an output GPIO port.  UF_RET_CODE UF_SetOutputGPIO( UF_GPIO_PORT port, int numOfData, UFGPIOOutputData* data )  Parameters  port \nGPIO port. numOfData \nNumber of UFGPIOOutputData to be assigned to the GPIO port. data \nArray of UFGPIOOutputData to be assigned to the GPIO port.\nUFGPIOOutputData is defined as follows;  typedef   struct   { \n     unsigned   short   event ;   // see UF_GPIO_OUTPUT_EVENT \n                           // in UF_3000IO.h \n     unsigned   short   level ;   // see UF_GPIO_OUTPUT_LEVEL \n     unsigned   short   interval ;   // in milliseconds \n     unsigned   short   blinkingPeriod ;   // valid only if the level is \n                 // UF_GPIO_OUT_HIGH_BLINK or UF_GPIO_OUT_LOW_BLINK  }   UFGPIOOutputData ;   Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetOutputGPIO"
        },
        {
            "location": "/documents/API_Specification/#uf_setsharedgpio",
            "text": "Configures the shared I/O GPIO port.  UF_RET_CODE UF_SetSharedGPIO( UF_GPIO_PORT port, UFGPIOInputData inputData, int numOfOutputData, UFGPIOOutputData* outputData )  Parameters  port \nGPIO port. Only GPIO 0 to GPIO 3 can be a shared I/O port. inputData \nInput data to be assigned. numOfOutputData \nNumber of UFGPIOOutputData to be assigned. outputData \nArray of UFGPIOOutputData to be assigned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetSharedGPIO"
        },
        {
            "location": "/documents/API_Specification/#uf_disablegpio",
            "text": "Disables a GPIO port.  UF_RET_CODE UF_DisableGPIO( UF_GPIO_PORT port )  Parameters  port \nGPIO port.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_DisableGPIO"
        },
        {
            "location": "/documents/API_Specification/#uf_clearallgpio",
            "text": "Clears all the configurations of GPIO ports.  UF_RET_CODE UF_ClearAllGPIO()  Parameters \nNone  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ClearAllGPIO"
        },
        {
            "location": "/documents/API_Specification/#uf_setdefaultgpio",
            "text": "Resets the configurations of GPIO ports to default.  UF_RET_CODE UF_SetDefaultGPIO()  Parameters \nNone  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetDefaultGPIO"
        },
        {
            "location": "/documents/API_Specification/#uf_enablewiegandinput",
            "text": "Enables Wiegand input. Wiegand input uses GPIO 2 and GPIO 3 as input signal.  UF_RET_CODE UF_EnableWiegandInput( UFGPIOWiegandData data )  Parameters  data \nUFGPIOWiegandData is defined as follows;  typedef   struct   { \n     unsigned   short   totalBits ;   // fixed at 26 bit \n     unsigned   short   fcBits ;   // number of facility bits \n     unsigned   short   idBits ;   // number of id bits \n     unsigned   short   fcCode ;   // facility code  }   UFGPIOWiegandData ;   Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_EnableWiegandInput"
        },
        {
            "location": "/documents/API_Specification/#uf_enablewiegandoutput",
            "text": "Enables Wiegand output. Wiegand output use GPIO 4 and GPIO 5 as output signal.  UF_RET_CODE UF_EnableWiegandOutput( UFGPIOWiegandData data )  Parameters  data \nWiegand configuration data.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_EnableWiegandOutput"
        },
        {
            "location": "/documents/API_Specification/#uf_disablewiegandinput",
            "text": "Disables Wiegand input.  UF_RET_CODE UF_DisableWiegandInput()  Parameters \nNone  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_DisableWiegandInput"
        },
        {
            "location": "/documents/API_Specification/#uf_disablewiegandoutput",
            "text": "Disables Wiegand output.  UF_RET_CODE UF_DisableWiegandOutput()  Parameters \nNone  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_DisableWiegandOutput"
        },
        {
            "location": "/documents/API_Specification/#uf_makegpioconfiguration",
            "text": "Makes GPIO configuration data to be saved into a file.  UF_RET_CODE UF_MakeGPIOConfiguration( UFConfigComponentHeader* configHeader, BYTE* configData )  Parameters  configHeader \nPointer to the configuration header. configData \nPointer to the configuration data.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_MakeGPIOConfiguration"
        },
        {
            "location": "/documents/API_Specification/#example_24",
            "text": "See CUniFingerUI3000IOView::OnGpioSaveFile in UniFingerUI source codes.",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#316-user-memory-api",
            "text": "SFM modules reserve 256 bytes for user data. This area can be read and written by these APIs.\n- UF_WriteUserMemory: writes data to the user memory.\n- UF_ReadUserMemory: reads the contents of the user memory.",
            "title": "3.16. User Memory API"
        },
        {
            "location": "/documents/API_Specification/#uf_writeusermemory",
            "text": "Writes data into the user memory.  UF_RET_CODE UF_WriteUserMemory( BYTE* memory )  Parameters  memory \nPointer to the 256 byte array to be written.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_WriteUserMemory"
        },
        {
            "location": "/documents/API_Specification/#uf_readusermemory",
            "text": "Reads the contents of the user memory.  UF_RET_CODE UF_ReadUserMemory( BYTE* memory )  Parameters  memory \nPointer to the 256 byte array to be read.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ReadUserMemory"
        },
        {
            "location": "/documents/API_Specification/#317-log-management-api",
            "text": "SFM3500 modules provide logging facility for recording important events. Users can receive logs from the module and delete unwanted ones. The format of a log record is as follows;     Item  Description  Size      Source  UF_LOG_SOURCE_HOST_PORT  1 byte     UF_LOG_SOURCE_AUX_PORT      UF_LOG_SOURCE_WIEGAND_INPUT      UF_LOG_SOURCE_IN0      UF_LOG_SOURCE_IN1      UF_LOG_SOURCE_IN2      UF_LOG_SOURCE_FREESCAN      UF_LOG_SOURCE_SMARTCARD     Event ID  One of the UF_OUTPUT_EVENT  1 byte    Date  (DD << 16) / (MM << 8) / YY  3 bytes    Time  (ss << 16) / (mm << 8) / hh  3 bytes    User ID  User ID  4 bytes    Custom Field  Customizable by user  4 bytes     In V1.6 firmware, there are two enhancements for logging functions. First, 4 byte custom field is added to log records. Making use of this field, users can add customized events to log records. Second, the log cache is added for real-time monitoring.   UF_SetTime: sets the time of the module.  UF_GetTime: gets the time of the module.  UF_GetNumOfLog: gets the number of log records.  UF_ReadLog: reads log records.  UF_ReadLatestLog: reads latest log records.  UF_DeleteOldestLog: deletes oldest log records.  UF_DeleteAllLog: deletes all the log records.  UF_ClearLogCache: clears the log cache.  UF_ReadLogCache: reads the log records in the cache.  UF_SetCustomLogField: sets the custom field of log records.  UF_GetCustomLogField: gets the custom field of log records.",
            "title": "3.17. Log Management API"
        },
        {
            "location": "/documents/API_Specification/#uf_settime",
            "text": "Sets the time of the module.  UF_RET_CODE UF_SetTime( time_t timeVal )  Parameters  timeVal \nNumber of seconds elapsed since midnight (00:00:00), January 1, 1970.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetTime"
        },
        {
            "location": "/documents/API_Specification/#uf_gettime",
            "text": "Gets the time of the module.  UF_RET_CODE UF_GetTime( time_t* timeVal )  Parameters  timeVal \nPointer to the time value to be returned by the module.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetTime"
        },
        {
            "location": "/documents/API_Specification/#uf_getnumoflog",
            "text": "Retrieves the number of log records.  UF_RET_CODE UF_GetNumOfLog( int* numOfLog, int* numOfTotalLog )  Parameters  numOfLog \nPointer to the number of log records to be returned. numOfTotalLog \nPointer to the maximum log records to be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetNumOfLog"
        },
        {
            "location": "/documents/API_Specification/#uf_readlog",
            "text": "Reads log records.  UF_RET_CODE UF_ReadLog( int startIndex, int count, UFLogRecord* logRecord, int* readCount )  Parameters  startIndex \nStart index of log records to be read. count \nNumber of log records to be read. logRecord \nPointer to the log records to be read. readCount \nPointer to the number of log records actually read.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ReadLog"
        },
        {
            "location": "/documents/API_Specification/#uf_readlatestlog",
            "text": "Reads latest log records.  UF_RET_CODE UF_ReadLatestLog( int count, UFLogRecord* logRecord, int* readCount )  Parameters  count \nNumber of latest log records to be read. logRecord \nPointer to the log records to be read. readCount \nPointer to the number of log records actually read.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ReadLatestLog"
        },
        {
            "location": "/documents/API_Specification/#uf_deleteoldestlog",
            "text": "Deletes oldest log records.  UF_RET_CODE UF_DeleteOldestLog( int count, int* deletedCount )  Parameters  count \nNumber of oldest log records to be deleted. It should be a multiple of 256. deletedCount \nPointer to the number of log records actually deleted.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_DeleteOldestLog"
        },
        {
            "location": "/documents/API_Specification/#uf_deletealllog",
            "text": "Deletes all the log records.  UF_RET_CODE UF_DeleteAllLog()  Parameters \nNone  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_DeleteAllLog"
        },
        {
            "location": "/documents/API_Specification/#uf_clearlogcache",
            "text": "Clears the log cache.  UF_RET_CODE UF_ClearLogCache()  Parameters \nNone  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ClearLogCache"
        },
        {
            "location": "/documents/API_Specification/#uf_readlogcache",
            "text": "Reads the log records in the cache. After reading, the cache will be cleared. The maximum number of log records in the cache is 256.  UF_RET_CODE UF_ReadLogCache( int dataPacketSize, int* numOfLog, UFLogRecord* logRecord )  Parameters  dataPacketSize \nData packet size used in Extended Data Transfer protocol. numOfLog \nPointer to the number of log records to be returned. logRecord \nPointer to the log records to be returned. This pointer should be preallocated large enough to store the log records.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ReadLogCache"
        },
        {
            "location": "/documents/API_Specification/#uf_setcustomlogfield",
            "text": "There is a 4 byte reserved field in each log record. This function is used for setting this custom value. If the custom field is not set, it will be filled with NULL.  UF_RET_CODE UF_SetCustomLogField( UF_LOG_SOURCE source, unsigned customField )  Parameters  source \nUsers can set 4 different custom values according to the source of log records.     Source  Description      UF_LOG_SOURCE_OTHER  If the log is generated by Packet Protocol commands or freescan, this value will be used.    UF_LOG_SOURCE_IN0     UF_LOG_SOURCE_IN1     UF_LOG_SOURCE_IN2  If the log is generated by an Input port, the respective values will be used.     customField \n4 byte custom value.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetCustomLogField"
        },
        {
            "location": "/documents/API_Specification/#uf_getcustomlogfield",
            "text": "Reads the custom value of the specified log source.  UF_RET_CODE UF_GetCustomLogField( UF_LOG_SOURCE source, unsigned* customField )  Parameters     source \nLog source. customField \nPointer to the 4 byte custom value to be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetCustomLogField"
        },
        {
            "location": "/documents/API_Specification/#318-extended-wiegand-api",
            "text": "Extended Wiegand Interface supports up to 64 bit Wiegand formats. The only constraint is that the ID field is limited to 32 bits. It also supports advanced options such as Fail ID and Inverse Parity on Fail.   UF_SetWiegandFormat: configures the Wiegand format.  UF_GetWiegandFormat: gets the Wiegand format information.  UF_SetWiegandIO: configures the Wiegand IO ports.  UF_GetWiegandIO: gets the configurations of the Wiegand IO ports.  UF_SetWiegandOption: sets the advanced options.  UF_GetWiegandOption: gets the advanced options.  UF_SetAltValue: sets the alternative value of a field.  UF_ClearAltValue: clears the alternative value of a field.  UF_GetAltValue: gets the alternative value of a field.  UF_MakeWiegandConfiguration: makes Wiegand configuration data to be saved into a file.",
            "title": "3.18. Extended Wiegand API"
        },
        {
            "location": "/documents/API_Specification/#uf_setwiegandformat",
            "text": "Configures the Wiegand format.  UF_RET_CODE UF_SetWiegandFormat( UFWiegandFormatHeader* header, UFWiegandFormatData* data, int pulseWidth, int pulseInterval )  Parameters  header \nUFWiegandFormatHeader is defined as follows;  typedef   struct   { \n     UF_WIEGAND_FORMAT   format ;   // UF_WIEGAND_26BIT, \n                              // UF_WIEGAND_PASS_THRU, \n                              // UF_WIEGAND_CUSTOM \n     int               totalBits ;  }   UFWiegandFormatHeader ;   data \nWiegand format data. If the format is UF_WIEGAND_26BIT, there is no format data and this parameter will be ignored. UFWiegandFormatData is defined as follows;  typedef   struct   { \n     int                  numOfIDField ; \n     UFWiegandField       field [ MAX_WIEGAND_FIELD ];  }   UFWiegandPassThruData ;  typedef   struct   { \n     int                  numOfField ; \n     UINT32               idFieldMask ; \n     UFWiegandField       field [ MAX_WIEGAND_FIELD ]; \n     int                  numOfParity ; \n     UFWiegandParity      parity [ MAX_WIEGAND_PARITY ];  }   UFWiegandCustomData ;  typedef   union   { \n     UFWiegandPassThruData     passThruData ; \n     UFWiegandCustomData       customData ;  }   UFWiegandFormatData ;   pulseWidth \nSpecifies the width of Wiegand signal. pulseInterval \nSpecifies the interval of Wiegand signal.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetWiegandFormat"
        },
        {
            "location": "/documents/API_Specification/#uf_getwiegandformat",
            "text": "Gets the Wiegand format data.  UF_RET_CODE UF_GetWiegandFormat( UFWiegandFormatHeader* header, UFWiegandFormatData* data, int* pulseWidth, int* pulseInterval )  Parameters  header \nPointer to the format header to be returned. data \nPointer to the format data to be returned. pulseWidth \nPointer to the width of Wiegand signal. pulseInterval \nPointer to the interval of Wiegand signal.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetWiegandFormat"
        },
        {
            "location": "/documents/API_Specification/#uf_setwiegandio",
            "text": "Configures the Wiegand IO ports.  UF_RET_CODE UF_SetWiegandIO( UF_WIEGAND_INPUT_MODE inputMode, UF_WIEGAND_OUTPUT_MODE outputMode, int numOfChar )  Parameters  inputMode        Mode  Description      UF_WIEGAND_INPUT_DISABLE  Ignores Wiegand inputs.    UF_WIEGAND_INPUT_VERIFY  Starts verification after receiving Wiegand inputs.     outputMode        Mode  Description      UF_WIEGAND_OUTPUT_DISABLE  Disables Wiegand output.    UF_WIEGAND_OUTPUT_WIEGAND_ONLY  Outputs Wiegand signal only if the verification is initiated by Wiegand input.    UF_WIEGAND_OUTPUT_ALL  Outputs Wiegand signal if matching succeeds.    UF_WIEGAND_OUTPUT_ABA_TRACK_II  Outputs ABA Track II characters instead of Wiegand signal.     numOfChar \nNumber of characters in ABA Track II output format. It is ignored if\noutputMode is not UF_WIEGAND_OUTPUT_ABA_TRACK_II.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetWiegandIO"
        },
        {
            "location": "/documents/API_Specification/#uf_getwiegandio",
            "text": "Gets the configurations of Wiegand IO ports.  UF_RET_CODE UF_GetWiegandIO( UF_WIEGAND_INPUT_MODE* inputMode, UF_WIEGAND_OUTPUT_MODE* outputMode, int* numOfChar )  Parameters  inputMode \nPointer to Wiegand input mode to be returned. outputMode \nPointer to Wiegand output mode to be returned. numOfChar \nPointer to the number of characters in ABA Track II output format. It is ignored if outputMode is not UF_WIEGAND_OUTPUT_ABA_TRACK_II.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetWiegandIO"
        },
        {
            "location": "/documents/API_Specification/#uf_setwiegandoption",
            "text": "Sets advanced options.  UF_RET_CODE UF_SetWiegandOption( BOOL useFailID, UINT32 failID, BOOL inverseParityOnFail )  Parameters  useFailID \nNormally the module outputs Wiegand signal only if matching succeeds. If this option is TRUE, the module outputs the fail ID when matching fails. failID \nID to be output if useFailID is TRUE. inverseParityOnFail \nIf this option is TRUE, the module outputs Wiegand signals with inverted parities when matching fails.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetWiegandOption"
        },
        {
            "location": "/documents/API_Specification/#uf_getwiegandoption",
            "text": "Gets the advanced options.  UF_RET_CODE UF_GetWiegandOption( BOOL* useFailID, UINT32* failID, BOOL* inverseParityOnFail )  Parameters  userFailID \nPointer to the useFailID option to be returned. failID \nPointer to the fail ID to be returned. inverseParityOnFail \nPointer to the inverseParityOnFail option to be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetWiegandOption"
        },
        {
            "location": "/documents/API_Specification/#uf_setaltvalue",
            "text": "If the Wiegand format is UF_WIEGAND_26BIT or UF_WIEGAND_CUSTOM, users can set alternative values for non-ID fields. If an alternative value is set for a non-ID field, the module will replace the field with the alternative value before outputting the signal.  UF_RET_CODE UF_SetAltValue( int fieldIndex, UINT32 value )  Parameters  fieldIndex \nIndex of the field. value \nAlternative value of the field.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetAltValue"
        },
        {
            "location": "/documents/API_Specification/#uf_clearaltvalue",
            "text": "Clears the alternative value of a field.  UF_RET_CODE UF_ClearAltValue( int fieldIndex )  Parameters  fieldIndex \nIndex of the field.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ClearAltValue"
        },
        {
            "location": "/documents/API_Specification/#uf_getaltvalue",
            "text": "Gets the alternative value of a field.  UF_RET_CODE UF_GetAltValue( int fieldIndex, UINT32* value )  Parameters  fieldIndex \nIndex of the field. value \nAlternative value of the field to be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. If alternative value is not set to the field, return UF_ERR_NOT_FOUND. Otherwise, return the corresponding error code.",
            "title": "UF_GetAltValue"
        },
        {
            "location": "/documents/API_Specification/#uf_makewiegandconfiguration",
            "text": "Makes Wiegand configuration data to be saved into a file.  UF_RET_CODE UF_MakeWiegandConfiguration( UFConfigComponentHeader* configHeader, BYTE* configData )  Parameters  configHeader \nPointer to the configuration header to be returned. configData \nPointer to the configuration data to be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_MakeWiegandConfiguration"
        },
        {
            "location": "/documents/API_Specification/#example_25",
            "text": "See CUniFingerUIWiegandView::OnWiegandSaveFile in UniFingerUI source codes.",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#319-wiegand-command-card-api",
            "text": "Users can map an input function to a Wiegand ID. When the module detects the mapped IDs in Wiegand input port, it will execute the corresponding input function.   UF_AddWiegandCommandCard: adds a mapping of input function to the specified ID.  UF_GetWiegandCommandCardList: gets all the mapping data.  UF_ClearAllWiegandCommandCard: clears all the mappings.",
            "title": "3.19. Wiegand Command Card API"
        },
        {
            "location": "/documents/API_Specification/#uf_addwiegandcommandcard",
            "text": "Maps the input function to the specified ID.  UF_RET_CODE UF_AddWiegandCommandCard( UINT32 userID, UF_INPUT_FUNC function )  Parameters  userID \nUser ID. function \nAmong the input functions, the followings can be assigned to command cards.     Function  Description      UF_INPUT_ENROLL  Enroll    UF_INPUT_IDENTIFY  Identify    UF_INPUT_DELETE  Delete    UF_INPUT_DELETE_ALL  Delete all    UF_INPUT_ENROLL_BY_WIEGAND  Enroll by Wiegand ID    UF_INPUT_DELETE_BY_WIEGAND  Delete by Wiegand ID    UF_INPUT_ENROLL_VERIFICATION  Enroll after administrator\u2019s verification    UF_INPUT_ENROLL_BY_WIEGAND_VERIFICATION  Enroll by Wiegand ID after administrator\u2019s verification    UF_INPUT_DELETE_VERIFICATION  Delete after administrator\u2019s verification    UF_INPUT_DELETE_BY_WIEGAND_VERIFICATION  Delete by Wiegand ID after administrator\u2019s verification    UF_INPUT_DELETE_ALL_VERIFICATION  Delete all after administrator\u2019s verification     Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_AddWiegandCommandCard"
        },
        {
            "location": "/documents/API_Specification/#uf_getwiegandcommandcardlist",
            "text": "Gets the list of all the command cards.  UF_RET_CODE UF_GetWiegandCommandCardList( int* numOfCard, UFWiegandCommandCard* commandCard )  Parameters  numOfCard \nNumber of command cards to be returned. commandCard \nArray of command card information to be returned. UFWiegandCommandCard is defined as follows;  typedef   struct   { \n     UINT32            userID ; \n     UF_INPUT_FUNC     function ;  }   UFWiegandCommandCard ;   Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetWiegandCommandCardList"
        },
        {
            "location": "/documents/API_Specification/#uf_clearallwiegandcommandcard",
            "text": "Clears all the command card mappings.  UF_RET_CODE UF_ClearAllWiegandCommandCard()  Parameters \nNone  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ClearAllWiegandCommandCard"
        },
        {
            "location": "/documents/API_Specification/#320-smartcard-api",
            "text": "BioEntry Smart readers support MIFARE types of smartcards. These functions provide basic functionalities such as read, write, and format smartcards.   UF_ReadSmartCard: reads a smartcard.  UF_ReadSmartCardWithAG: reads a smartcard with access group information.  UF_WriteSmartCard: writes templates into a smartcard.  UF_WriteSmartCardWithAG: writes templates and access group information into a smartcard.  UF_WriteSmartCardWithEntranceLimit: writes templates, access group information, and entrance limit into a smartcard.  UF_FormatSmartCard: formats a smartcard.  UF_SetSmartCardMode: sets the operation mode.  UF_GetSmartCardMode: gets the operation mode.  UF_ChangePrimaryKey: changes the primary key.  UF_ChangeSecondaryKey: changes the secondary key.  UF_SetKeyOption: sets the site key options.  UF_GetKeyOption: gets the site key options.  UF_SetCardLayout: sets the layout of smartcard.  UF_GetCardLayout: gets the layout of smartcard.  UF_SetSmartCardCallback: sets the callback function for smartcard operation.",
            "title": "3.20. SmartCard API"
        },
        {
            "location": "/documents/API_Specification/#uf_readsmartcard",
            "text": "Reads a smart card.  UF_RET_CODE UF_ReadSmartCard( UFCardHeader* header, BYTE* template1, BYTE* template2 )  Parameters  header \nUFCardHeader is defined as follows;  typedef   struct   { \n     UINT32   csn ;   // 4 byte card serial number \n     UINT32   wiegandLower ;   // lower 4 bytes of Wiegand string \n     UINT32   wiegandHigher ; // higher 4 bytes of Wiegand string \n     BYTE   version ; \n     BYTE   commandType ;   // reserved for command cards. In V1.7 or \n                 // later firmware, this field is used for \n                 // storing entrance limit for non-command cards. \n     BYTE   securityLevel ;   // security level of the user \n     BYTE   numOfTemplate ;   // number of templates stored \n                         // in the card \n     BYTE   template1Duress ;   // 1 if the template1 is \n                         // of duress finger \n     BYTE   template1Length [ 2 ];   // length of template1 \n     BYTE   template2Duress ; \n     BYTE   template2Length [ 2 ];  }   UFCardHeader ;   template1 \nPointer to the first template data read from the smartcard. template2 \nPointer to the second template data read from the smartcard.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ReadSmartCard"
        },
        {
            "location": "/documents/API_Specification/#uf_readsmartcardwithag",
            "text": "Reads a smart card with access group information. As for access group, see  UF_AddAccessGroup.  UF_RET_CODE UF_ReadSmartCardWithAG( UFCardHeader* header, BYTE* template1, BYTE* template2, int* numOfAccessGroup, BYTE* accessGroup )  Parameters  header \nPointer to the UFCardHeader to be returned. template1 \nPointer to the first template data read from the smartcard. template2 \nPointer to the second template data read from the smartcard. numOfAccessGroup \nPointer to the number of access groups assigned to the smartcard. accessGroup \nPointer to the IDs of access groups assigned to the smartcard. The length of each ID is 1 byte.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ReadSmartCardWithAG"
        },
        {
            "location": "/documents/API_Specification/#uf_writesmartcard",
            "text": "Writes template data and header information into a smartcard.  UF_RET_CODE UF_WriteSmartCard( UINT32 userID, UF_CARD_SECURITY_LEVEL securityLevel, int numOfTemplate, int templateSize, BYTE* template1, BOOL duress1, BYTE* template2, BOOL duress2 )  Parameters  userID \nUser ID. securityLevel \nSecurity level. If it is set to UF_SECURITY_READER_DEFAULT, the security level is same as defined in the BioEntry reader. If it is set to UF_SECURITY_BYPASS, the BioEntry reader will bypass the fingerprint authentication. numOfTemplate \nNumber of templates to be written. templateSize \nSize of a template. template1 \nPointer to the first template data. duress1 \nSpecifies if the first template is of a duress finger. template2 \nPointer to the second template data. duress2 \nSpecifies if the second template is of a duress finger.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_WriteSmartCard"
        },
        {
            "location": "/documents/API_Specification/#uf_writesmartcardwithag",
            "text": "Writes template data and access group information into a smartcard.  UF_RET_CODE UF_WriteSmartCardWithAG( UINT32 userID, UF_CARD_SECURITY_LEVEL securityLevel, int numOfTemplate, int templateSize, BYTE* template1, BOOL duress1, BYTE* template2, BOOL duress2, int numOfAccessGroup, BYTE* accessGroup )  Parameters  userID \nUser ID. securityLevel \nSecurity level. If it is set to UF_SECURITY_READER_DEFAULT, the security level is same as defined in the BioEntry reader. If it is set to UF_SECURITY_BYPASS, the BioEntry reader will bypass the fingerprint authentication. numOfTemplate \nNumber of templates to be written. templateSize \nSize of a template. template1 \nPointer to the first template data. duress1 \nSpecifies if the first template is of a duress finger. template2 \nPointer to the second template data. duress2 \nSpecifies if the second template is of a duress finger. numOfAccessGroup \nNumber of access groups assigned to the smartcard. accessGroup \nPointer to the IDs of access group to be written.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_WriteSmartCardWithAG"
        },
        {
            "location": "/documents/API_Specification/#uf_writesmartcardwithentrancelimit",
            "text": "Writes template data, access group, and entrance limit information into a smartcard.  UF_RET_CODE UF_WriteSmartCardWithEntranceLimit( UINT32 userID, UF_CARD_SECURITY_LEVEL securityLevel, int entranceLimit, int numOfTemplate, int templateSize, BYTE* template1, BOOL duress1, BYTE* template2, BOOL duress2, int numOfAccessGroup, BYTE* accessGroup )  Parameters  userID \nUser ID. securityLevel \nSecurity level. If it is set to UF_SECURITY_READER_DEFAULT, the security level is same as defined in the BioEntry reader. If it is set to UF_SECURITY_BYPASS, the BioEntry reader will bypass the fingerprint authentication. entranceLimit \nEntrance limit between 0 and 7. numOfTemplate \nNumber of templates to be written. templateSize \nSize of a template. template1 \nPointer to the first template data. duress1 \nSpecifies if the first template is of a duress finger. template2 \nPointer to the second template data. duress2 \nSpecifies if the second template is of a duress finger. numOfAccessGroup \nNumber of access groups assigned to the smartcard. accessGroup \nPointer to the IDs of access group to be written.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_WriteSmartCardWithEntranceLimit"
        },
        {
            "location": "/documents/API_Specification/#uf_formatsmartcard",
            "text": "Formats a smartcard.  UF_RET_CODE UF_FormatSmartCard( BOOL templateOnly )  Parameters  templateOnly \nIf TRUE, erases only the template area and don\u2019t change the header\ninformation. If FALSE, erase the header information, too.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_FormatSmartCard"
        },
        {
            "location": "/documents/API_Specification/#uf_setsmartcardmode",
            "text": "Sets the operation mode of the BioEntry Smart reader.  UF_RET_CODE UF_SetSmartCardMode( UF_CARD_MODE mode )  Parameters  mode \nOperation mode.     Mode  Description      UF_CARD_DISABLE  Disables the smartcard operation.    UF_CARD_VERIFY_ID  After detecting a smartcard, verifies the fingerprint input with the templates stored in the BioEntry reader.    UF_CARD_VERIFY_TEMPLATE  After detecting a smartcard, verifies the fingerprint input with the templates stored in the card.     Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetSmartCardMode"
        },
        {
            "location": "/documents/API_Specification/#uf_getsmartcardmode",
            "text": "Gets the operation mode.  UF_RET_CODE UF_GetSmartCardMode( UF_CARD_MODE* mode )  Parameters  mode \nPointer to the operation mode to be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetSmartCardMode"
        },
        {
            "location": "/documents/API_Specification/#uf_changeprimarykey",
            "text": "To prevent illegal access, MIFARE card is encrypted using 48bit site key. The site key should be handled with utmost caution. If it is disclosed, the data on the smartcard will not be secure any more.  UF_ChangePrimaryKey  is used to change the primary site key.  UF_RET_CODE UF_ChangePrimaryKey( BYTE* oldPrimaryKey, BYTE* newPrimaryKey )  Parameters  oldPrimaryKey \nPointer to the old site key. newPrimaryKey \nPointer to the new site key.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ChangePrimaryKey"
        },
        {
            "location": "/documents/API_Specification/#uf_changesecondarykey",
            "text": "Changes the secondary site key. The secondary site key is used only when the useSecondaryKey option is set by  UF_SetKeyOption.  UF_RET_CODE UF_ChangeSecondaryKey( BYTE* primaryKey, BYTE* newSecondaryKey )  Parameters  primaryKey \nPointer to the primary key. newSecondaryKey \nPointer to the new secondary key.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ChangeSecondaryKey"
        },
        {
            "location": "/documents/API_Specification/#uf_changesecondarykey_1",
            "text": "Changes the secondary site key. The secondary site key is used only when the useSecondaryKey option is set by  UF_SetKeyOption.  UF_RET_CODE UF_ChangeSecondaryKey( BYTE* primaryKey, BYTE* newSecondaryKey )  Parameters  primaryKey \nPointer to the primary key. newSecondaryKey \nPointer to the new secondary key.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_ChangeSecondaryKey"
        },
        {
            "location": "/documents/API_Specification/#uf_setkeyoption",
            "text": "When changing the site key, BioEntry readers have to handle cards with new site key and cards with old site key at the same time. In that case, useSecondaryKey option can be used. If the secondary key is set to old site key, the reader will handle both types of cards. If autoUpdate option is on, the reader automatically replaces the old site key with new one whenever detecting a smartcard with old key.  UF_RET_CODE UF_SetKeyOption( BYTE* primaryKey, BOOL useSecondaryKey, BOOL autoUpdate )  Parameters  primaryKey \nPointer to the primary key. useSecondaryKey \nIf TRUE, process the cards encrypted with the secondary key. autoUpdate \nIf TRUE, replace the secondary key with primary key when detecting a smartcard encrypted with the secondary key.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetKeyOption"
        },
        {
            "location": "/documents/API_Specification/#uf_getkeyoption",
            "text": "Gets the site key options.  UF_RET_CODE UF_GetKeyOption( BOOL* useSecondaryKey, BOOL* autoUpdate )  Parameters  useSecondaryKey \nPointer to userSecondaryKey option. autoUpdate \nPointer to autoUpdate option.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetKeyOption"
        },
        {
            "location": "/documents/API_Specification/#uf_setcardlayout",
            "text": "Changes the layout of the smartcard. By default, a smartcard stores two fingerprint templates. If there are not sufficient spaces on the card, or some blocks of it are reserved for other data, users can change the layout using this function. Changing card layout should be handled with utmost caution. If you aren\u2019t sure what to do, contact to  support@supremainc.com  first before trying yourself.  UF_RET_CODE UF_SetCardLayout( UFCardLayout* layout )  Parameters  layout \nPointer to the layout information. UFCardLayout is defined as follows;  typedef   struct   { \n     unsigned   short      templateSize ; \n     BYTE                headerBlock ; \n     BYTE                template1StartBlock ; \n     BYTE                template1BlockSize ; \n     BYTE                template2StartBlock ; \n     BYTE                template2BlockSize ;  }   UFCardLayout ;   Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetCardLayout"
        },
        {
            "location": "/documents/API_Specification/#uf_getcardlayout",
            "text": "Gets the card layout information.  UF_RET_CODE UF_GetCardLayout( UFCardLayout* layout )  Parameters  layout \nPointer to UFCardLayout.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetCardLayout"
        },
        {
            "location": "/documents/API_Specification/#uf_setsmartcardcallback",
            "text": "Sets the callback function for smartcard operation. This callback is called after scanning a smartcard successfully.  void UF_SetSmartCardCallback( void (*callback)( BYTE ) )  Parameters  callback \nPointer to the callback function.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetSmartCardCallback"
        },
        {
            "location": "/documents/API_Specification/#321-access-control-api",
            "text": "Since V1.6 firmware, BioEntry readers provide access control features such as time schedule and access group. By using these functions, user\u2019s access can be controlled in finer detail.   UF_AddTimeSchedule: adds a time schedule.  UF_GetTimeSchedule: reads the specified time schedule.  UF_DeleteTimeSchedule: deletes a time schedule.  UF_DeleteAllTimeSchedule: deletes all time schedules.  UF_AddHoliday: adds a holiday schedule.  UF_GetHoliday: reads the specified holiday schedule.  UF_DeleteHoliday: deletes a holiday schedule.  UF_DeleteAllHoliday: deletes all holiday schedules.  UF_AddAccessGroup: adds an access group.  UF_GetAccessGroup: reads the specified access group.  UF_DeleteAccessGroup: deletes an access group.  UF_DeleteAllAccessGroup: deletes all access groups.  UF_SetUserAccessGroup: assigns access groups to a user.  UF_GetUserAccessGroup: gets the access groups of a user.",
            "title": "3.21. Access Control API"
        },
        {
            "location": "/documents/API_Specification/#uf_addtimeschedule",
            "text": "A BioEntry reader can store up to 64 time schedules. Each time schedule consists of 7 daily schedules and an optional holiday schedule. And each daily schedule may have up to 5 time segments.  #define UF_TIMECODE_PER_DAY       5  typedef   struct   { \n     unsigned   short   startTime ;   // start time in minutes \n     unsigned   short   endTime ;   // end time in minutes  }   UFTimeCodeElem ;  typedef   struct   { \n     UFTimeCodeElem   codeElement [ UF_TIMECODE_PER_DAY ];  }   UFTimeCode ;  typedef   struct   { \n     int   scheduleID ; \n     UFTimeCode   timeCode [ 7 ];   // 0 - Sunday, 1 - Monday, ... \n     int   holidayID ;  }   UFTimeSchedule ;   UF_RET_CODE UF_AddTimeSchedule( UFTimeSchedule* schedule )  Parameters  schedule \nPointer to the time schedule to be added.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_AddTimeSchedule"
        },
        {
            "location": "/documents/API_Specification/#example_26",
            "text": "UFTimeSchedule   timeSchedule ;  memset (   & timeSchedule ,   0 ,   sizeof ( UFTimeSchedule )   );   // clear the structure  timeSchedule . scheduleID   =   1 ;  timeSchedule . holidayID   =   1 ;  // Monday- 09:00 ~ 18:00  timeSchedule . timeCode [ 1 ]. codeElement [ 0 ]. startTime   =   9   *   60 ;  timeSchedule . timeCode [ 1 ]. codeElement [ 0 ]. endTime   =   18   *   60 ;  // Tuesday- 08:00 ~ 12:00 and 14:30 ~ 20:00  timeSchedule . timeCode [ 2 ]. codeElement [ 0 ]. startTime   =   8   *   60 ;  timeSchedule . timeCode [ 2 ]. codeElement [ 0 ]. endTime   =   12   *   60 ;  timeSchedule . timeCode [ 2 ]. codeElement [ 1 ]. startTime   =   14   *   60   +   30 ;  timeSchedule . timeCode [ 2 ]. codeElement [ 1 ]. endTime   =   20   *   60 ;  // \u2026  UF_RET_CODE   result   =   UF_AddTimeSchedule (   & timeSchedule   );",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_gettimeschedule",
            "text": "Reads the specified time schedule.  UF_RET_CODE UF_GetTimeSchedule( int ID, UFTimeSchedule* schedule )  Parameters  ID \nID of the time schedule. schedule \nPointer to the time schedule to be read.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetTimeSchedule"
        },
        {
            "location": "/documents/API_Specification/#uf_deletetimeschedule",
            "text": "Deletes the specified time schedule.  UF_RET_CODE UF_DeleteTimeSchedule( int ID )  Parameters  ID \nID of the time schedule.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_DeleteTimeSchedule"
        },
        {
            "location": "/documents/API_Specification/#uf_deletealltimeschedule",
            "text": "Deletes all the time schedules stored in a BioEntry reader.  UF_RET_CODE UF_DeleteAllTimeSchedule()  Parameters \nNone  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the\ncorresponding error code.",
            "title": "UF_DeleteAllTimeSchedule"
        },
        {
            "location": "/documents/API_Specification/#uf_addholiday",
            "text": "Each time schedule may have an optional holiday schedule. A holiday schedule consists of a holiday list and a daily schedule for it.  typedef   struct   { \n     int   holidayID ; \n     int   numOfHoliday ; \n     unsigned   short   holiday [ 32 ];   // (month << 8) | day \n     UFTimeCode   timeCode ;  }   UFHoliday ;   UF_RET_CODE UF_AddHoliday( UFHoliday* holiday )  Parameters  holiday \nPointer to the holiday schedule to be added.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_AddHoliday"
        },
        {
            "location": "/documents/API_Specification/#example_27",
            "text": "UFHoliday   holiday ;  memset (   & holiday ,   0 ,   sizeof ( UFHoliday )   );   // clear the structure  holiday . holidayID   =   1 ;  holiday . numOfHoliday   =   10 ;  // Jan. 1 is holiday  holiday . holiday [ 0 ]   =   ( 1   <<   8 )   |   1 ;  // Mar. 5 is holiday  holiday . holiday [ 1 ]   =   ( 3   <<   8 )   |   5 ;  // \u2026  // Access is granted during 09:00 ~ 10:00 on holideys  holiday . timeCode . codeElement [ 0 ]. startTime   =   9   *   60 ;  holiday . timeCode . codeElement [ 0 ]. endTime   =   10   *   60 ;  UF_RET_CODE   result   =   UF_AddHoliday (   & holiday   );",
            "title": "Example"
        },
        {
            "location": "/documents/API_Specification/#uf_getholiday",
            "text": "Reads the specified holiday schedule.  UF_RET_CODE UF_GetHoliday( int ID, UFHoliday* holiday )  Parameters  ID \nID of the holiday schedule. holiday \nPointer to the holiday schedule to be read.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetHoliday"
        },
        {
            "location": "/documents/API_Specification/#uf_deleteholiday",
            "text": "Deletes the specified holiday schedule.  UF_RET_CODE UF_DeleteHoliday( int ID )  Parameters  ID \nID of the holiday schedule.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_DeleteHoliday"
        },
        {
            "location": "/documents/API_Specification/#uf_deleteallholiday",
            "text": "Deletes all the holiday schedules stored in a BioEntry reader.  UF_RET_CODE UF_DeleteAllHoliday()  Parameters \nNone  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_DeleteAllHoliday"
        },
        {
            "location": "/documents/API_Specification/#uf_addaccessgroup",
            "text": "Each access group may have up to 16 time schedules. The access of members is granted only when the time belongs to the time schedules of the group.  #define UF_SCHEDULE_PER_GROUP    16  typedef   struct   { \n     int   groupID ; \n     int   numOfSchedule ; \n     int   scheduleID [ UF_SCHEDULE_PER_GROUP ];  }   UFAccessGroup ;   UF_RET_CODE UF_AddAccessGroup( UFAccessGroup* group )  Parameters  group \nPointer to the access group to be added.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_AddAccessGroup"
        },
        {
            "location": "/documents/API_Specification/#uf_getaccessgroup",
            "text": "Reads the specified access group.  UF_RET_CODE UF_GetAccessGroup( int ID, UFAccessGroup* group )  Parameters  ID \nID of the access group. group \nPointer to the access group to be read.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetAccessGroup"
        },
        {
            "location": "/documents/API_Specification/#uf_deleteaccessgroup",
            "text": "Deletes the specified access group.  UF_RET_CODE UF_DeleteAccessGroup( int ID )  Parameters  ID \nID of the access group.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_DeleteAccessGroup"
        },
        {
            "location": "/documents/API_Specification/#uf_deleteallaccessgroup",
            "text": "Deletes all the access groups stored in a BioEntry reader.  UF_RET_CODE UF_DeleteAllAccessGroup()  Parameters \nNone  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_DeleteAllAccessGroup"
        },
        {
            "location": "/documents/API_Specification/#uf_setuseraccessgroup",
            "text": "Assigns access groups to a user. A user can be a member of up to 4 access groups.  UF_RET_CODE UF_SetUserAccessGroup( UINT32 userID, int numOfGroup, int* groupID )  Parameters  userID \nUser ID. numOfGroup \nNumber of access groups to be assigned. groupID \nArray of access group IDs to be assigned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_SetUserAccessGroup"
        },
        {
            "location": "/documents/API_Specification/#uf_getuseraccessgroup",
            "text": "Reads the IDs of access groups assigned to a user.  UF_RET_CODE UF_GetUserAccessGroup( UINT32 userID, int* numOfGroup, int* groupID )  Parameters  userID \nUser ID. numOfGroup \nPointer to the number of access groups to be returned. groupID \nArray of access group IDs to be returned.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetUserAccessGroup"
        },
        {
            "location": "/documents/API_Specification/#322-blacklist-api",
            "text": "When a user ID is added to the blacklist, authentication will always fail regardless of fingerprint matching result. The blacklist takes precedence over the authentication type of a user. For example, though the authentication mode of a user is UF_AUTH_BYPASS, the authentication would fail if it is in the blacklist. The blacklist can store up to 1022 user IDs.   UF_AddBlacklist: adds an ID to the blacklist.  UF_DeleteBlacklist: deletes an ID from the blacklist.  UF_GetBlacklist: reads the IDs in the blacklist.  UF_DeleteAllBlacklist: clears the blacklist.",
            "title": "3.22. Blacklist API"
        },
        {
            "location": "/documents/API_Specification/#uf_addblacklist",
            "text": "Adds a user ID to the blacklist.  UF_RET_CODE UF_AddBlacklist( UINT32 userID, int* numOfBlacklistedID )  Parameters  userID \nUser ID. numOfBlacklistedID \nNumber of IDs in the blacklist after adding.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_AddBlacklist"
        },
        {
            "location": "/documents/API_Specification/#uf_deleteblacklist",
            "text": "Deletes an ID from the blacklist.  UF_RET_CODE UF_DeleteBlacklist( UINT32 userID, int* numOfBlacklistedID )  Parameters  userID \nUser ID. numOfBlacklistedID \nNumber of IDs in the blacklist after deleting.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_DeleteBlacklist"
        },
        {
            "location": "/documents/API_Specification/#uf_getblacklist",
            "text": "Receive user IDs in the blacklist.  UF_RET_CODE UF_GetBlacklist( int* numOfBlacklistedID, UINT32* userID )  Parameters  numOfBlacklistedID \nPointer to the number of IDs in the blacklist. userID \nArray of user IDs in the blacklist. This should be pre-allocated large enough.  Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_GetBlacklist"
        },
        {
            "location": "/documents/API_Specification/#uf_deleteallblacklist",
            "text": "Clears the blacklist.  UF_RET_CODE UF_DeleteAllBlacklist()  Parameters \nNone Return Values \nIf the function succeeds, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.",
            "title": "UF_DeleteAllBlacklist"
        },
        {
            "location": "/documents/API_Specification/#323-wsq-api",
            "text": "",
            "title": "3.23. WSQ API"
        },
        {
            "location": "/documents/API_Specification/#uf_scanimageex",
            "text": "",
            "title": "UF_ScanImageEx"
        },
        {
            "location": "/documents/API_Specification/#uf_readimageex",
            "text": "",
            "title": "UF_ReadImageEx"
        },
        {
            "location": "/documents/API_Specification/#uf_wsq_decode",
            "text": "",
            "title": "UF_WSQ_Decode"
        },
        {
            "location": "/documents/API_Specification/#contact-info",
            "text": "Headquarters   Suprema, Inc. ( http://www.supremainc.com )\n16F Parkview Office Tower,\nJoengja-dong, Bundang-gu,\nSeongnam, Gyeonggi, 463-863 Korea\nTel: +82-31-783-4505\nFax:+82-31-783-4506\nEmail:  sales@supremainc.com ,  support@supremainc.com",
            "title": "Contact Info"
        },
        {
            "location": "/documents/UF_Protocol_Manual/",
            "text": "",
            "title": "UF Protocol Manual"
        },
        {
            "location": "/sdk/c_cpp/",
            "text": "",
            "title": "C/C++"
        },
        {
            "location": "/sdk/c_sharp/",
            "text": "",
            "title": ".NET"
        },
        {
            "location": "/sdk/android/",
            "text": "",
            "title": "android"
        },
        {
            "location": "/sdk/python/",
            "text": "",
            "title": "python"
        },
        {
            "location": "/community/community/",
            "text": "",
            "title": "Community"
        },
        {
            "location": "/projects/SFM_OPEN_EVK/",
            "text": "",
            "title": "SFM Open EVK"
        }
    ]
}